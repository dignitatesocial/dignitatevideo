{
  "name": "Dignitate Content Automation (v3.9-direct-after-split-2026-02-10)",
  "nodes": [
    {
      "parameters": {
        "updates": [
          "message",
          "callback_query"
        ]
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000001",
      "name": "Telegram Trigger",
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000001",
      "position": [
        -688,
        400
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000002",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -688,
        700
      ],
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Load conversation history and build LLM context with lightweight memory\nconst update = $input.first().json || {};\nconst telegramMessage = update.message || update.callback_query?.message || {};\nconst message = String(update.message?.text || update.callback_query?.data || '');\nconst chatId = update.message?.chat?.id || update.callback_query?.message?.chat?.id || update.callback_query?.from?.id;\nconst messageId = update.message?.message_id || update.callback_query?.message?.message_id || update.callback_query?.id || null;\nconst replyToText = String(telegramMessage.reply_to_message?.text || '').trim();\nconst replyToMessageId = telegramMessage.reply_to_message?.message_id || null;\nconst repliedByBot = Boolean(telegramMessage.reply_to_message?.from?.is_bot);\nconst isSlash = message.trim().startsWith('/');\n\n// If this is a callback query, keep the original message text for fallback parsing\nconst sourceMessageText = String(update.callback_query?.message?.text || '').trim();\nconst sourceMessageId = update.callback_query?.message?.message_id || null;\nconst callbackQueryId = update.callback_query?.id || null;\n\nconst staticData = $getWorkflowStaticData('global');\nif (chatId) staticData.defaultChatId = String(chatId);\nif (!staticData.conversations) staticData.conversations = {};\nif (!staticData.userMemory) staticData.userMemory = {};\n\nconst chatKey = String(chatId || '');\nconst now = Date.now();\nconst TWO_HOURS = 2 * 60 * 60 * 1000;\n\nif (staticData.conversations[chatKey] && (now - staticData.conversations[chatKey].lastActivity) > TWO_HOURS) {\n  delete staticData.conversations[chatKey];\n}\n\nif (!staticData.conversations[chatKey]) {\n  staticData.conversations[chatKey] = { messages: [], lastActivity: now };\n}\n\nconst conv = staticData.conversations[chatKey];\nconv.lastActivity = now;\n\nif (message) {\n  conv.messages.push({ role: 'user', content: message });\n}\n\nif (conv.messages.length > 12) {\n  conv.messages = conv.messages.slice(-12);\n}\n\nconst pending = staticData.pendingContent?.[chatKey] || null;\nconst mem = staticData.userMemory[chatKey] || {};\n\nconst memorySummary = [\n  pending ? `pending_type=${pending.type || 'unknown'}` : 'pending_type=none',\n  pending ? `pending_title=\"${(pending.title || pending.args || 'untitled').replace(/\"/g, \"'\")}\"` : 'pending_title=none',\n  mem.lastAction ? `last_action=${mem.lastAction}` : 'last_action=none',\n  mem.lastTopic ? `last_topic=\"${String(mem.lastTopic).replace(/\"/g, \"'\")}\"` : 'last_topic=none'\n].join('; ');\n\nconst systemPrompt = `You are Dignitate's assistant in Telegram. Dignitate is a UK charity supporting cultural carers in the dementia journey.\n\nBehave like a natural LLM chat assistant: warm, practical, concise, and context-aware.\n- Default to natural conversation, not command-style instructions.\n- Do not mention slash commands unless the user explicitly asks.\n- Keep most replies to 1-3 short sentences.\n- Ask at most one clarifying question only when essential.\n- If user confirms (for example: yes, do it, go ahead, make it), use prior context and proceed.\n\nCAPABILITIES:\n- Create Instagram carousel drafts with generated images\n- Create short-form video drafts\n- Pull latest dementia-care trends\n- Approve/regenerate pending drafts for posting\n\nALWAYS return valid JSON only, no markdown, no extra text:\n{\"reply\":\"assistant reply\",\"action\":{\"type\":\"carousel|video|both|trends|approve|regenerate|status|help|none\",\"topic\":\"topic or empty\"}}\n\nACTION POLICY:\n- If user clearly asks for a carousel, set type=carousel.\n- If user clearly asks for a video/reel/tiktok, set type=video.\n- If user asks for both formats, set type=both.\n- If user asks for trends or what to post now, set type=trends.\n- If user asks to post/approve/publish, set type=approve.\n- If user asks to redo/regenerate/try again, set type=regenerate.\n- If user asks for status/help, set type=status/help.\n- If it is normal chat without execution request, set type=none.\n- When action is carousel/video/both and topic is implied by context, infer topic from context.`;\n\nconst memoryMessage = `Conversation memory: ${memorySummary}`;\n\nconst aiMessages = [\n  { role: 'system', content: systemPrompt },\n  { role: 'system', content: memoryMessage },\n  ...conv.messages\n];\n\nconst aiMessagesJson = JSON.stringify(aiMessages);\n\nreturn [{\n  json: {\n    message,\n    chatId,\n    messageId,\n    replyToText,\n    replyToMessageId,\n    repliedByBot,\n    isSlash,\n    sourceMessageText,\n    sourceMessageId,\n    callbackQueryId,\n    conversationHistory: conv.messages,\n    aiMessagesJson,\n    memorySummary\n  }\n}];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000003",
      "name": "Load Chat History",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -464,
        400
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ String($json.isSlash) }}",
                    "rightValue": "true",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Slash"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000004",
      "name": "Is Slash Command?",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -240,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"z-ai/glm-5\",\n  temperature: 0.55,\n  messages: [\n    {\n      role: \"system\",\n      content: \"You create educational Instagram carousel scripts for Dignitate (UK dementia-care support for carers). UK English. Factual, compassionate, plain language. Output STRICT JSON only, no markdown, no extra text.\"\n    },\n    {\n      role: \"user\",\n      content:\n        \"TOPIC LOCK (must stay exact): \" + ($json.args || \"dementia caregiving support in the UK\") +\n        \"\\n\\nSELECTED ARTICLE FACT ANCHOR (highest priority):\\n\" +\n        JSON.stringify({\n          summary: $json.selectedTrendSummary || '',\n          source_name: $json.selectedTrendSourceName || '',\n          source_url: $json.selectedTrendSourceUrl || '',\n          published_at: $json.selectedTrendPublishedAt || ''\n        }, null, 2) +\n        \"\\n\\nRESEARCH SUMMARY (context only; do not invent numbers):\\n\" + ($json.researchSummary || \"No research summary available.\") +\n        \"\\n\\nRESEARCH FACTS (ONLY source for numbers/claims):\\n\" + JSON.stringify($json.researchFacts || [], null, 2) +\n        \"\\n\\nPRACTICAL ACTIONS FOR CARERS (use as ideas):\\n\" + JSON.stringify($json.researchActions || [], null, 2) +\n        \"\\n\\nNARRATIVE FLOW SUGGESTIONS (use as slide intent; do not quote verbatim):\\n\" + JSON.stringify($json.narrativeFlow || {}, null, 2) +\n        \"\\n\\nTASK: Create exactly 5 slides. Each slide must have a SHORT heading + a USEFUL subline.\" +\n        \"\\n\\nTEXT RULES (very important):\" +\n        \"\\n- No meta labels. Never use: Why this matters now, What changed, Evidence update, Key takeaway, Next step, Conclusion.\" +\n        \"\\n- Never include recommendation/search/debug language such as: recommendation, search results, could not find, topic lock, schema.\" +\n        \"\\n- No colons in the heading.\" +\n        \"\\n- Heading: 3-8 words.\" +\n        \"\\n- Subline: 18-26 words (you may use 2 short sentences).\" +\n        \"\\n- No dense paragraphs. No bullets. No hashtags inside the slide text.\" +\n        \"\\n- Avoid generic filler. Every subline must contain a concrete detail (number, UK service like GP/NHS, a symptom/sign, or a step you can do today).\" +\n        \"\\n- If a number is not present in research facts, do not invent it.\" +\n        \"\\n- If selected article anchor exists, keep wording aligned to that anchor and do not switch topic.\" +\n        \"\\n- Slide 2 MUST be based on one item from RESEARCH FACTS (do not write a generic line).\" +\n        \"\\n- Slide 3 MUST be based on a DIFFERENT RESEARCH FACT, or explain the Slide 2 fact in plain language.\" +\n        \"\\n- Slide 4 MUST be based on one item from PRACTICAL ACTIONS (specific, step-like).\" +\n        \"\\n- Slide 5 MUST feel like an ending: short recap + reassurance (you are not alone) + clear CTA.\" +\n        \"\\n\\nCONTENT STRUCTURE:\" +\n        \"\\n1) cover: punchy promise for carers\" +\n        \"\\n2) information: include ONE key number if available OR one crisp fact\" +\n        \"\\n3) information: explain what the fact means in plain language\" +\n        \"\\n4) action: one practical step today (specific, not vague)\" +\n        \"\\n5) conclusion: recap + one practical next step + reassurance + CTA: Follow Dignitate for support\" +\n        \"\\n\\nCAPTION RULES:\" +\n        \"\\n- 2-4 short sentences.\" +\n        \"\\n- Include one clear next step + CTA: Follow Dignitate for support.\" +\n        \"\\n- Do not include links.\" +\n        \"\\n\\nIMAGE PROMPT RULES (one clean scene each):\" +\n        \"\\n- 4:5 portrait. Editorial UK healthcare documentary realism.\" +\n        \"\\n- Each slide must have a DIFFERENT scene idea and DIFFERENT setting.\" +\n        \"\\n- Scene must match the slide meaning AND reflect the topic using relevant props (e.g. coffee cup, GP leaflet, calendar).\" +\n        \"\\n- One scene only. No collage/grid/split-screen/storyboard. No text overlays, no logos.\" +\n        \"\\n\\nOUTPUT JSON ONLY (exact shape):\" +\n        \"\\n{\\\"title\\\":\\\"...\\\",\\\"slides\\\":[{\\\"role\\\":\\\"cover\\\"|\\\"information\\\"|\\\"conclusion\\\",\\\"heading\\\":\\\"...\\\",\\\"subline\\\":\\\"...\\\",\\\"imagePrompt\\\":\\\"...\\\"}],\\\"hashtags\\\":[\\\"#DementiaCare\\\",\\\"#CarerSupport\\\",\\\"#UKHealth\\\",\\\"#Dignitate\\\"],\\\"caption\\\":\\\"...\\\"}\"\n    }\n  ]\n}) }}\n",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000007",
      "name": "OpenRouter - Carousel Script",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        460,
        160
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"z-ai/glm-5\",\n  temperature: 0.6,\n  messages: [\n    {\n      role: \"system\",\n      content: \"You write punchy, high-retention UK short-form vertical video scripts for Dignitate (dementia-care support for carers). Use UK English. Direct, warm, confident. Output STRICT JSON only.\"\n    },\n    {\n      role: \"user\",\n      content:\n        \"TOPIC LOCK (must stay exact): \" + ($json.args || \"signs of caregiver burnout\") +\n        \"\\n\\nSELECTED ARTICLE FACT ANCHOR (highest priority):\\n\" +\n        JSON.stringify({\n          summary: $json.selectedTrendSummary || '',\n          source_name: $json.selectedTrendSourceName || '',\n          source_url: $json.selectedTrendSourceUrl || '',\n          published_at: $json.selectedTrendPublishedAt || ''\n        }, null, 2) +\n        \"\\n\\nRESEARCH SUMMARY:\\n\" + ($json.researchSummary || \"No research summary available.\") +\n        \"\\n\\nRESEARCH FACTS (ONLY source for numbers/claims):\\n\" + JSON.stringify($json.researchFacts || [], null, 2) +\n        \"\\n\\nPRACTICAL ACTIONS (use for step language):\\n\" + JSON.stringify($json.researchActions || [], null, 2) +\n        \"\\n\\nVIDEO MODE: \" + ($json.videoMode || \"kling_multiclip\") +\n        \"\\n\\n\" + ((String($json.videoMode || \"\").toLowerCase() === \"talking_head\")\n          ? \"TASK: Write ONE vertical short as a TALKING-HEAD presenter clip: exactly 1 scene (30 seconds).\"\n          : \"TASK: Write ONE vertical short as MULTI-SHOT b-roll: exactly 2 scenes (12 seconds each).\") +\n        \"\\n\\nSCRIPT RULES:\" +\n        \"\\n- Hook fast. First line is a question or bold statement.\" +\n        \"\\n- Speak directly to one person (you/your).\" +\n        \"\\n- Plain language only, no academic tone.\" +\n        \"\\n- Use at most ONE statistic, and only if present in RESEARCH FACTS.\" +\n        \"\\n- Never include recommendation/search/debug lines (recommendation, search results, topic lock, schema, could not find).\" +\n        \"\\n- Never use these labels: Why this matters now, What changed, Evidence update, Key takeaway, Next step, Conclusion.\" +\n        \"\\n- No bullets, no headings, no stage directions, no citations, no URLs.\" +\n        \"\\n- Keep wording aligned to selected article anchor and do not switch topic.\" +\n        \"\\n\\nTIMING (strict):\\n\" + ((String($json.videoMode || \"\").toLowerCase() === \"talking_head\")\n          ? \"- Narration: 65-82 words. Include hook + 2 points + 1 practical step + CTA: Follow Dignitate for support.\"\n          : \"- Scene 1 narration: 22-30 words, hook + one concrete fact + one practical step.\\n- Scene 2 narration: 22-30 words, what it means + one action + CTA: Follow Dignitate for support.\") +\n        \"\\n\\nVISUAL PROMPT RULES:\" +\n        \"\\n- Vertical 9:16 documentary/editorial photorealism.\" +\n        \"\\n- Talking head: podcast-style presenter with visible microphone, chest-up.\" +\n        \"\\n- Multi-shot: different angle and different environment per scene.\" +\n        \"\\n- B-roll only: no visible lip movement or speaking-to-camera direction.\" +\n        \"\\n- Leave bottom 30% clean for subtitles.\" +\n        \"\\n- No collage/grid/split-screen/text/logos/watermarks.\" +\n        \"\\n\\nOUTPUT JSON ONLY (exact shape):\\n\" +\n        ((($json.videoMode || \"\").toLowerCase() === \"talking_head\")\n          ? \"{\\\"title\\\":\\\"...\\\",\\\"scenes\\\":[{\\\"type\\\":\\\"hook\\\",\\\"narration\\\":\\\"...\\\",\\\"visualPrompt\\\":\\\"...\\\",\\\"duration\\\":30}],\\\"hashtags\\\":[\\\"#DementiaCare\\\",\\\"#CarerSupport\\\",\\\"#UKHealth\\\",\\\"#Dignitate\\\"],\\\"caption\\\":\\\"...\\\"}\"\n          : \"{\\\"title\\\":\\\"...\\\",\\\"scenes\\\":[{\\\"type\\\":\\\"hook\\\",\\\"narration\\\":\\\"...\\\",\\\"visualPrompt\\\":\\\"...\\\",\\\"duration\\\":12},{\\\"type\\\":\\\"cta\\\",\\\"narration\\\":\\\"...\\\",\\\"visualPrompt\\\":\\\"...\\\",\\\"duration\\\":12}],\\\"hashtags\\\":[\\\"#DementiaCare\\\",\\\"#CarerSupport\\\",\\\"#UKHealth\\\",\\\"#Dignitate\\\"],\\\"caption\\\":\\\"...\\\"}\")\n    }\n  ]\n}) }}\n",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000008",
      "name": "OpenRouter - Video Script",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        460,
        400
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"perplexity/sonar-pro\",\n  messages: [\n    {\n      role: \"system\",\n      content: \"You are a trend analyst for Dignitate, a UK dementia-care organisation supporting cultural carers. Return strict JSON only.\"\n    },\n    {\n      role: \"user\",\n      content:\n        \"Find 12 diverse high-engagement trend topics about dementia care and carers from the last 7 days (prioritize last 72 hours).\" +\n        \" Focus UK first, but include major global developments with clear UK relevance.\" +\n        \" Cover varied areas: policy, clinical research, caregiving practice, social care delivery, community support, legal rights, workforce, prevention, digital health, finance, and lived-experience stories.\" +\n        \" Avoid near-duplicate topics and avoid repeating the same angle.\" +\n        \" Return ONLY JSON array with exactly 12 items and this schema:\" +\n        \" [{\\\"title\\\":\\\"...\\\",\\\"summary\\\":\\\"2-3 sentences\\\",\\\"engagement_score\\\":8,\\\"category\\\":\\\"policy|research|caregiving|community|technology|finance|legal|clinical\\\",\\\"region\\\":\\\"UK|Global-UK\\\"}]\"\n    }\n  ]\n}) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000009",
      "name": "OpenRouter - Trends",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        460,
        640
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "Everything is running smoothly.\\nBuild: v3-stable-2026-02-11-lock-throttle-fix\\n\\nI can research a topic, create carousel or video drafts, pull trends, and post approved drafts.\\n\\nTell me what you want to create, for example: \"Create a carousel about caregiver burnout in South Asian families.\"",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000010",
      "name": "Status Response",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000010",
      "position": [
        0,
        820
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "I can work like a normal chat assistant.\n\nTry prompts like:\n- Create a carousel about dementia-friendly home routines\n- Make a short video about signs of caregiver burnout\n- What are the latest UK dementia-care trends?\n- This looks good, post it\n- Regenerate this with a more hopeful tone\n\nCreator profile for realistic videos:\n- /setface <public_image_url>\n- /setvoiceid <elevenlabs_voice_id>\n- /creator\n- /commands\n\nAuto mode is currently disabled.\n\nGive me your topic and preferred format, and I will handle the workflow.",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000011",
      "name": "Help Response",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000011",
      "position": [
        0,
        1020
      ]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json || {};\nconst rawContent = response.choices?.[0]?.message?.content || '{}';\nconst content = Array.isArray(rawContent)\n  ? rawContent.map((c) => c?.text || '').join('\\n')\n  : String(rawContent || '{}');\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n\\t]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction stripMeta(text) {\n  let t = clean(text);\n  if (!t) return t;\n  t = t\n    .replace(/^(why this matters now|what changed|evidence update|what this means for carers|next step|key takeaway|conclusion)\\s*[:\\-]\\s*/i, '')\n    .replace(/\\b(why\\s+this\\s+matters\\s+now|what\\s+changed|evidence\\s+update|key\\s+takeaway|next\\s+step|conclusion)\\b\\s*[:\\-]?\\s*/ig, '')\n    .trim();\n  return t;\n}\n\nfunction parseJsonLoose(text) {\n  const t = String(text || '').trim();\n  if (!t) return null;\n  const stripped = t\n    .replace(/^\\x60\\x60\\x60json\\s*/i, '')\n    .replace(/^\\x60\\x60\\x60\\s*/i, '')\n    .replace(/\\x60\\x60\\x60$/i, '')\n    .trim();\n  try { return JSON.parse(stripped); } catch (e) {}\n  const start = stripped.indexOf('{');\n  const end = stripped.lastIndexOf('}');\n  if (start >= 0 && end > start) {\n    try { return JSON.parse(stripped.slice(start, end + 1)); } catch (e2) {}\n  }\n  return null;\n}\n\nfunction words(text) {\n  return stripMeta(text).split(/\\s+/).filter(Boolean);\n}\n\nfunction isLeakText(text) {\n  const t = clean(text).toLowerCase();\n  if (!t) return true;\n  const bad = [\n    'to complete this research task',\n    'search specifically for',\n    'search results provided do not contain',\n    'do not contain any information',\n    'return strict json',\n    'topic lock',\n    'output json only',\n    'schema',\n    'recommendation:',\n    '\"explanation\"',\n    \"'explanation'\"\n  ];\n  if (bad.some((p) => t.includes(p))) return true;\n  if (/^\\s*[\\[{]/.test(t)) return true;\n  return false;\n}\n\nfunction hasActionVerb(text) {\n  return /\\b(ask|check|book|call|write|plan|track|share|speak|request|tell|save|note|ring|message|visit|print|bring|keep|set|add|create|use|contact|attend|register)\\b/i.test(text);\n}\n\nfunction hasConcreteDetail(text) {\n  if (/\\d/.test(text)) return true;\n  return /\\b(gp|nhs|memory\\s+clinic|icb|care\\s+board|hospital|appointment|medication|meds|sleep|hydration|carer|carers|leaflet|calendar|referral|assessment|community\\s+team|social\\s+care|england|uk)\\b/i.test(text);\n}\n\nfunction sanitizeHeading(text, fallback) {\n  let h = stripMeta(text);\n  if (!h || isLeakText(h)) h = fallback;\n  h = words(h).slice(0, 8).join(' ');\n  if (words(h).length < 3) h = words(fallback).slice(0, 8).join(' ');\n  return h.split(' ').map((w) => w ? (w.charAt(0).toUpperCase() + w.slice(1)) : '').join(' ').trim();\n}\n\nfunction sanitizeSubline(text, fallback) {\n  let s = stripMeta(text);\n  if (!s || isLeakText(s)) s = fallback;\n  if (!hasActionVerb(s) && !hasConcreteDetail(s)) s = fallback;\n\n  const maxWords = 26;\n  let arr = words(s);\n  if (arr.length > maxWords) arr = arr.slice(0, maxWords);\n  if (arr.length < 14) {\n    const extra = words(fallback);\n    for (const w of extra) {\n      if (arr.length >= 14) break;\n      arr.push(w);\n    }\n  }\n\n  let out = arr.join(' ');\n  out = clean(out);\n  if (!/[.!?]$/.test(out)) out = out + '.';\n  return out;\n}\n\nfunction normalizeFact(v) {\n  if (!v) return '';\n  if (typeof v === 'string') return clean(v);\n\n  const fact = clean(v.fact || v.statement || v.text || v.value || '');\n  const source = clean(v.source || '');\n  const date = clean(v.date || v.year || '');\n  if (!fact) return '';\n\n  const lower = fact.toLowerCase();\n  const parts = [];\n  if (source && !lower.includes(source.toLowerCase())) parts.push(source);\n  if (date && !lower.includes(date.toLowerCase())) parts.push(date);\n  if (!parts.length) return fact;\n\n  return clean(fact + ' (' + parts.join(', ') + ')');\n}\n\nfunction normalizeAction(v) {\n  if (!v) return '';\n  if (typeof v === 'string') return clean(v);\n  return clean(v.action || v.step || v.text || v.value || '');\n}\n\nfunction sanitizeImagePrompt(text, fallback) {\n  let t = clean(text);\n  if (!t || isLeakText(t)) t = fallback;\n  t = t\n    .replace(/\\b(collage|grid|mosaic|split\\s*screen|diptych|triptych|storyboard|multi\\s*panel|comic\\s*panel)\\b/gi, '')\n    .replace(/\\s{2,}/g, ' ')\n    .trim();\n  return t || fallback;\n}\n\nfunction extractHeadingSubline(slide) {\n  const heading = clean(slide?.heading || slide?.slideHeading || '');\n  const subline = clean(slide?.subline || slide?.slideBody || '');\n  if (heading || subline) return { heading, subline };\n\n  const text = clean(slide?.text || slide?.caption || '');\n  if (!text) return { heading: '', subline: '' };\n\n  const idx = text.indexOf(':');\n  if (idx > 0 && idx < 90) {\n    return { heading: clean(text.slice(0, idx)), subline: clean(text.slice(idx + 1)) };\n  }\n\n  const w = words(text);\n  return { heading: w.slice(0, 7).join(' '), subline: w.slice(7).join(' ') };\n}\n\nconst parsed = parseJsonLoose(content) || {};\n\nlet base = {};\ntry { base = $('Parse Carousel Research').first().json || {}; } catch (e) {}\n\nlet commandData = {};\ntry { commandData = $('Load Chat History').first().json || {}; } catch (e) {}\n\nconst requestedTopic = clean(base.args || base.requestedTopic || commandData.args || parsed.title || 'Dementia care support in England');\nconst researchBlocked = Boolean(base.researchBlocked);\nconst researchBlockReason = clean(base.researchBlockReason || '');\nconst isEventTopic = /\\b(conference|summit|event|meeting|forum|congress|workshop)\\b/i.test(requestedTopic);\n\nconst facts = (Array.isArray(base.researchFacts) ? base.researchFacts : [])\n  .map(normalizeFact)\n  .filter((f) => f && !isLeakText(f));\n\nconst actions = (Array.isArray(base.researchActions) ? base.researchActions : [])\n  .map(normalizeAction)\n  .filter((a) => a && !isLeakText(a));\n\nconst fact1 = facts[0] || (isEventTopic\n  ? 'Public event programme details can change before publication, so rely on official organiser pages for confirmed agenda, dates, and registration updates.'\n  : 'Support needs in dementia care can change quickly, so carers benefit from one named NHS or social-care contact for follow-up questions.');\n\nconst fact2 = facts[1] || (isEventTopic\n  ? 'If details are not yet published, avoid assumptions and track official updates weekly before sharing advice with carers and families.'\n  : 'A written care plan for medication, meals, hydration, and sleep improves continuity between home routines and clinical appointments.');\n\nconst action1 = actions[0] || (isEventTopic\n  ? 'Check the official event website this week, save confirmed dementia sessions, and note one question to raise with your GP or memory clinic.'\n  : 'Ask your GP or memory service for a named contact and a written care plan you can refer to at home.');\n\nconst action2 = actions[1] || (isEventTopic\n  ? 'Share only verified updates from official sources and convert one practical takeaway into an action for this week at home.'\n  : 'Write one support request for this week and share it with family, carers support, or your care coordinator.');\n\nconst title = sanitizeHeading(parsed.title || requestedTopic, isEventTopic ? 'What Carers Should Track' : 'Dementia Care Update');\n\nconst fallbackSlides = [\n  {\n    role: 'cover',\n    heading: isEventTopic ? 'What Carers Should Track' : 'New Dementia Care Update',\n    subline: isEventTopic\n      ? 'When event details are unclear, use official sources and focus on practical dementia-care actions carers can apply this week in England.'\n      : 'If you support someone with dementia, here is one key UK fact, what it means in practice, and one practical step you can take today.',\n    imagePrompt: 'Single UK carer planning at a kitchen table with notebook and calendar, natural daylight, editorial documentary realism, 4:5 portrait'\n  },\n  {\n    role: 'information',\n    heading: 'One Key UK Fact',\n    subline: fact1,\n    imagePrompt: 'Single UK healthcare consultation scene with leaflet and notes, documentary realism, 4:5 portrait'\n  },\n  {\n    role: 'information',\n    heading: 'What This Means Daily',\n    subline: fact2,\n    imagePrompt: 'Single UK care-planning scene with clinician and family member reviewing next steps, realistic props, 4:5 portrait'\n  },\n  {\n    role: 'information',\n    heading: 'Do This Today',\n    subline: action1,\n    imagePrompt: 'Single UK home planning scene with phone, diary, and NHS leaflet, documentary realism, 4:5 portrait'\n  },\n  {\n    role: 'conclusion',\n    heading: 'Your Next Step',\n    subline: action2 + ' You are not alone. Follow Dignitate for support.',\n    imagePrompt: 'Single hopeful UK carers support group or family support moment, warm realistic light, 4:5 portrait'\n  }\n];\n\nconst rawSlides = Array.isArray(parsed.slides) ? parsed.slides : [];\nconst roles = ['cover', 'information', 'information', 'information', 'conclusion'];\nconst slides = [];\n\nfor (let i = 0; i < 5; i++) {\n  const fallback = fallbackSlides[i];\n  const raw = rawSlides[i] || {};\n  const extracted = extractHeadingSubline(raw);\n\n  let heading = sanitizeHeading(extracted.heading, fallback.heading);\n  let subline = sanitizeSubline(extracted.subline, fallback.subline);\n\n  if (i === 0) {\n    heading = fallback.heading;\n    subline = sanitizeSubline(fallback.subline, fallback.subline);\n  }\n\n  if (i === 1) {\n    heading = 'One Key UK Fact';\n    subline = sanitizeSubline(extracted.subline || fact1, fact1);\n  }\n\n  if (i === 2) {\n    heading = 'What This Means Daily';\n    subline = sanitizeSubline(extracted.subline || fact2, fact2);\n  }\n\n  if (i === 3) {\n    heading = 'Do This Today';\n    subline = sanitizeSubline(extracted.subline || action1, action1);\n  }\n\n  if (i === 4) {\n    heading = sanitizeHeading(extracted.heading || 'Your Next Step', 'Your Next Step');\n    subline = sanitizeSubline((extracted.subline || action2) + ' You are not alone. Follow Dignitate for support.', fallback.subline);\n    if (!/\\bfollow\\s+dignitate\\b/i.test(subline)) {\n      subline = clean(subline + ' Follow Dignitate for support.');\n    }\n  }\n\n  const imagePrompt = sanitizeImagePrompt(\n    raw.imagePrompt || raw.image_prompt || raw.visualPrompt || raw.prompt || raw.image || '',\n    fallback.imagePrompt\n  );\n\n  slides.push({\n    role: roles[i],\n    heading,\n    subline,\n    text: heading + ': ' + subline,\n    imagePrompt,\n  });\n}\n\nlet hashtags = Array.isArray(parsed.hashtags) ? parsed.hashtags : [];\nif (!hashtags.length) hashtags = ['#DementiaCare', '#CarerSupport', '#UKHealth', '#Dignitate'];\nhashtags = [...new Set(hashtags.map((h) => String(h || '').trim()).filter(Boolean))].slice(0, 12);\n\nlet caption = clean(parsed.caption || '');\nif (!caption || isLeakText(caption)) {\n  caption = isEventTopic\n    ? 'Use official updates, focus on one practical step this week, and share verified dementia-care guidance with your network. Follow Dignitate for support.'\n    : 'Practical UK dementia-care guidance for carers with one clear step you can take today. Follow Dignitate for support.';\n}\nif (!/\\bfollow\\s+dignitate\\b/i.test(caption)) {\n  caption = clean(caption + ' Follow Dignitate for support.');\n}\nif (caption.length > 420) caption = caption.slice(0, 417).trim() + '...';\n\nreturn [{\n  json: {\n    title,\n    slides,\n    hashtags,\n    caption,\n    chatId: base.chatId || commandData.chatId,\n    args: requestedTopic,\n    coherence: {\n      forcedStructure: true,\n      factCount: facts.length,\n      actionCount: actions.length,\n      leakGuard: true\n    },\n    researchBlocked,\n    researchBlockReason\n  }\n}];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000012",
      "name": "Parse Carousel Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse Video Response (OpenRouter -> strict-ish JSON)\n// Outputs: { title, allScenes, fullNarration, hashtags, caption, chatId, args, ... }\n\nconst response = $input.first()?.json ?? {};\n\nlet base = {};\ntry {\n  base = $(\"Parse Video Research\").first().json ?? {};\n} catch (e) {\n  base = {};\n}\n\nlet mode = String(base?.videoMode || base?.video_mode || \"\").toLowerCase().trim();\nif (!mode) {\n  try { mode = String($(\"Prepare Video Args\").first().json?.videoMode || \"\").toLowerCase().trim(); } catch (e) {}\n}\nif (!mode) mode = \"kling_multiclip\";\nconst TARGET_SCENES = mode === \"talking_head\" ? 1 : 2;\nconst DEFAULT_SCENE_DURATION_SEC = mode === \"talking_head\" ? 30 : 12; // talking head is a 30s single-image style\n\nfunction clean(s) {\n  return String(s ?? \"\")\n    .replace(/[\\r\\n\\t]+/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\nfunction isLeakText(text) {\n  const t = clean(text).toLowerCase();\n  if (!t) return true;\n  return [\n    \"to complete this research task\",\n    \"search specifically for\",\n    \"search results provided do not contain\",\n    \"do not contain any information\",\n    \"return strict json\",\n    \"topic lock\",\n    \"output json only\",\n    \"schema\",\n    \"recommendation:\"\n  ].some((p) => t.includes(p));\n}\n\nfunction sanitizeNarration(text, fallback) {\n  let t = clean(text);\n  if (!t || isLeakText(t)) t = clean(fallback || \"\");\n  if (!t) t = \"Take one small step today and follow Dignitate for support.\";\n  t = t.replace(/\\s*(?:https?:\\/\\/\\S+|\\[[^\\]]+\\])\\s*/g, \" \").trim();\n  return t;\n}\n\n\nfunction countWords(text) {\n  return clean(text).split(/\\s+/).filter(Boolean).length;\n}\n\nfunction trimToWords(text, maxWords) {\n  const words = clean(text).split(/\\s+/).filter(Boolean);\n  if (words.length <= maxWords) return words.join(\" \");\n  return words.slice(0, maxWords).join(\" \");\n}\n\nfunction estimateDurationForNarration(narration, fallbackSec) {\n  const words = countWords(narration);\n  if (!words) return fallbackSec;\n\n  if (mode === \"talking_head\") {\n    // Talking-head mode is intentionally 30s for natural pacing and fuller context.\n    return 30;\n  }\n\n  const est = Math.ceil(words / 2.8) + 1;\n  return Math.max(10, Math.min(14, est));\n}\n\nfunction getContent(r) {\n  const c = r?.choices?.[0]?.message?.content;\n  if (Array.isArray(c)) {\n    return c\n      .map((p) => clean(p?.text ?? p?.content ?? \"\"))\n      .filter(Boolean)\n      .join(\"\\n\");\n  }\n  return clean(c ?? \"\");\n}\n\nfunction parseJsonLoose(text) {\n  const t0 = String(text ?? \"\").trim();\n  if (!t0) return null;\n\n  const t1 = t0\n    .replace(/^```json\\s*/i, \"\")\n    .replace(/^```\\s*/i, \"\")\n    .replace(/```$/i, \"\")\n    .trim();\n\n  try {\n    return JSON.parse(t1);\n  } catch (e) {\n    const start = t1.indexOf('{');\n    const end = t1.lastIndexOf('}');\n    if (start >= 0 && end > start) {\n      try {\n        return JSON.parse(t1.slice(start, end + 1));\n      } catch (e2) {\n        return null;\n      }\n    }\n    return null;\n  }\n}\n\nfunction normalizeScene(s, idx, fallbackNarration) {\n  const rawNarration = clean(s?.narration);\n  const narrationBase = sanitizeNarration(rawNarration, fallbackNarration);\n  const narration = mode === \"talking_head\"\n    ? trimToWords(narrationBase, 85)\n    : trimToWords(narrationBase, 30);\n  const visualPrompt = clean(s?.visualPrompt ?? s?.visual_prompt);\n\n  const durationRaw = Number(s?.duration);\n  const requestedDuration = Number.isFinite(durationRaw) && durationRaw > 0\n    ? durationRaw\n    : DEFAULT_SCENE_DURATION_SEC;\n  const duration = estimateDurationForNarration(narration, requestedDuration);\n\n  // Default type only if missing. We'll re-pin hook/cta positions below.\n  const type = clean(s?.type) || (idx === 0 ? \"hook\" : \"cta\");\n\n  return { type, narration, visualPrompt, duration, index: idx };\n}\n\nconst content = getContent(response);\nconst parsed = parseJsonLoose(content) ?? {};\n\nconst title =\n  clean(parsed?.title) ||\n  clean(base?.args) ||\n  clean(base?.requestedTopic) ||\n  \"Dignitate Video\";\n\nconst facts = (Array.isArray(base?.researchFacts) ? base.researchFacts : [])\n  .map((f) => clean(typeof f === \"string\" ? f : (f?.fact || \"\")))\n  .filter(Boolean);\nconst actions = (Array.isArray(base?.researchActions) ? base.researchActions : [])\n  .map((a) => clean(typeof a === \"string\" ? a : (a?.action || a?.step || \"\")))\n  .filter(Boolean);\n\nconst fallbackHook = facts[0]\n  ? `Quick question: did you know this UK update matters for your dementia-care routine? ${facts[0]}`\n  : \"Quick question: are you carrying most dementia care on your own this week?\";\n\nconst fallbackAction = actions[0]\n  ? actions[0]\n  : \"Ask your GP or memory service this week for one named contact and a written care plan update.\";\n\nconst fallbackCta = \"Follow Dignitate for support.\";\n\nconst fallbackTalkingHead = trimToWords(\n  `${fallbackHook} ${actions[0] || \"One practical step: write one clear support request and share it today.\"} ${actions[1] || fallbackAction} ${fallbackCta}`,\n  82\n);\n\nlet scenes = Array.isArray(parsed?.scenes) ? parsed.scenes : [];\nscenes = scenes.map((s, i) => {\n  const fallback = mode === \"talking_head\"\n    ? fallbackTalkingHead\n    : (i === 0 ? trimToWords(`${fallbackHook} ${fallbackAction}`, 30) : trimToWords(`${actions[1] || \"Take one small step today and share it with your care team.\"} ${fallbackCta}`, 30));\n  return normalizeScene(s, i, fallback);\n}).filter((s) => s.narration);\n\n// Keep it short and consistent.\nif (scenes.length > TARGET_SCENES) scenes = scenes.slice(0, TARGET_SCENES);\n\n// If too few, pad to target scene count.\nconst pad = (TARGET_SCENES === 1)\n  ? [\n      {\n        type: \"hook\",\n        narration: fallbackTalkingHead,\n        visualPrompt: \"Podcast studio talking head with microphone, warm lighting, UK documentary realism\",\n        duration: DEFAULT_SCENE_DURATION_SEC,\n      },\n    ]\n  : [\n      {\n        type: \"hook\",\n        narration: trimToWords(`${fallbackHook} ${fallbackAction}`, 30),\n        visualPrompt: \"UK clinic corridor, documentary realism, overcast daylight\",\n        duration: DEFAULT_SCENE_DURATION_SEC,\n      },\n      {\n        type: \"cta\",\n        narration: trimToWords(`${actions[1] || \"Pick one small step today: write it down and ask for one specific help.\"} ${fallbackCta}`, 30),\n        visualPrompt: \"UK kitchen table, care plan notes and calendar, documentary realism\",\n        duration: DEFAULT_SCENE_DURATION_SEC,\n      },\n    ];\n\nwhile (scenes.length < TARGET_SCENES) {\n  const idx = scenes.length;\n  scenes.push(normalizeScene(pad[idx], idx, pad[idx]?.narration || \"\"));\n}\n\n// Enforce structure positions regardless of model output.\nscenes = scenes.map((s, idx) => {\n  const forcedType = (TARGET_SCENES === 1) ? \"hook\" : (idx === 0 ? \"hook\" : \"cta\");\n  return {\n    ...s,\n    type: forcedType,\n    index: idx,\n  };\n});\n\nconst fullNarration = clean(scenes.map((s) => s.narration).join(' '));\n\nlet hashtags = Array.isArray(parsed?.hashtags) ? parsed.hashtags : [];\nhashtags = hashtags.map((h) => clean(h)).filter(Boolean);\nif (!hashtags.length) hashtags = [\"#DementiaCare\", \"#CarerSupport\", \"#UKHealth\", \"#Dignitate\"];\n\nlet caption = clean(parsed?.caption);\nif (!caption) caption = `${title}. Follow Dignitate for support.`;\nif (isLeakText(caption)) caption = `${title}. ${actions[0] || \"Take one practical step this week.\"} Follow Dignitate for support.`;\n\nreturn [\n  {\n    json: {\n      ...base,\n      title,\n      allScenes: scenes,\n      scenes,\n      fullNarration,\n      hashtags,\n      caption,\n      videoMode: mode || clean(base?.videoMode || base?.video_mode || \"kling_multiclip\"),\n      chatId: String(base?.chatId ?? base?.chatKey ?? base?.memoryKey ?? ''),\n      args: clean(base?.args ?? base?.requestedTopic ?? title),\n      _debug: {\n        resolvedVideoMode: mode || clean(base?.videoMode || base?.video_mode || \"\"),\n        openrouterModel: clean(response?.model),\n        contentPreview: content.slice(0, 500),\n      },\n    },\n  },\n];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000013",
      "name": "Parse Video Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Telegram sendMessage nodes replace the current item with Telegram's API response.\n// Restore the real video payload (title/scenes/narration/creator refs) so downstream nodes use correct data.\nconst base = $('Parse Video Response').first().json || {};\nlet args = {};\ntry { args = $('Prepare Video Args').first().json || {}; } catch (e) {}\n\nreturn [{\n  json: {\n    ...args,\n    ...base,\n    // Keep creatorImageUrls pool if present\n    creatorImageUrls: base.creatorImageUrls || args.creatorImageUrls || [],\n  }\n}];\n"
      },
      "id": "restore-video-payload-v1",
      "name": "Restore Video Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        920,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json || {};\nconst rawContent = response.choices?.[0]?.message?.content ?? response.output_text ?? response.text ?? '[]';\nconst content = Array.isArray(rawContent)\n  ? rawContent.map((c) => (typeof c === 'string' ? c : (c?.text || JSON.stringify(c)))).join('\\n')\n  : String(rawContent || '[]');\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction asArray(v) {\n  if (Array.isArray(v)) return v;\n  if (v && typeof v === 'object') {\n    for (const key of ['topics', 'trends', 'items', 'results', 'data']) {\n      if (Array.isArray(v[key])) return v[key];\n    }\n    if (v.title || v.topic) return [v];\n  }\n  return [];\n}\n\nfunction parseJsonLoose(text) {\n  const t = String(text || '').trim();\n  if (!t) return [];\n\n  const stripped = t\n    .replace(/^\\x60\\x60\\x60json\\s*/i, '')\n    .replace(/^\\x60\\x60\\x60\\s*/i, '')\n    .replace(/\\x60\\x60\\x60$/i, '')\n    .trim();\n\n  try {\n    const parsed = JSON.parse(stripped);\n    const arr = asArray(parsed);\n    if (arr.length) return arr;\n  } catch (e) {}\n\n  const aStart = stripped.indexOf('[');\n  const aEnd = stripped.lastIndexOf(']');\n  if (aStart >= 0 && aEnd > aStart) {\n    try {\n      const parsed = JSON.parse(stripped.slice(aStart, aEnd + 1));\n      const arr = asArray(parsed);\n      if (arr.length) return arr;\n    } catch (e) {}\n  }\n\n  const oStart = stripped.indexOf('{');\n  const oEnd = stripped.lastIndexOf('}');\n  if (oStart >= 0 && oEnd > oStart) {\n    try {\n      const parsed = JSON.parse(stripped.slice(oStart, oEnd + 1));\n      const arr = asArray(parsed);\n      if (arr.length) return arr;\n    } catch (e) {}\n  }\n\n  return [];\n}\n\nfunction normTitle(s) {\n  return clean(s).toLowerCase().replace(/[^a-z0-9\\s]/g, '').replace(/\\s+/g, ' ').trim();\n}\n\nconst allowedCategories = new Set(['policy', 'research', 'caregiving', 'community', 'technology', 'finance', 'legal', 'clinical']);\nconst parsed = parseJsonLoose(content);\n\nlet topics = parsed\n  .map((t) => {\n    const title = clean(t?.title || t?.topic || '');\n    const summary = clean(t?.summary || t?.description || '');\n    let engagement_score = Number(t?.engagement_score ?? t?.engagementScore ?? 7);\n    if (!Number.isFinite(engagement_score)) engagement_score = 7;\n    engagement_score = Math.max(1, Math.min(10, Math.round(engagement_score)));\n\n    const rawCat = clean(t?.category || '').toLowerCase();\n    const category = allowedCategories.has(rawCat) ? rawCat : 'caregiving';\n    const region = clean(t?.region || 'UK');\n    const source_url = clean(t?.source_url || t?.sourceUrl || t?.url || '');\n    const source_name = clean(t?.source_name || t?.sourceName || t?.source || '');\n    const published_at = clean(t?.published_at || t?.publishedAt || t?.date || '');\n\n    return { title, summary, engagement_score, category, region, source_url, source_name, published_at };\n  })\n  .filter((t) => t.title && t.summary);\n\nconst fallbackPool = [\n  {\n    title: 'NHS Dementia Diagnosis Pathway Performance Update',\n    summary: 'Latest NHS pathway performance and waiting-time changes are affecting early diagnosis and support access for carers in the UK.',\n    engagement_score: 8,\n    category: 'clinical',\n    region: 'UK'\n  },\n  {\n    title: 'Local Authority Social Care Funding Pressures and Carer Impact',\n    summary: 'Council-level social care budget pressures are changing respite availability, home support capacity, and carer strain.',\n    engagement_score: 8,\n    category: 'finance',\n    region: 'UK'\n  },\n  {\n    title: 'Dementia Research Trial Recruitment and What It Means for Families',\n    summary: 'UK trial recruitment trends are shifting opportunities for participation and information access for families and carers.',\n    engagement_score: 7,\n    category: 'research',\n    region: 'UK'\n  },\n  {\n    title: 'Carer Legal Rights: Attendance Allowance and Support Entitlements',\n    summary: 'Recent guidance changes on entitlements and assessments are influencing financial and practical support for carers.',\n    engagement_score: 8,\n    category: 'legal',\n    region: 'UK'\n  },\n  {\n    title: 'Community Dementia Hubs Expanding Practical Support Services',\n    summary: 'Community hubs are introducing local support models that improve navigation, peer support, and caregiver wellbeing.',\n    engagement_score: 7,\n    category: 'community',\n    region: 'UK'\n  },\n  {\n    title: 'Digital Tools for Dementia Care Coordination in Primary Care',\n    summary: 'Digital coordination tools are being adopted to improve care continuity between GPs, memory clinics, and carers.',\n    engagement_score: 7,\n    category: 'technology',\n    region: 'UK'\n  },\n  {\n    title: 'Workforce Shortages in Dementia Services and Care Quality Risks',\n    summary: 'Staffing pressures across dementia services are affecting continuity, communication, and experience of care.',\n    engagement_score: 8,\n    category: 'policy',\n    region: 'UK'\n  },\n  {\n    title: 'Culturally Tailored Carer Support Programmes Expanding Across the UK',\n    summary: 'New culturally responsive support services are improving access and outcomes for carers from diverse communities.',\n    engagement_score: 8,\n    category: 'caregiving',\n    region: 'UK'\n  }\n];\n\nconst seenIncoming = new Set();\ntopics = topics.filter((t) => {\n  const k = normTitle(t.title);\n  if (!k || seenIncoming.has(k)) return false;\n  seenIncoming.add(k);\n  return true;\n});\n\nif (topics.length < 8) {\n  for (const f of fallbackPool) {\n    const key = normTitle(f.title);\n    if (seenIncoming.has(key)) continue;\n    topics.push(f);\n    seenIncoming.add(key);\n    if (topics.length >= 8) break;\n  }\n}\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.sentTrends) staticData.sentTrends = [];\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.globalSuggestedTopic) staticData.globalSuggestedTopic = '';\nif (!staticData.userMemory) staticData.userMemory = {};\nif (!staticData.trendCursorByChat) staticData.trendCursorByChat = {};\nif (!staticData.trendHistoryByChat) staticData.trendHistoryByChat = {};\nif (!staticData.trendMetaByTitle) staticData.trendMetaByTitle = {};\n\nlet chatId = clean(response.chatId || response.chat_id || '');\nif (!chatId) {\n  try { chatId = clean($('Quick Parse Slash').first().json.chatId); } catch (e) {}\n}\nif (!chatId) {\n  try { chatId = clean($('Load Chat History').first().json.chatId); } catch (e) {}\n}\nif (!chatId) chatId = clean(staticData.defaultChatId || '');\nif (!chatId) return [];\n\nconst chatKey = String(chatId);\nconst now = Date.now();\nconst dedupeWindowMs = 72 * 60 * 60 * 1000;\nstaticData.sentTrends = staticData.sentTrends.filter((t) => now - Number(t.timestamp || 0) < dedupeWindowMs);\n\nconst historyWindowMs = 24 * 60 * 60 * 1000;\nconst history = Array.isArray(staticData.trendHistoryByChat[chatKey]) ? staticData.trendHistoryByChat[chatKey] : [];\nconst recentHistory = history.filter((h) => now - Number(h.timestamp || 0) < historyWindowMs);\nstaticData.trendHistoryByChat[chatKey] = recentHistory;\n\nconst recentlySentGlobal = new Set(staticData.sentTrends.map((t) => normTitle(t.title || '')));\nconst recentlySentChat = new Set(recentHistory.map((t) => normTitle(t.title || '')));\n\nlet fresh = topics.filter((t) => !recentlySentGlobal.has(normTitle(t.title)) && !recentlySentChat.has(normTitle(t.title)));\nif (!fresh.length) fresh = topics.filter((t) => !recentlySentChat.has(normTitle(t.title)));\nconst pool = fresh.length ? fresh : topics;\n\nconst sorted = [...pool].sort((a, b) => b.engagement_score - a.engagement_score);\nconst selected = [];\nconst usedCat = new Set();\n\nfor (const t of sorted) {\n  if (!usedCat.has(t.category)) {\n    selected.push(t);\n    usedCat.add(t.category);\n  }\n  if (selected.length >= 8) break;\n}\nfor (const t of sorted) {\n  if (selected.length >= 8) break;\n  if (!selected.includes(t)) selected.push(t);\n}\n\nlet ordered = selected.slice(0, 8);\nconst cursor = Number(staticData.trendCursorByChat[chatKey] || 0);\nif (ordered.length > 1) {\n  const shift = ((cursor % ordered.length) + ordered.length) % ordered.length;\n  ordered = ordered.slice(shift).concat(ordered.slice(0, shift));\n}\nstaticData.trendCursorByChat[chatKey] = cursor + 1;\n\nconst lastTopNorm = normTitle(staticData.lastTrendByChat[chatKey] || '');\nif (ordered.length > 1 && normTitle(ordered[0]?.title || '') === lastTopNorm) {\n  const swapIdx = ordered.findIndex((t, i) => i > 0 && normTitle(t.title) !== lastTopNorm);\n  if (swapIdx > 0) {\n    const tmp = ordered[0];\n    ordered[0] = ordered[swapIdx];\n    ordered[swapIdx] = tmp;\n  }\n}\n\nconst finalTopics = ordered.slice(0, 8);\nfor (const t of finalTopics) {\n  staticData.sentTrends.push({ title: t.title, category: t.category, timestamp: now });\n  const meta = {\n    title: t.title,\n    summary: t.summary || '',\n    category: t.category || '',\n    region: t.region || 'UK',\n    sourceUrl: t.source_url || '',\n    sourceName: t.source_name || '',\n    publishedAt: t.published_at || '',\n    updatedAt: now\n  };\n  const keyLower = String(t.title || '').toLowerCase();\n  const keyNorm = normTitle(t.title || '');\n  if (keyLower) staticData.trendMetaByTitle[keyLower] = meta;\n  if (keyNorm) staticData.trendMetaByTitle[keyNorm] = meta;\n}\n\nif (finalTopics[0]?.title) {\n  const selectedTitle = String(finalTopics[0].title).trim();\n  staticData.lastTrendByChat[chatKey] = selectedTitle;\n  staticData.latestSuggestedTopicByChat[chatKey] = selectedTitle;\n  staticData.pendingTrendTopicByChat[chatKey] = selectedTitle;\n  staticData.globalSuggestedTopic = selectedTitle;\n  staticData.userMemory[chatKey] = {\n    ...(staticData.userMemory[chatKey] || {}),\n    lastTopic: selectedTitle,\n    lastAction: 'trends',\n    updatedAt: now\n  };\n}\n\nstaticData.trendHistoryByChat[chatKey] = [\n  ...recentHistory,\n  ...finalTopics.map((t) => ({ title: t.title, timestamp: now }))\n].slice(-60);\n\nreturn finalTopics.map((t, idx) => ({\n  json: {\n    ...t,\n    chatId,\n    rank: idx + 1,\n    totalTopics: finalTopics.length\n  }\n}));\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000014",
      "name": "Parse Trends Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        640
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{`Creating Carousel (v3.9-direct-after-split)...\n\nTitle: ${$json.title || 'Untitled Carousel'}\nSlides: ${Array.isArray($json.slides) ? $json.slides.length : 0}\nFirst slide text: ${(() => {\n  const t = String($json.slides?.[0]?.text || 'n/a').trim();\n  if (t.length <= 140) return t;\n  const cut = t.slice(0, 140);\n  const i = cut.lastIndexOf(' ');\n  return (i > 60 ? cut.slice(0, i) : cut) + '...';\n})()}\n\nGenerating unique images per slide with fal.ai...`}}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000015",
      "name": "Carousel - Status Update",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000015",
      "position": [
        940,
        160
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{`Creating Video...\\n\\nTitle: ${$json.title || 'Untitled Video'}\\nScenes: ${$json.sceneCount || 0}\\nCreator face: ${$json.creatorImageUrl ? 'set' : 'not set'}\\nCreator voice: ${$json.creatorVoiceId ? 'set' : 'default'}\\n\\nWorkflow build: 2026-02-15-gh-fal-v1\\n\\nStep 1/4: Creating voiceover with ElevenLabs...`}}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000016",
      "name": "Video - Status Update",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000016",
      "position": [
        940,
        400
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.trendMessage || \"Trending topic unavailable.\" }}",
        "replyMarkup": "inlineKeyboard",
        "inlineKeyboard": {
          "rows": [
            {
              "row": {
                "buttons": [
                  {
                    "text": "Carousel",
                    "additionalFields": {
                      "callback_data": "/carousel"
                    }
                  },
                  {
                    "text": "Video",
                    "additionalFields": {
                      "callback_data": "/video"
                    }
                  }
                ]
              }
            }
          ]
        },
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000017",
      "name": "Trends - Send Topic",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000017",
      "position": [
        940,
        640
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 2000
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json || {};\nlet data = input;\n\n// Fallback in case upstream node accidentally passes Telegram API response.\nif (!Array.isArray(data.slides) || data.slides.length === 0) {\n  try { data = $('Parse Carousel Response').first().json || data; } catch (e) {}\n}\n\nif (data.researchBlocked) {\n  throw new Error(String(data.researchBlockReason || 'Research quality is too low for reliable carousel generation. Please refine the topic.'));\n}\n\nconst slides = Array.isArray(data.slides) ? data.slides : [];\nif (!slides.length) {\n  throw new Error('No slides found in carousel payload. Ensure Split Slides receives Parse Carousel Response output.');\n}\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n\\t]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nreturn slides.map((slide, idx) => {\n  const heading = clean(slide.heading || '');\n  const body = clean(slide.subline || slide.body || '');\n  const text = clean(slide.text || slide.caption || '');\n\n  return {\n    json: {\n      slideIndex: idx,\n      totalSlides: slides.length,\n      slideRole: String(slide.role || (idx === 0 ? 'cover' : (idx === slides.length - 1 ? 'conclusion' : 'information'))),\n      imagePrompt: slide.imagePrompt || slide.image_prompt || slide.visualPrompt || slide.prompt || '',\n      slideText: text,\n      slideHeading: heading,\n      slideBody: body,\n      chatId: data.chatId,\n      title: data.title,\n      hashtags: data.hashtags,\n      caption: data.caption,\n      args: data.args\n    }\n  };\n});\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000018",
      "name": "Split Slides",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1180,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://queue.fal.run/fal-ai/nano-banana-pro",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Key ' + $('TEST_KEYS').first().json.falKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  prompt: $json.falPrompt || 'Clean UK dementia-care editorial slide, 4:5, no logos',\n  num_images: 1,\n  seed: $json.falSeed,\n  aspect_ratio: \"4:5\",\n  output_format: \"png\",\n  resolution: \"1K\"\n}) }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000019",
      "name": "fal.ai - Submit Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1420,
        160
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": false
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000020",
      "name": "Collect Images",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1900,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nlet carouselData = {};\ntry { carouselData = $('Parse Carousel Response').first().json || {}; } catch (e) {}\n\nconst allImageUrls = [];\nconst expectedCandidates = [];\nconst failedRequests = [];\n\nfunction collectUrls(node, out) {\n  if (!node) return;\n  if (Array.isArray(node)) {\n    for (const x of node) collectUrls(x, out);\n    return;\n  }\n  if (typeof node === 'string') {\n    const u = node.trim();\n    if (/^https?:\\/\\//i.test(u)) out.push(u);\n    return;\n  }\n  if (typeof node !== 'object') return;\n\n  const candidates = [node.url, node.image_url, node.imageUrl];\n  for (const v of candidates) {\n    const u = String(v || '').trim();\n    if (/^https?:\\/\\//i.test(u)) out.push(u);\n  }\n\n  if (node.images) collectUrls(node.images, out);\n  if (node.image) collectUrls(node.image, out);\n  if (node.output) collectUrls(node.output, out);\n  if (node.outputs) collectUrls(node.outputs, out);\n  if (node.data) collectUrls(node.data, out);\n  if (node.result) collectUrls(node.result, out);\n  if (node.response) collectUrls(node.response, out);\n}\n\nfor (const item of items) {\n  const j = item?.json || {};\n\n  if (j.falError) {\n    failedRequests.push({ request_id: j.request_id || j.requestId || '', error: String(j.falError) });\n  }\n\n  collectUrls(j, allImageUrls);\n\n  if (Number.isFinite(Number(j.totalSlides)) && Number(j.totalSlides) > 0) {\n    expectedCandidates.push(Number(j.totalSlides));\n  }\n\n  const nestedData = Array.isArray(j.data) ? j.data : [];\n  for (const row of nestedData) {\n    const rowJson = row?.json || row || {};\n    collectUrls(rowJson, allImageUrls);\n\n    if (Number.isFinite(Number(rowJson.totalSlides)) && Number(rowJson.totalSlides) > 0) {\n      expectedCandidates.push(Number(rowJson.totalSlides));\n    }\n  }\n}\n\nconst uniqueUrls = [...new Set(allImageUrls)];\nlet expectedSlides = Array.isArray(carouselData.slides) ? carouselData.slides.length : 0;\nif (!expectedSlides && expectedCandidates.length) {\n  expectedSlides = Math.max(...expectedCandidates);\n}\nif (!expectedSlides) expectedSlides = 5;\n\nif (!uniqueUrls.length) {\n  const reason = failedRequests.length\n    ? (' fal.ai details: ' + failedRequests.map((f) => (f.request_id ? '[' + f.request_id + '] ' : '') + f.error).join(' | ').slice(0, 700))\n    : '';\n  throw new Error('No image URLs were returned from fal.ai.' + reason);\n}\n\nconst partialGeneration = uniqueUrls.length < expectedSlides;\nconst missingSlides = partialGeneration ? Math.max(0, expectedSlides - uniqueUrls.length) : 0;\n\nreturn [{ json: {\n  ...carouselData,\n  allImageUrls: uniqueUrls,\n  imageUrl: uniqueUrls[0] || '',\n  firstImageUrl: uniqueUrls[0] || '',\n  imageCount: uniqueUrls.length,\n  expectedSlides,\n  partialGeneration,\n  missingSlides,\n  failedRequests\n} }];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000021",
      "name": "Package Carousel Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2140,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingContent) staticData.pendingContent = {};\n\nconst data = $input.first().json;\nconst chatId = String(data.chatId);\n\nstaticData.pendingContent[chatId] = {\n  type: 'carousel',\n  title: data.title,\n  slides: data.slides,\n  hashtags: data.hashtags,\n  caption: data.caption,\n  allImageUrls: data.allImageUrls || [],\n  imageUrl: data.imageUrl,\n  firstImageUrl: data.firstImageUrl,\n  imageCount: data.imageCount,\n  chatId: data.chatId,\n  args: data.args,\n  timestamp: Date.now()\n};\n\nreturn [{ json: data }];\n\nif (!staticData.activeGenerationByChat) staticData.activeGenerationByChat = {};\ndelete staticData.activeGenerationByChat[chatId];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000022",
      "name": "Store Pending Carousel",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2140,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{(() => {\n  const title = String($json.title || 'Untitled Carousel');\n  const slides = Array.isArray($json.slides) ? $json.slides : [];\n  const lines = slides\n    .map((s, i) => {\n      const heading = String((s && s.heading) || '').trim();\n      const subline = String((s && s.subline) || '').trim();\n      const text = (heading ? heading + ' - ' : '') + subline;\n      return ((i + 1) + ') ' + text).trim();\n    })\n    .filter(Boolean);\n\n  const caption = String($json.caption || '').trim();\n  const hashtags = Array.isArray($json.hashtags) ? $json.hashtags.join(' ') : '';\n  const imageCount = Number.isFinite(Number($json.imageCount)) ? Number($json.imageCount) : 0;\n  const missingSlides = Number.isFinite(Number($json.missingSlides)) ? Number($json.missingSlides) : 0;\n  const warning = $json.partialGeneration\n    ? ('\\nWarning: ' + missingSlides + ' slide image(s) are missing due to model queue delays.')\n    : '';\n\n  let msg = 'CAROUSEL READY FOR REVIEW\\n\\n'\n    + 'Title: ' + title + '\\n'\n    + 'Slides: ' + slides.length + '\\n'\n    + 'Images generated: ' + imageCount + warning + '\\n\\n'\n    + 'SLIDES:\\n' + (lines.join('\\n') || '-') + '\\n\\n'\n    + 'CAPTION:\\n' + (caption || '-')\n    + (hashtags ? ('\\n\\nHASHTAGS:\\n' + hashtags) : '')\n    + '\\n\\nTap a button below: Approve to post, or Regenerate for a new version.';\n\n  if (msg.length > 3900) msg = msg.slice(0, 3890) + '...';\n  return msg;\n})()}}",
        "additionalFields": {
          "disableWebPagePreview": true
        },
        "replyMarkup": "inlineKeyboard",
        "inlineKeyboard": {
          "rows": [
            {
              "row": {
                "buttons": [
                  {
                    "text": "Approve",
                    "additionalFields": {
                      "callback_data": "/approve"
                    }
                  },
                  {
                    "text": "Regenerate",
                    "additionalFields": {
                      "callback_data": "/regenerate"
                    }
                  }
                ]
              }
            }
          ]
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000023",
      "name": "Send Carousel for Approval",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000023",
      "position": [
        2380,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "let data = $input.first().json || {};\n\n// When upstream is Telegram send-message output, recover the real carousel payload.\nif (!Array.isArray(data.allImageUrls) || data.allImageUrls.length === 0) {\n  try { data = $('Store Pending Carousel').first().json || data; } catch (e) {}\n}\nif (!Array.isArray(data.allImageUrls) || data.allImageUrls.length === 0) {\n  try { data = $('Package Carousel Data').first().json || data; } catch (e) {}\n}\n\nconst urls = Array.isArray(data.allImageUrls) ? data.allImageUrls.filter(Boolean) : [];\nif (!urls.length) {\n  throw new Error('No carousel image URLs found to send on Telegram.');\n}\n\nreturn urls.map((url, idx) => ({\n  json: {\n    chatId: data.chatId,\n    imageUrl: String(url),\n    slideIndex: idx + 1,\n    totalSlides: urls.length,\n    title: data.title || ''\n  }\n}));"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000024",
      "name": "Split Remaining Images",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2620,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "sendPhoto",
        "chatId": "={{ $json.chatId }}",
        "binaryData": true,
        "binaryPropertyName": "data",
        "additionalFields": {
          "caption": "={{(() => {\n  const h = String($json.slideHeading || \"\").trim();\n  const b = String($json.slideBody || \"\").trim();\n  const base = `Slide ${($json.slideIndex ?? 0) + 1}/${$json.totalSlides || 1}` + ($json.title ? ` - ${$json.title}` : \"\");\n  let t = (h || b) ? (base + `\\n${h}${h && b ? \": \" : \"\"}${b}`) : base;\n  if (t.length > 900) t = t.slice(0, 890) + \"...\";\n  return t;\n})()}}"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000025",
      "name": "Send Remaining Images",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000025",
      "position": [
        2860,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ 'https://api.elevenlabs.io/v1/text-to-speech/' + ($json.creatorVoiceId || 'GoLTMzQJAHarswiHqv3L') }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "xi-api-key",
              "value": "={{ $('TEST_KEYS').first().json.elevenLabsKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  text: ($json.fullNarration || \"Supporting cultural carers through the dementia journey.\"),\n  model_id: \"eleven_multilingual_v2\",\n  voice_settings: {\n    stability: 0.5,\n    similarity_boost: 0.75,\n    style: 0.4\n  }\n}) }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "audioFile"
            }
          }
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000026",
      "name": "ElevenLabs - Create Voiceover",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1180,
        400
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000
    },
    {
      "parameters": {
        "jsCode": "const videoData = $('Resolve Founder Portrait URL').first().json || $('Parse Video Response').first().json || {};\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n\\t]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction uniq(parts) {\n  const out = [];\n  const seen = new Set();\n  for (const p of parts) {\n    const t = clean(p);\n    if (!t) continue;\n    const k = t.toLowerCase();\n    if (seen.has(k)) continue;\n    seen.add(k);\n    out.push(t);\n  }\n  return out.join(', ');\n}\n\nfunction stripMetaLabels(text) {\n  let t = clean(text);\n  if (!t) return t;\n  t = t\n    .replace(/^(why this matters now|what changed|evidence update|what this means for carers|next step|key takeaway)\\s*[:\\-]\\s*/i, '')\n    .replace(/\\b(key takeaway)\\s*[:\\-].*$/i, '')\n    .trim();\n  return t;\n}\n\nfunction intentFromNarration(text) {\n  const t = stripMetaLabels(text);\n  return t || 'practical UK dementia-care guidance for carers';\n}\n\nfunction visualCore(raw) {\n  return clean(String(raw || '').split(/topic context:/i)[0]);\n}\n\nfunction stripIdentityDrift(text) {\n  return clean(text)\n    .replace(/\\bresembling[^,.;]*/ig, '')\n    .replace(/\\b(?:a|an)?\\s*(?:young|middle-aged|elderly)\\s+(?:man|woman|person)\\b/ig, '')\n    .replace(/\\b(?:man|woman)\\s+with\\s+[^,.;]*/ig, '')\n    .replace(/\\b(?:male|female)\\b/ig, '')\n    .replace(/\\b(?:blonde|red-haired|blue-eyed|green-eyed)\\b/ig, '')\n    .replace(/\\b(?:same man|same woman|different person)\\b/ig, '');\n}\n\nfunction hashSeed(str) {\n  const s = String(str || '');\n  let h = 0;\n  for (let i = 0; i < s.length; i++) {\n    h = ((h << 5) - h + s.charCodeAt(i)) | 0;\n  }\n  return Math.abs(h);\n}\n\nconst scenes = Array.isArray(videoData.allScenes) ? videoData.allScenes : [];\n\nconst mode = String(videoData.videoMode || videoData.video_mode || \"\").toLowerCase().trim();\nconst isTalkingHead = mode === \"talking_head\";\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.videoContinuityByChat) staticData.videoContinuityByChat = {};\nconst chatKey = String(videoData.chatId || staticData.defaultChatId || '');\n\nconst continuityDefaults = {\n  identityAnchor: 'same exact founder identity from reference image, match face geometry, skin tone, hairstyle, no identity drift',\n  wardrobeAnchor: isTalkingHead ? 'wardrobe: podcast host style, clean modern clothing, subtle variation allowed (different shirt/jacket) but still consistent identity' : 'wardrobe consistent across scenes, professional UK healthcare editorial clothing',\n  cameraAnchor: 'vertical 9:16, chest-up framing, eyes sharp, natural skin texture, documentary realism',\n  negative: 'no borders, no black bars, no letterboxing, no text, no captions, no logos, no watermark, no UI, no collage, no grid, no split-screen'\n};\n\nconst continuity = {\n  ...continuityDefaults,\n  ...(chatKey ? (staticData.videoContinuityByChat[chatKey] || {}) : {})\n};\nif (chatKey) staticData.videoContinuityByChat[chatKey] = continuity;\n\nconst settingByType = isTalkingHead\n  ? {\n      hook: 'podcast/recording studio setup, visible microphone, warm studio lighting, clean background',\n      cta: 'podcast/recording studio setup, visible microphone, warm studio lighting, clean background',\n      scene: 'podcast/recording studio setup, visible microphone, warm studio lighting, clean background'\n    }\n  : {\n      hook: 'quiet NHS clinic consult room or community health centre, soft daylight, calm tone',\n      scene: 'UK home-care planning moment at a kitchen table, practical props (calendar, leaflet, pill organiser), soft daylight',\n      cta: 'warm UK living room or community centre, hopeful closing moment, calm and reassuring'\n    };\n\nconst motionByType = isTalkingHead\n  ? {\n      hook: 'locked-off tripod, subtle natural head movement, minimal camera motion',\n      scene: 'locked-off tripod, subtle natural head movement, minimal camera motion',\n      cta: 'locked-off tripod, subtle natural head movement, minimal camera motion'\n    }\n  : {\n      hook: 'gentle dolly-in, natural pacing',\n      scene: 'subtle handheld documentary motion, small natural gestures',\n      cta: 'slow cinematic push-in, calm finish'\n    };\n\nconst shotByIndex = isTalkingHead\n  ? [\n      'vertical medium shot, presenter at desk with microphone, camera at eye level',\n      'vertical medium shot, presenter with microphone, slight angle change'\n    ]\n  : [\n      'vertical medium shot, camera at eye level',\n      'vertical close-up, subtle expression detail'\n    ];\n\nreturn scenes.map((scene, idx) => {\n  const sceneType = String(scene?.type || (idx === 0 ? 'hook' : (idx === scenes.length - 1 ? 'cta' : 'scene'))).toLowerCase();\n  const shot = shotByIndex[idx % shotByIndex.length];\n  const motion = motionByType[sceneType] || motionByType.scene;\n\n  const intent = intentFromNarration(scene?.narration || '');\n  const visualHint = stripIdentityDrift(visualCore(scene?.visualPrompt || ''));\n  const fallbackSetting = settingByType[sceneType] || settingByType.scene;\n\n  const framingLock = 'composition: subject centred, face in upper-middle (upper third), hands visible if possible, leave bottom 30% uncluttered for subtitles';\n\n  const videoPrompt = uniq([\n    'Photorealistic UK documentary scene: ' + intent,\n    visualHint || fallbackSetting,\n    continuity.identityAnchor,\n    continuity.wardrobeAnchor,\n    continuity.cameraAnchor,\n    framingLock,\n    motion,\n    shot,\n    continuity.negative\n  ]);\n\n  const sceneImagePrompt = uniq([\n    'Create a NEW photorealistic still frame (start image) for a vertical 9:16 short.',\n    'Same exact founder identity as reference images (strict).',\n    ...(isTalkingHead ? [] : ['Change the environment/background completely (do NOT keep the original portrait/studio background).']),\n    'Scene: ' + (visualHint || fallbackSetting) + '. Must match the narration meaning: ' + intent,\n    continuity.identityAnchor,\n    continuity.wardrobeAnchor,\n    continuity.cameraAnchor,\n    framingLock,\n    'lighting: natural window light, neutral-warm grade, realistic skin texture',\n    'no other prominent people, no distorted hands, no extra fingers',\n    continuity.negative\n  ]);\n\n  const sceneSeed = hashSeed(String(videoData.title || '') + '|' + String(videoData.chatId || '') + '|' + String(idx));\n\n  return {\n    json: {\n      ...scene,\n      sceneIndex: idx,\n      totalScenes: scenes.length,\n      chatId: videoData.chatId,\n      title: videoData.title,\n      hashtags: videoData.hashtags,\n      caption: videoData.caption,\n      fullNarration: videoData.fullNarration,\n      creatorImageUrl: videoData.creatorImageUrl || '',\n      creatorImageUrls: Array.isArray(videoData.creatorImageUrls) ? videoData.creatorImageUrls : [],\n      creatorVoiceId: videoData.creatorVoiceId || 'GoLTMzQJAHarswiHqv3L',\n      continuityProfile: continuity,\n      videoPrompt,\n      sceneImagePrompt,\n      sceneSeed,\n    }\n  };\n});\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000027",
      "name": "Prepare Video Scenes",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1420,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($json.sceneImageUrl || $json.creatorImageUrl) ? 'https://queue.fal.run/fal-ai/kling-video/v3/standard/image-to-video' : 'https://queue.fal.run/fal-ai/kling-video/v3/standard/text-to-video' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Key ' + $('TEST_KEYS').first().json.falKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify(\n  ($json.sceneImageUrl || $json.creatorImageUrl)\n    ? {\n        start_image_url: ($json.sceneImageUrl || $json.creatorImageUrl),\n        prompt: ($json.videoPrompt || $json.visualPrompt || 'photorealistic UK dementia-care documentary scene, vertical 9:16, no borders'),\n        duration: String($json.duration || 15),\n        aspect_ratio: '9:16',\n        generate_audio: false\n      }\n    : {\n        prompt: ($json.videoPrompt || $json.visualPrompt || 'photorealistic UK dementia-care documentary scene, vertical 9:16, no borders'),\n        duration: String($json.duration || 15),\n        aspect_ratio: '9:16',\n        generate_audio: false\n      }\n) }}",
        "options": {
          "timeout": 900000
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000028",
      "name": "Kling v3 - Generate Clip",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1660,
        400
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst apiKey = String($('TEST_KEYS').first().json.falKey || '').trim();\nconst headers = { Authorization: 'Key ' + apiKey };\n\nconst pollIntervalMs = 1800;\nconst maxChecks = 400; // ~12 minutes\nconst maxWaitMs = 900000; // 15 min hard cap\nconst resultRetryCount = 40;\nconst transientCodes = new Set([404, 409, 422, 425, 429]);\n\nconst httpRequest =\n  (typeof $httpRequest === 'function' && $httpRequest) ||\n  (this && this.helpers && typeof this.helpers.httpRequest === 'function'\n    ? this.helpers.httpRequest.bind(this)\n    : null);\n\nif (!httpRequest) {\n  throw new Error('n8n HTTP helper is unavailable in this Code node runtime.');\n}\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction getStatusCode(err) {\n  const candidates = [\n    err?.statusCode,\n    err?.status,\n    err?.httpCode,\n    err?.response?.statusCode,\n    err?.response?.status\n  ];\n  for (const c of candidates) {\n    const n = Number(c);\n    if (Number.isFinite(n)) return n;\n  }\n\n  const msg = String(err?.message || '');\n  const m = msg.match(/status\\s*code\\s*(\\d{3})/i) || msg.match(/\\b(\\d{3})\\b/);\n  if (m?.[1]) {\n    const n = Number(m[1]);\n    if (Number.isFinite(n)) return n;\n  }\n  return null;\n}\n\nfunction safeJson(v, maxLen = 600) {\n  try {\n    const s = JSON.stringify(v);\n    if (!s) return '';\n    return s.length > maxLen ? s.slice(0, maxLen) + '...' : s;\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction errText(err) {\n  const base = String(err?.message || err || 'unknown error');\n  const status = getStatusCode(err);\n  const body = safeJson(err?.response?.body || err?.body || err?.data || null);\n  return base + (status ? (' [status ' + status + ']') : '') + (body ? (' body=' + body) : '');\n}\n\nfunction readStatus(json) {\n  return String(\n    (json &&\n      (json.status ||\n        json.request_status ||\n        json.state ||\n        json.phase ||\n        (json.data && json.data.status))) ||\n      ''\n  ).toUpperCase();\n}\n\nfunction readQueuePos(json) {\n  const v = json?.queue_position ?? json?.data?.queue_position ?? null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction looksLikeVideoUrl(u) {\n  const s = String(u || '').trim();\n  if (!/^https?:\\/\\//i.test(s)) return false;\n  const lower = s.toLowerCase();\n  const bare = lower.split('?')[0].split('#')[0];\n  if (bare.endsWith('.mp4') || bare.endsWith('.mov') || bare.endsWith('.webm') || bare.endsWith('.m3u8')) return true;\n  if (lower.includes('fal.media/files/')) return true;\n  return false;\n}\n\nfunction pickVideoUrl(payload) {\n  const urls = [];\n  const seen = new Set();\n\n  function push(v) {\n    const u = String(v || '').trim();\n    if (!u || seen.has(u) || !looksLikeVideoUrl(u)) return;\n    seen.add(u);\n    urls.push(u);\n  }\n\n  function walk(node, depth = 0) {\n    if (node == null || depth > 7) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) walk(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      push(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    push(node.video?.url);\n    push(node.data?.video?.url);\n    push(node.output?.video?.url);\n    push(node.result?.video?.url);\n    push(node.response?.video?.url);\n    push(node.url);\n    push(node.video_url);\n    push(node.videoUrl);\n\n    walk(node.video, depth + 1);\n    walk(node.videos, depth + 1);\n    walk(node.data, depth + 1);\n    walk(node.output, depth + 1);\n    walk(node.result, depth + 1);\n    walk(node.response, depth + 1);\n\n    for (const v of Object.values(node)) {\n      if (v && typeof v === 'object') walk(v, depth + 1);\n    }\n  }\n\n  walk(payload);\n  return urls[0] || '';\n}\n\nasync function getJson(url) {\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function waitForOne(item) {\n  const inputJson = item.json || {};\n\n  // If already has a final video URL, just pass through.\n  const direct = pickVideoUrl(inputJson);\n  if (direct) {\n    return { json: { ...inputJson, videoUrl: direct, falStatus: inputJson.falStatus || 'COMPLETED_SYNC' } };\n  }\n\n  const requestId = inputJson.request_id || inputJson.requestId;\n  const statusUrl = clean(inputJson.status_url || inputJson.statusUrl);\n  const responseUrl = clean(inputJson.response_url || inputJson.responseUrl);\n\n  if (!requestId && !statusUrl && !responseUrl) {\n    return {\n      json: {\n        ...inputJson,\n        falStatus: 'ERROR',\n        falError: 'fal.ai submit did not return request_id/status_url/response_url.',\n      }\n    };\n  }\n\n  const startedAt = Date.now();\n  let attempts = 0;\n  let statusValue = '';\n  let lastQueuePosition = null;\n\n  while (attempts < maxChecks && (Date.now() - startedAt) < maxWaitMs) {\n    attempts++;\n\n    try {\n      const statusJson = await getJson(statusUrl || (requestId ? `https://queue.fal.run/fal-ai/kling-video/requests/${encodeURIComponent(requestId)}/status` : ''));\n      statusValue = readStatus(statusJson);\n      lastQueuePosition = readQueuePos(statusJson);\n    } catch (err) {\n      const code = getStatusCode(err);\n      if (!transientCodes.has(code)) {\n        return {\n          json: {\n            ...inputJson,\n            falStatus: 'ERROR',\n            falError: 'fal.ai status request failed: ' + errText(err),\n          }\n        };\n      }\n      statusValue = statusValue || 'IN_QUEUE';\n    }\n\n    if (statusValue === 'COMPLETED') {\n      // fal sometimes reports COMPLETED before the mp4 URL is fetchable.\n      // Try fetching the result; if the URL is missing, keep polling.\n      try {\n        const resultJson = await getJson(responseUrl || (requestId ? `https://queue.fal.run/fal-ai/kling-video/requests/${encodeURIComponent(requestId)}` : ''));\n        const videoUrl = pickVideoUrl(resultJson) || pickVideoUrl(inputJson);\n        if (videoUrl) {\n          return {\n            json: {\n              ...inputJson,\n              ...(resultJson && typeof resultJson === 'object' ? resultJson : {}),\n              videoUrl,\n              falStatus: 'COMPLETED',\n              falPollAttempts: attempts,\n            }\n          };\n        }\n      } catch (err) {\n        const code = getStatusCode(err);\n        if (!transientCodes.has(code)) {\n          return {\n            json: {\n              ...inputJson,\n              falStatus: 'ERROR',\n              falError: 'fal.ai result request failed: ' + errText(err),\n            }\n          };\n        }\n      }\n      // No URL yet; keep polling until maxWait.\n    }\n    if (['FAILED', 'ERROR', 'CANCELLED'].includes(statusValue)) {\n      return {\n        json: {\n          ...inputJson,\n          falStatus: statusValue,\n          falError: 'fal.ai request failed with status ' + statusValue,\n        }\n      };\n    }\n\n    const elapsed = Date.now() - startedAt;\n    const remaining = maxWaitMs - elapsed;\n    if (remaining <= 0) break;\n    await sleep(Math.min(pollIntervalMs, remaining));\n  }\n\n  // Fetch result\n  let resultJson = null;\n  for (let i = 0; i < resultRetryCount; i++) {\n    try {\n      resultJson = await getJson(responseUrl || (requestId ? `https://queue.fal.run/fal-ai/kling-video/requests/${encodeURIComponent(requestId)}` : ''));\n      break;\n    } catch (err) {\n      const code = getStatusCode(err);\n      if (!transientCodes.has(code)) {\n        return {\n          json: {\n            ...inputJson,\n            falStatus: 'ERROR',\n            falError: 'fal.ai result request failed: ' + errText(err),\n          }\n        };\n      }\n      await sleep(Math.min(1200 + i * 400, 3500));\n    }\n  }\n\n  const videoUrl = pickVideoUrl(resultJson) || pickVideoUrl(inputJson);\n  if (!videoUrl) {\n    const seconds = Math.max(1, Math.round((Date.now() - startedAt) / 1000));\n    return {\n      json: {\n        ...inputJson,\n        ...((resultJson && typeof resultJson === 'object') ? resultJson : {}),\n        falStatus: statusValue || 'UNKNOWN',\n        falPollAttempts: attempts,\n        falError:\n          'kling video not ready or no mp4 URL yet after ' + attempts + ' checks (~' + seconds + 's), status=' + (statusValue || 'IN_QUEUE') +\n          ', queue_position=' + (lastQueuePosition == null ? 'n/a' : lastQueuePosition)\n      }\n    };\n  }\n\n  return {\n    json: {\n      ...inputJson,\n      ...(resultJson && typeof resultJson === 'object' ? resultJson : {}),\n      videoUrl,\n      falStatus: statusValue || 'COMPLETED',\n      falPollAttempts: attempts,\n    }\n  };\n}\n\n\nasync function runWithLimit(arr, limit, fn) {\n  const results = new Array(arr.length);\n  let cursor = 0;\n  let lastErr = null;\n\n  async function worker() {\n    while (true) {\n      const i = cursor++;\n      if (i >= arr.length) return;\n      try {\n        results[i] = await fn(arr[i]);\n      } catch (e) {\n        lastErr = e;\n        results[i] = { json: { ...(arr[i]?.json || {}), falStatus: 'ERROR', falError: String(e.message || e) } };\n      }\n    }\n  }\n\n  const workers = [];\n  const w = Math.max(1, Math.min(limit, arr.length));\n  for (let i = 0; i < w; i++) workers.push(worker());\n  await Promise.all(workers);\n\n  return { results, lastErr };\n}\n\n// Kling O3 clips can take ~6-7 minutes each. Sequential waiting can exceed\n// n8n Cloud timeouts. Run waits concurrently.\nconst { results, lastErr } = await runWithLimit(items, 3, waitForOne);\n\nconst anyVideo = results.some((o) => looksLikeVideoUrl(o?.json?.videoUrl) || pickVideoUrl(o?.json));\nif (!anyVideo && lastErr) {\n  throw lastErr;\n}\n\nreturn results;\n"
      },
      "id": "await-kling-video-result-v1",
      "name": "fal.ai - Await Clip Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1820,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000029",
      "name": "Collect All Clips",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1900,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Package a lightweight video job for GitHub Actions.\n// All heavy generation (scene images + Kling clips) is done in GitHub Actions to avoid n8n Cloud timeouts.\n\nconst items = $input.all();\nconst parseVideoData = $('Parse Video Response').first().json || {};\nconst first = items[0]?.json || {};\n\nconst dataArr = Array.isArray(first.data) ? first.data : [];\n\nfunction clean(s) {\n  return String(s ?? '').replace(/\\s+/g, ' ').trim();\n}\n\nfunction pick(...vals) {\n  for (const v of vals) {\n    const t = clean(v);\n    if (t) return t;\n  }\n  return '';\n}\n\nfunction asNumber(v, fallback) {\n  const n = Number(v);\n  return Number.isFinite(n) && n > 0 ? n : fallback;\n}\n\nfunction isHttpUrl(v) {\n  return /^https?:\\/\\//i.test(String(v || '').trim());\n}\n\nfunction capUrls(list, max = 3) {\n  const out = [];\n  const seen = new Set();\n  for (const raw of (Array.isArray(list) ? list : [])) {\n    const u = String(raw || '').trim();\n    if (!u || !isHttpUrl(u)) continue;\n    const k = u.toLowerCase();\n    if (seen.has(k)) continue;\n    seen.add(k);\n    out.push(u);\n    if (out.length >= max) break;\n  }\n  return out;\n}\n\nconst mode = String(parseVideoData.videoMode || parseVideoData.video_mode || first.videoMode || \"\").toLowerCase().trim();\nconst MAX_SCENES = mode === \"talking_head\" ? 1 : 2;\n\n// Scenes coming from Prepare Video Scenes contain videoPrompt + sceneImagePrompt.\nconst sourceScenes = dataArr.length\n  ? dataArr\n  : (Array.isArray(parseVideoData.allScenes) ? parseVideoData.allScenes : []);\n\nconst trimmed = sourceScenes.slice(0, MAX_SCENES);\nconst total = trimmed.length;\n\nconst scenes = trimmed.map((s, idx) => {\n  const duration = asNumber(s?.duration, mode === \"talking_head\" ? 30 : 12);\n  const type = pick(s?.type, idx === 0 ? 'hook' : (idx === (total - 1) ? 'cta' : 'scene'));\n\n  return {\n    narration: pick(s?.narration, s?.text),\n    visualPrompt: pick(s?.visualPrompt, s?.imagePrompt, s?.prompt),\n    type,\n    duration,\n    index: Number.isFinite(Number(s?.index)) ? Number(s.index) : idx,\n\n    // Added by Prepare Video Scenes\n    videoPrompt: pick(s?.videoPrompt, s?.visualPrompt),\n    sceneImagePrompt: pick(s?.sceneImagePrompt, s?.visualPrompt),\n\n    // Identity anchors (cap to 3 to control cost)\n    creatorImageUrl: pick(s?.creatorImageUrl, parseVideoData.creatorImageUrl),\n    creatorImageUrls: capUrls(\n      Array.isArray(s?.creatorImageUrls)\n        ? s.creatorImageUrls\n        : (Array.isArray(parseVideoData.creatorImageUrls) ? parseVideoData.creatorImageUrls : []),\n      3\n    ),\n  };\n});\n\nconst title = pick(parseVideoData.title, first.title, 'Untitled Video');\nconst chatId = pick(parseVideoData.chatId, first.chatId);\nconst args = pick(parseVideoData.args, first.args);\nconst hashtags = Array.isArray(parseVideoData.hashtags)\n  ? parseVideoData.hashtags\n  : (Array.isArray(first.hashtags) ? first.hashtags : []);\nconst caption = pick(parseVideoData.caption, first.caption);\n\nconst fullNarration = pick(\n  parseVideoData.fullNarration,\n  first.fullNarration,\n  scenes.map((s) => clean(s.narration)).filter(Boolean).join(' ')\n);\n\nconst creatorVoiceId = pick(parseVideoData.creatorVoiceId, first.creatorVoiceId, 'GoLTMzQJAHarswiHqv3L');\n\nconst creatorImageUrl = pick(\n  scenes[0]?.creatorImageUrl,\n  parseVideoData.creatorImageUrl,\n  first.creatorImageUrl\n);\n\nconst creatorImageUrls = capUrls(\n  (Array.isArray(scenes[0]?.creatorImageUrls) && scenes[0].creatorImageUrls.length)\n    ? scenes[0].creatorImageUrls\n    : (Array.isArray(parseVideoData.creatorImageUrls) ? parseVideoData.creatorImageUrls : []),\n  3\n);\n\nconst out = {\n  type: 'video',\n  title,\n  hashtags,\n  caption,\n  chatId,\n  args,\n  videoMode: mode || \"kling_multiclip\",\n\n  // Clip generation is handled in GitHub Actions; these are optional.\n  clipUrls: [],\n  clipRequests: [],\n  clipCount: scenes.length,\n\n  scenes,\n  fullNarration,\n  narrationText: fullNarration,\n  creatorVoiceId,\n  creatorImageUrl,\n  creatorImageUrls,\n\n  status: 'queued'\n};\n\n// Clear active-generation lock for this chat (best-effort)\ntry {\n  const chatKey = String(chatId || '');\n  const staticData = $getWorkflowStaticData('global');\n  if (staticData?.activeGenerationByChat && chatKey) delete staticData.activeGenerationByChat[chatKey];\n} catch (e) {}\n\nreturn [{ json: out }];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000030",
      "name": "Package Video Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2140,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Prepare payload for GitHub rendering.\n// Renderer can synthesize audio from narrationText + voiceId if audioUrl is empty.\nconst data = $input.first().json || {};\n\nlet hasVoiceoverBinary = false;\ntry {\n  const audioBinary = $('ElevenLabs - Create Voiceover').first().binary;\n  hasVoiceoverBinary = Boolean(audioBinary?.audioFile?.data);\n} catch (e) {\n  hasVoiceoverBinary = false;\n}\n\nreturn [{\n  json: {\n    ...data,\n    audioUrl: String(data.audioUrl || '').trim(),\n    narrationText: String(data.narrationText || data.fullNarration || '').trim(),\n    creatorVoiceId: String(data.creatorVoiceId || 'GoLTMzQJAHarswiHqv3L').trim(),\n    hasVoiceoverBinary\n  }\n}];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000031",
      "name": "Prepare Render Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2380,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.github.com/repos/dignitatesocial/dignitatevideo/dispatches",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.githubPat }}"
            },
            {
              "name": "Accept",
              "value": "application/vnd.github.v3+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  event_type: 'render-video',\n  client_payload: {\n    job: {\n      clipUrls: $json.clipUrls || [],\n      clipRequests: $json.clipRequests || [],\n      creatorImageUrl: $json.creatorImageUrl || '',\n      creatorImageUrls: $json.creatorImageUrls || [],\n      audioUrl: $json.audioUrl || '',\n      narrationText: $json.narrationText || $json.fullNarration || '',\n      voiceId: $json.creatorVoiceId || 'GoLTMzQJAHarswiHqv3L',\n      videoMode: $json.videoMode || 'kling_multiclip',\n      targetDurationSec: (String($json.videoMode || '').toLowerCase() === 'talking_head') ? 30 : null,\n      scenes: $json.scenes,\n      title: $json.title,\n      chatId: String($json.chatId),\n      n8nWebhookUrl: 'https://dignitate.app.n8n.cloud/webhook/dignitate-remotion-callback',\n      renderConfig: {\n        aspectRatio: '9:16',\n        subtitles: {\n          enabled: true,\n          mode: 'word-highlight',\n          placement: 'bottom-center',\n          maxWordsOnScreen: 8\n        },\n        talkingHeadSingleImage: (String($json.videoMode || '').toLowerCase() === 'talking_head'),\n        animation: {\n          preset: 'smooth-cinematic',\n          transition: 'crossfade',\n          sceneMotion: 'subtle-zoom'\n        },\n        branding: {\n          style: 'dignitate-teal-logo',\n          enabled: true\n        }\n      },\n      postMeta: {\n        hashtags: $json.hashtags,\n        caption: $json.caption\n      }\n    }\n  }\n}) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000032",
      "name": "Trigger GitHub Actions",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 5000,
      "position": [
        2620,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "chatId": "={{ $('Package Video Data').first().json.chatId }}",
        "text": "={{`Assembling your video with Remotion...\\n\\nTitle: ${$('Package Video Data').first().json.title || 'Untitled Video'}\\nClips: ${$('Package Video Data').first().json.clipCount || 0}\\nVoice: ${($('Package Video Data').first().json.creatorVoiceId || '') ? 'configured' : 'default'}\\nPortrait source: ${$('Package Video Data').first().json.founderPortraitSource || 'n/a'}\\nSubtitles: Word-by-word highlight\\nBranding: Dignitate teal + logo\\n\\nThis takes about 10-20 minutes (clip generation + render). You will receive the finished MP4 automatically.`}}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000060",
      "name": "Video - Rendering Status",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000060",
      "position": [
        2860,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "const staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingContent) staticData.pendingContent = {};\n\nconst commandData = $('Load Chat History').first().json;\nconst chatId = String(commandData.chatId);\nconst pending = staticData.pendingContent[chatId];\n\nif (!pending) {\n  return [{ json: { chatId: commandData.chatId, error: true, message: 'No pending content found. Generate content first with /carousel or /video.' } }];\n}\n\nconst contentData = { ...pending };\ndelete staticData.pendingContent[chatId];\n\nreturn [{ json: { ...contentData, chatId: commandData.chatId, approved: true } }];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000033",
      "name": "Handle Approval",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        -200
      ]
    },
    {
      "parameters": {
        "jsCode": "const staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingContent) staticData.pendingContent = {};\n\nconst commandData = $('Load Chat History').first().json;\nconst chatId = String(commandData.chatId);\nconst pending = staticData.pendingContent[chatId];\n\nif (!pending) {\n  return [{ json: { chatId: commandData.chatId, error: true, message: 'No pending content found. Generate content first with /carousel or /video.' } }];\n}\n\nconst contentData = { ...pending };\ndelete staticData.pendingContent[chatId];\n\nreturn [{ json: { ...contentData, chatId: commandData.chatId, regenerate: true } }];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000034",
      "name": "Handle Regeneration",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        -400
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "carousel",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Carousel"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "video",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Video"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000035",
      "name": "Content Type Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        240,
        -200
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "carousel",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Carousel"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "video",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Video"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000036",
      "name": "Regen Type Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        240,
        -400
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "Carousel approved! Posting to social media now...",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000037",
      "name": "Approval Confirmed",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000037",
      "position": [
        460,
        -280
      ]
    },
    {
      "parameters": {
        "jsCode": "function clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction stripPrefixes(text) {\n  return clean(text)\n    .replace(/^why this matters now:\\s*/i, '')\n    .replace(/^what changed:\\s*/i, '')\n    .replace(/^evidence update:\\s*/i, '')\n    .replace(/^what this means for carers:\\s*/i, '')\n    .replace(/^what carers can do next:\\s*/i, '')\n    .trim();\n}\n\nfunction uniqHashtags(list) {\n  const out = [];\n  const seen = new Set();\n  for (const raw of (Array.isArray(list) ? list : [])) {\n    let h = clean(raw);\n    if (!h) continue;\n    if (!h.startsWith('#')) h = '#' + h;\n    const key = h.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push(h);\n  }\n  return out;\n}\n\nconst input = $input.first().json || {};\nlet data = { ...input };\n\n// After Telegram confirmation nodes, payload can be replaced by Telegram API response.\n// Recover canonical approved content from Handle Approval when needed.\nconst looksLikeTelegramOnly = !data.title && !data.caption && !Array.isArray(data.slides) && !data.imageUrl;\nif (looksLikeTelegramOnly) {\n  try {\n    const approved = $('Handle Approval').first().json || {};\n    data = { ...approved };\n  } catch (e) {}\n}\n\nconst title = clean(data.title || data.args || 'Dementia Care Update');\nconst slides = Array.isArray(data.slides) ? data.slides : [];\nconst allImageUrls = Array.isArray(data.allImageUrls) ? data.allImageUrls.filter(Boolean) : [];\nconst imageUrl = clean(data.imageUrl || allImageUrls[0] || '');\nconst chatId = data.chatId;\nconst type = clean(data.type || 'carousel').toLowerCase();\n\nlet hashtags = uniqHashtags(data.hashtags || []);\nif (!hashtags.length) {\n  hashtags = ['#DementiaCare', '#CarerSupport', '#UKHealth', '#Dignitate'];\n}\n\nlet baseCaption = clean(data.caption || '');\nif (!baseCaption) {\n  baseCaption = 'Evidence-led update for carers with practical next steps and clear takeaways.';\n}\n\nconst keyPoints = slides\n  .map((s) => stripPrefixes(s?.text || s?.caption || ''))\n  .filter(Boolean)\n  .slice(0, 5);\n\nconst pointLines = keyPoints.map((p) => '- ' + p);\n\nconst defaultIntro = 'A practical update from Dignitate for carers and families navigating dementia support.';\nconst intro = baseCaption || defaultIntro;\n\nconst instagramCaption = [\n  title,\n  intro,\n  pointLines.length ? 'Key points:\\n' + pointLines.join('\\n') : '',\n  'Save and share with carers who need clear, practical guidance.',\n  hashtags.join(' ')\n].filter(Boolean).join('\\n\\n').slice(0, 2100);\n\nconst linkedinText = [\n  title,\n  intro,\n  pointLines.length ? 'Highlights:\\n' + pointLines.join('\\n') : '',\n  'Dignitate shares evidence-led dementia content to support cultural carers and families across the UK.',\n  hashtags.slice(0, 8).join(' ')\n].filter(Boolean).join('\\n\\n').slice(0, 2900);\n\nconst xCore = [\n  title,\n  keyPoints[0] ? keyPoints[0] : intro,\n  'Practical next steps for carers in the full carousel.'\n].filter(Boolean).join(' ');\nconst xTags = hashtags.slice(0, 3).join(' ');\nconst xText = (xCore + (xTags ? (' ' + xTags) : '')).slice(0, 275);\n\nreturn [{\n  json: {\n    chatId,\n    type,\n    title,\n    caption: baseCaption,\n    hashtags,\n    allImageUrls,\n    imageUrl,\n    slides,\n    instagramCaption,\n    linkedinText,\n    xText\n  }\n}];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000038",
      "name": "Prepare Post Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        -280
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v1/actions/INSTAGRAM_CREATE_MEDIA_CONTAINER/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ connectedAccountId: 'ac_KNBQIWjdvioh', input: { image_url: $('Prepare Post Data').first().json.imageUrl, image_urls: $('Prepare Post Data').first().json.allImageUrls, allImageUrls: $('Prepare Post Data').first().json.allImageUrls, caption: $('Prepare Post Data').first().json.instagramCaption || '', is_carousel: true, media_type: 'CAROUSEL' } }) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000039",
      "name": "Composio - Instagram",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        940,
        -280
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v1/actions/LINKEDIN_CREATE_POST/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ connectedAccountId: 'ac_T2GUOXxT7_hq', input: { text: $('Prepare Post Data').first().json.linkedinText || '', media_url: $('Prepare Post Data').first().json.imageUrl } }) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000040",
      "name": "Composio - LinkedIn",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1180,
        -280
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v1/actions/TWITTER_CREATE_TWEET/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ connectedAccountId: 'ac_lrFu5_tsVghC', input: { text: $('Prepare Post Data').first().json.xText || '', media_url: $('Prepare Post Data').first().json.imageUrl } }) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000041",
      "name": "Composio - X/Twitter",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1420,
        -280
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const postData = $('Prepare Post Data').first().json;\nlet igStatus = 'Failed';\nlet liStatus = 'Failed';\nlet twStatus = 'Failed';\n\ntry {\n  const igResult = $('Composio - Instagram').first().json;\n  if (igResult && !igResult.error) igStatus = 'Posted';\n} catch(e) {}\n\ntry {\n  const liResult = $('Composio - LinkedIn').first().json;\n  if (liResult && !liResult.error) liStatus = 'Posted';\n} catch(e) {}\n\ntry {\n  const twResult = $('Composio - X/Twitter').first().json;\n  if (twResult && !twResult.error) twStatus = 'Posted';\n} catch(e) {}\n\nconst allSucceeded = igStatus === 'Posted' && liStatus === 'Posted' && twStatus === 'Posted';\nconst noneSucceeded = igStatus === 'Failed' && liStatus === 'Failed' && twStatus === 'Failed';\n\nlet summary;\nif (allSucceeded) {\n  summary = 'CAROUSEL POSTED SUCCESSFULLY!\\n\\nInstagram: ' + igStatus + '\\nLinkedIn: ' + liStatus + '\\nX/Twitter: ' + twStatus + '\\n\\nLive on all platforms!';\n} else if (noneSucceeded) {\n  summary = 'POSTING FAILED\\n\\nInstagram: ' + igStatus + '\\nLinkedIn: ' + liStatus + '\\nX/Twitter: ' + twStatus + '\\n\\nPlease check API credentials and try again.';\n} else {\n  summary = 'POSTING PARTIALLY COMPLETE\\n\\nInstagram: ' + igStatus + '\\nLinkedIn: ' + liStatus + '\\nX/Twitter: ' + twStatus + '\\n\\nSome platforms may need attention.';\n}\n\nreturn [{ json: { chatId: postData.chatId, message: summary } }];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000042",
      "name": "Check Post Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1660,
        -280
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000043",
      "name": "Post Results Message",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000043",
      "position": [
        1900,
        -280
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "Regenerating carousel content with a fresh script...",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000048",
      "name": "Regeneration Started",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000048",
      "position": [
        460,
        -480
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "Regenerating video content with a fresh script...",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000049",
      "name": "Video Regen Started",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000049",
      "position": [
        460,
        -340
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId || $('Load Chat History').first().json.chatId }}",
        "text": "={{(() => {\n  const j = $json || {};\n  const detail = j.error?.message || j.error?.description || j.error?.details || j.body?.detail || j.detail || j.message || (typeof j.error === 'string' ? j.error : '') || 'An unexpected error occurred. Please try again.';\n  const slideInfo = (j.slideIndex !== undefined && j.totalSlides !== undefined) ? `\\nSlide: ${Number(j.slideIndex) + 1}/${j.totalSlides}` : '';\n  return `Error: Something went wrong.\\n\\n${String(detail).slice(0, 700)}${slideInfo}\\n\\nTry running the command again or use /status to check bot health.`;\n})()}}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000050",
      "name": "Error Notification",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000050",
      "position": [
        940,
        1100
      ]
    },
    {
      "parameters": {
        "jsCode": "const staticData = $getWorkflowStaticData('global');\nif (!staticData.autoScheduleByChat) staticData.autoScheduleByChat = {};\nif (!staticData.pendingAutoActionByChat) staticData.pendingAutoActionByChat = {};\n\nconst nowMs = Date.now();\n\nfor (const key of Object.keys(staticData.autoScheduleByChat)) {\n  const cfg = staticData.autoScheduleByChat[key] || {};\n  staticData.autoScheduleByChat[key] = {\n    ...cfg,\n    enabled: false,\n    updatedAt: nowMs,\n  };\n}\n\nfor (const key of Object.keys(staticData.pendingAutoActionByChat)) {\n  staticData.pendingAutoActionByChat[key] = '';\n}\n\nreturn [];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000051",
      "name": "Scheduled Trends Prep",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -464,
        700
      ]
    },
    {
      "parameters": {
        "jsCode": "// Deterministic slash parser for button-first trend flow + generation lock\nconst data = $input.first().json || {};\nconst rawMessage = String(data.message || '').trim();\nconst replyToText = String(data.replyToText || '').trim();\nconst sourceMessageText = String(data.sourceMessageText || '').trim();\n\nlet actionType = 'none';\nlet args = '';\nlet command = '';\nlet directArgs = '';\nlet topicSource = 'none';\nlet customReply = '';\nlet videoMode = ''; // 'talking_head' | 'kling_multiclip'\nlet selectedTrendSummary = '';\nlet selectedTrendCategory = '';\nlet selectedTrendRegion = '';\nlet selectedTrendSourceUrl = '';\nlet selectedTrendSourceName = '';\nlet selectedTrendPublishedAt = '';\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction normalizeTopic(s) {\n  let t = clean(s);\n  for (let i = 0; i < 3; i++) {\n    const first = t.charAt(0);\n    const last = t.charAt(t.length - 1);\n    const pairs = { '\"': '\"', \"'\": \"'\", '(': ')', '[': ']', '{': '}' };\n    if (pairs[first] && pairs[first] === last) t = clean(t.slice(1, -1));\n  }\n  return t;\n}\n\nfunction normTitle(s) {\n  return normalizeTopic(s).toLowerCase().replace(/[^a-z0-9\\s]/g, '').replace(/\\s+/g, ' ').trim();\n}\n\n\nfunction escapeRegExp(s) {\n  return String(s || '').replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction extractTopicFromTrendMessage(text, cmd) {\n  const t = String(text || '').trim();\n  const cmdRe = new RegExp('^\\\\s*' + escapeRegExp(cmd) + '\\\\s+(.+)$', 'im');\n  const cmdMatch = t.match(cmdRe);\n  if (cmdMatch?.[1]) return normalizeTopic(cmdMatch[1]);\n\n  const trendingMatch = t.match(/Trending Topic(?:\\s+\\d+\\/\\d+)?\\s*:\\s*[\\r\\n]+([^\\n\\r]+)/i);\n  if (trendingMatch?.[1]) return normalizeTopic(trendingMatch[1]);\n\n  const lines = t.split(/\\r?\\n/).map((x) => x.trim()).filter(Boolean);\n  if (!lines.length) return '';\n  const idx = lines.findIndex((x) => /^Trending Topic/i.test(x));\n  if (idx >= 0 && lines[idx + 1]) return normalizeTopic(lines[idx + 1]);\n\n  return '';\n}\n\nfunction extractSummaryFromTrendMessage(text) {\n  const t = String(text || '').trim();\n  if (!t) return '';\n  const lines = t.split(/\\r?\\n/).map((x) => x.trim()).filter(Boolean);\n  const idx = lines.findIndex((x) => /^Trending Topic/i.test(x));\n  if (idx >= 0 && lines[idx + 2]) return normalizeTopic(lines[idx + 2]);\n  const m = t.match(/Trending Topic(?:\\s+\\d+\\/\\d+)?\\s*:\\s*[\\r\\n]+[^\\n\\r]+[\\r\\n]+[\\r\\n]*([^\\n\\r]+)/i);\n  return m?.[1] ? normalizeTopic(m[1]) : '';\n}\n\nfunction extractMetaFromTrendMessage(text) {\n  const t = String(text || '').trim();\n  if (!t) return { summary: '', category: '', region: '', sourceUrl: '', sourceName: '', publishedAt: '' };\n\n  const summary = extractSummaryFromTrendMessage(t);\n  const category = normalizeTopic((t.match(/^\\s*Category\\s*:\\s*(.+)$/im) || [])[1] || '');\n  const region = normalizeTopic((t.match(/^\\s*Region\\s*:\\s*(.+)$/im) || [])[1] || '');\n  const publishedAt = normalizeTopic((t.match(/^\\s*Published\\s*:\\s*(.+)$/im) || [])[1] || '');\n\n  const srcLine = normalizeTopic((t.match(/^\\s*Source\\s*:\\s*(.+)$/im) || [])[1] || '');\n  let sourceName = '';\n  let sourceUrl = '';\n  if (srcLine) {\n    const urlMatch = srcLine.match(/(https?:\\/\\/\\S+)/i);\n    sourceUrl = normalizeTopic(urlMatch?.[1] || '');\n    sourceName = normalizeTopic(srcLine.replace(/\\s*-\\s*https?:\\/\\/\\S+/i, ''));\n    if (sourceName.toLowerCase() === 'link') sourceName = '';\n  }\n\n  return { summary, category, region, sourceUrl, sourceName, publishedAt };\n}\n\nfunction extractTopicFromChooseVideoMessage(text) {\n  const t = String(text || '').trim();\n  if (!t) return '';\n\n  // Accept several variants:\n  // - Choose video style for:\n  // <topic>\n  // - Choose a video style for <topic>\n  // - Choose video style:\n  // <topic>\n  const m = t.match(/\\bChoose\\s+(?:a\\s+)?video\\s+style(?:\\s+for)?\\s*:?\\s*([\\s\\S]+)/i);\n  if (!m?.[1]) return '';\n\n  const rest = String(m[1] || '').trim();\n  if (!rest) return '';\n\n  const lines = rest.split(/\\r?\\n/).map((x) => x.trim()).filter(Boolean);\n  const ignore = (line) => /sent\\s+automatically\\s+with\\s+n8n/i.test(line);\n  const first = lines.find((x) => !ignore(x)) || '';\n  return normalizeTopic(first);\n}\n\n\nconst slash = rawMessage.match(/^\\/([a-z0-9_]+)(?:@[A-Za-z0-9_]+)?(?:\\s+([\\s\\S]+))?$/i);\nif (slash) {\n  command = '/' + String(slash[1] || '').toLowerCase();\n  directArgs = normalizeTopic(String(slash[2] || ''));\n} else if (rawMessage.startsWith('/')) {\n  command = rawMessage.split(/\\s+/)[0].toLowerCase();\n}\n\nif (command === '/video_talking') videoMode = 'talking_head';\nif (command === '/video_kling') videoMode = 'kling_multiclip';\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.pendingVideoTopicByChat) staticData.pendingVideoTopicByChat = {};\nif (!staticData.userMemory) staticData.userMemory = {};\nif (!staticData.pendingAutoActionByChat) staticData.pendingAutoActionByChat = {};\nif (!staticData.lastManualCommandAtByChat) staticData.lastManualCommandAtByChat = {};\nif (!staticData.globalSuggestedTopic) staticData.globalSuggestedTopic = '';\nif (!staticData.activeGenerationByChat) staticData.activeGenerationByChat = {};\nif (!staticData.recentTapByChat) staticData.recentTapByChat = {};\nif (!staticData.recentCallbackIdsByChat) staticData.recentCallbackIdsByChat = {};\nif (!staticData.trendMetaByTitle) staticData.trendMetaByTitle = {};\n\nfunction findTrendMeta(topic) {\n  const map = staticData.trendMetaByTitle || {};\n  const exact = map[String(topic || '').toLowerCase()];\n  if (exact) return exact;\n\n  const wanted = normTitle(topic);\n  if (!wanted) return null;\n\n  for (const [key, value] of Object.entries(map)) {\n    if (normTitle(key) === wanted) return value;\n    if (normTitle(value?.title || '') === wanted) return value;\n  }\n  return null;\n}\n\nfunction syncTrendMeta(topic) {\n  if (!topic) return;\n  const meta = findTrendMeta(topic);\n  if (!meta) return;\n  if (!selectedTrendSummary) selectedTrendSummary = normalizeTopic(meta.summary || '');\n  if (!selectedTrendCategory) selectedTrendCategory = normalizeTopic(meta.category || '');\n  if (!selectedTrendRegion) selectedTrendRegion = normalizeTopic(meta.region || '');\n  if (!selectedTrendSourceUrl) selectedTrendSourceUrl = normalizeTopic(meta.sourceUrl || '');\n  if (!selectedTrendSourceName) selectedTrendSourceName = normalizeTopic(meta.sourceName || '');\n  if (!selectedTrendPublishedAt) selectedTrendPublishedAt = normalizeTopic(meta.publishedAt || '');\n}\n\nconst now = Date.now();\nconst LOCK_MS = 10 * 60 * 1000;\nconst chatKey = String(data.chatId || '');\nconst defaultChatKey = String(staticData.defaultChatId || '');\nconst memoryKey = chatKey || defaultChatKey;\nconst lockKey = chatKey || memoryKey;\nconst pick = (...vals) => vals.map((v) => normalizeTopic(v)).find(Boolean) || '';\nconst isCallbackTap = Boolean(sourceMessageText || data.sourceMessageId || data.callbackQueryId);\nconst callbackQueryId = String(data.callbackQueryId || '').trim();\n\nfunction getPendingVideoTopic(key) {\n  const v = staticData.pendingVideoTopicByChat?.[key];\n  if (!v) return '';\n  if (typeof v === 'string') return normalizeTopic(v);\n  const topic = normalizeTopic(v.topic || '');\n  const ts = Number(v.ts || 0);\n  const TTL = 2 * 60 * 60 * 1000;\n  if (!topic) return '';\n  if (ts && (Date.now() - ts) > TTL) return '';\n  return topic;\n}\n\nif (lockKey && isCallbackTap) {\n  const CALLBACK_TTL_MS = 30 * 60 * 1000;\n  const cbSeen = staticData.recentCallbackIdsByChat[lockKey] || {};\n  for (const [k, ts] of Object.entries(cbSeen)) {\n    if ((Date.now() - Number(ts || 0)) > CALLBACK_TTL_MS) delete cbSeen[k];\n  }\n\n  if (callbackQueryId && cbSeen[callbackQueryId]) {\n    return [];\n  }\n\n  if (callbackQueryId) cbSeen[callbackQueryId] = Date.now();\n  staticData.recentCallbackIdsByChat[lockKey] = cbSeen;\n}\n\nconst active = staticData.activeGenerationByChat[lockKey];\nif (active && (now - Number(active.startedAt || 0) > LOCK_MS)) {\n  delete staticData.activeGenerationByChat[lockKey];\n}\n\nif (slash) {\n  const map = {\n    '/carousel': 'carousel',\n\n    // Video is now a 2-step flow: first choose the style, then generate.\n    '/video': 'choose_video',\n    '/video_talking': 'video',\n    '/video_kling': 'video',\n\n    '/trends': 'trends',\n    '/status': 'status',\n    '/approve': 'approve',\n    '/regenerate': 'regenerate',\n    '/help': 'help',\n    '/stop': 'stop',\n    '/cancel': 'stop',\n    '/auto': 'none',\n    '/commands': 'none',\n    '/cmds': 'none',\n    '/creator': 'none',\n    '/setface': 'none',\n    '/setvoiceid': 'none'\n  };\n  actionType = map[command] || 'none';\n  args = directArgs;\n  if (args && ['carousel', 'video', 'choose_video'].includes(actionType)) topicSource = 'direct';\n}\n\nif (actionType === 'stop') {\n  if (lockKey) delete staticData.activeGenerationByChat[lockKey];\n  if (chatKey) staticData.pendingAutoActionByChat[chatKey] = '';\n  actionType = 'none';\n  args = '';\n  topicSource = 'stop';\n  customReply = 'Stopped. I cleared the active generation lock for this chat. You can send /carousel <topic> or /video <topic> again.';\n}\n\nconst pendingVideoTopic = getPendingVideoTopic(memoryKey);\n\nsyncTrendMeta(args);\n\nconst fallbackTopic = pick(\n  pendingVideoTopic,\n  staticData.pendingTrendTopicByChat[memoryKey],\n  staticData.latestSuggestedTopicByChat[memoryKey],\n  staticData.lastTrendByChat[memoryKey],\n  staticData.userMemory[memoryKey]?.lastTopic,\n  staticData.globalSuggestedTopic\n);\n\nconst isVideoLike = actionType === 'video' || actionType === 'choose_video';\n\nif (!args && (actionType === 'carousel' || isVideoLike)) {\n  const replyTopic = extractTopicFromTrendMessage(replyToText, command || '/carousel');\n  if (replyTopic) {\n    args = replyTopic;\n    topicSource = 'reply';\n  }\n}\n\nif (!args && (actionType === 'carousel' || isVideoLike) && sourceMessageText) {\n  const trendTopic = extractTopicFromTrendMessage(sourceMessageText, command || '/carousel');\n  const chooseTopic = extractTopicFromChooseVideoMessage(sourceMessageText);\n  const sourceTopic = trendTopic || chooseTopic;\n  if (sourceTopic) {\n    args = sourceTopic;\n    topicSource = chooseTopic ? 'source_mode_message' : 'source_message';\n  }\n}\n\nif (sourceMessageText) {\n  const sourceMeta = extractMetaFromTrendMessage(sourceMessageText);\n  if (sourceMeta.summary) selectedTrendSummary = sourceMeta.summary;\n  if (sourceMeta.category && !selectedTrendCategory) selectedTrendCategory = sourceMeta.category;\n  if (sourceMeta.region && !selectedTrendRegion) selectedTrendRegion = sourceMeta.region;\n  if (sourceMeta.sourceUrl && !selectedTrendSourceUrl) selectedTrendSourceUrl = sourceMeta.sourceUrl;\n  if (sourceMeta.sourceName && !selectedTrendSourceName) selectedTrendSourceName = sourceMeta.sourceName;\n  if (sourceMeta.publishedAt && !selectedTrendPublishedAt) selectedTrendPublishedAt = sourceMeta.publishedAt;\n}\n\nif (!args && (actionType === 'carousel' || isVideoLike)) {\n  args = fallbackTopic;\n  if (args && topicSource === 'none') topicSource = 'memory';\n}\n\nsyncTrendMeta(args);\n\n// Debounce repeated inline button taps for the same topic/message.\nif (['carousel', 'video', 'choose_video'].includes(actionType) && lockKey && isCallbackTap) {\n  const tapSig = [\n    actionType,\n    String(data.sourceMessageId || data.messageId || ''),\n    normalizeTopic(args || '')\n  ].join('|');\n  const lastTap = staticData.recentTapByChat[lockKey];\n  const TAP_DEDUPE_MS = 10 * 60 * 1000;\n\n  if (lastTap && lastTap.sig === tapSig && (now - Number(lastTap.ts || 0) < TAP_DEDUPE_MS)) {\n    return [];\n  }\n\n  staticData.recentTapByChat[lockKey] = { sig: tapSig, ts: now };\n}\n\n// Prevent repeated taps/commands from spawning duplicate generations.\n// For choose_video we still respect the lock: don't let users start a new job while one runs.\nif (['carousel', 'video', 'choose_video'].includes(actionType) && lockKey) {\n  const lock = staticData.activeGenerationByChat[lockKey];\n  if (lock && (now - Number(lock.startedAt || 0) < LOCK_MS)) {\n    const sameAction = String(lock.type || '') === String(actionType || '');\n    const sameSource = String(lock.sourceMessageId || '') === String(data.sourceMessageId || '');\n\n    if (isCallbackTap && sameAction && sameSource) {\n      return [];\n    }\n\n    const mins = Math.max(1, Math.ceil((LOCK_MS - (now - Number(lock.startedAt || 0))) / 60000));\n    actionType = 'none';\n    args = '';\n    topicSource = 'active_lock';\n    customReply = 'A ' + String(lock.type || 'content') + ' generation is already running for this chat. Please wait about ' + mins + ' minute(s), or send /stop to unlock immediately.';\n  }\n}\n\nlet autoAction = '';\n// If user asked for generation but we couldn't resolve a topic, go fetch trends.\nif (!args && (actionType === 'carousel' || actionType === 'video' || actionType === 'choose_video')) {\n  autoAction = (actionType === 'carousel') ? 'carousel' : 'video';\n  actionType = 'trends';\n  if (chatKey) staticData.pendingAutoActionByChat[chatKey] = autoAction;\n}\n\n// Persist pending topic for mode selection step.\nif (args && actionType === 'choose_video') {\n  const writeKey = chatKey || memoryKey;\n  if (writeKey) {\n    staticData.pendingVideoTopicByChat[writeKey] = { topic: args, ts: now };\n    staticData.pendingTrendTopicByChat[writeKey] = args;\n    staticData.latestSuggestedTopicByChat[writeKey] = args;\n    staticData.lastTrendByChat[writeKey] = args;\n  }\n}\n\n// If user selected a mode, but didn't provide topic, use the pending one.\nif (!args && actionType === 'video' && videoMode) {\n  args = pick(\n    getPendingVideoTopic(chatKey),\n    getPendingVideoTopic(memoryKey),\n    fallbackTopic\n  );\n  if (args && topicSource === 'none') topicSource = 'pending_video_topic';\n}\n\n// Only acquire the expensive generation lock when we are actually generating.\nif (args && ['carousel', 'video'].includes(actionType)) {\n  const writeKey = chatKey || memoryKey;\n  if (writeKey) {\n    staticData.userMemory[writeKey] = {\n      ...(staticData.userMemory[writeKey] || {}),\n      lastAction: actionType,\n      lastTopic: args,\n      updatedAt: now\n    };\n    staticData.pendingTrendTopicByChat[writeKey] = args;\n    staticData.latestSuggestedTopicByChat[writeKey] = args;\n    staticData.lastTrendByChat[writeKey] = args;\n    staticData.pendingAutoActionByChat[writeKey] = '';\n    staticData.activeGenerationByChat[writeKey] = {\n      type: actionType,\n      topic: args,\n      startedAt: now,\n      messageId: String(data.messageId || ''),\n      sourceMessageId: String(data.sourceMessageId || '')\n    };\n  }\n}\n\nif (chatKey && ['carousel', 'video', 'choose_video', 'trends', 'approve', 'regenerate'].includes(actionType)) {\n  staticData.lastManualCommandAtByChat[chatKey] = now;\n}\n\nconst replies = {\n  carousel: args ? 'Great, I will create your carousel on: ' + args : 'I could not resolve a topic for carousel.',\n  video: args ? 'Great, I will create your video draft on: ' + args : 'I could not resolve a topic for video.',\n  choose_video: args ? ('Choose a video style for: ' + args) : 'Choose a video style.',\n  trends: autoAction\n    ? 'I could not find a saved topic, so I am fetching fresh trends now and will start your ' + autoAction + ' automatically.'\n    : 'I am pulling broader, diverse dementia-care trends now.',\n  status: 'Everything is online and ready. I can create content whenever you are ready.',\n  approve: 'Perfect, I am approving your latest draft for posting now.',\n  regenerate: 'Understood, I am regenerating your latest draft with fresh research now.',\n  help: 'Tell me a topic and format, for example: /carousel dementia support in UK carers',\n  none: 'Tell me what you want to create and the topic, and I will take it from there.'\n};\n\nreturn [{\n  json: {\n    chatId: data.chatId,\n    messageId: data.messageId,\n    replyToText,\n    replyToMessageId: data.replyToMessageId || null,\n    args,\n    action: { type: actionType, topic: actionType === 'trends' ? '' : args },\n    autoAction,\n    topicSource,\n    explicitTopicProvided: Boolean(directArgs),\n    forcedTopic: directArgs || '',\n    replyText: customReply || replies[actionType] || replies.none,\n    command,\n    videoMode,\n    selectedTrendSummary,\n    selectedTrendCategory,\n    selectedTrendRegion,\n    selectedTrendSourceUrl,\n    selectedTrendSourceName,\n    selectedTrendPublishedAt,\n    debugTopicSources: {\n      chatKey,\n      defaultChatKey,\n      memoryKey,\n      directArgs,\n      replyTopicCandidate: extractTopicFromTrendMessage(replyToText, command || '/carousel'),\n      sourceMessageTopicCandidate: extractTopicFromTrendMessage(sourceMessageText, command || '/carousel'),\n      sourceMessageChooseModeCandidate: extractTopicFromChooseVideoMessage(sourceMessageText),\n      pendingVideoTopic,\n      fallbackTopic,\n      autoAction,\n      topicSource,\n      activeGeneration: staticData.activeGenerationByChat[lockKey] || null,\n      command,\n      videoMode\n    }\n  }\n}];\n"
      },
      "id": "conv-0001-0000-0000-000000000001",
      "name": "Quick Parse Slash",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        200
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"z-ai/glm-5\",\n  messages: ($json.aiMessagesJson ? (typeof $json.aiMessagesJson === \"string\" ? JSON.parse($json.aiMessagesJson) : $json.aiMessagesJson) : [])\n}) }}",
        "options": {}
      },
      "id": "conv-0001-0000-0000-000000000002",
      "name": "AI Conversation",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        0,
        500
      ],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2000,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response into reply + structured action, with deterministic intent fallback\nconst response = $input.first().json || {};\nconst chatData = $('Load Chat History').first().json;\nconst rawContent = response.choices?.[0]?.message?.content;\nconst content = Array.isArray(rawContent)\n  ? rawContent.map(c => c?.text || '').join('\\n')\n  : (rawContent || '{}');\n\nfunction safeJsonParse(text) {\n  const cleaned = String(text || '').replace(/```json\\n?/gi, '').replace(/```/g, '').trim();\n  try {\n    return JSON.parse(cleaned);\n  } catch (_) {\n    const start = cleaned.indexOf('{');\n    const end = cleaned.lastIndexOf('}');\n    if (start >= 0 && end > start) {\n      try { return JSON.parse(cleaned.slice(start, end + 1)); } catch (_) {}\n    }\n  }\n  return null;\n}\n\nconst parsed = safeJsonParse(content) || {\n  reply: String(content || '').trim() || 'Happy to help. Tell me what you want to create.',\n  action: { type: 'none', topic: '' }\n};\n\nconst allowed = new Set(['carousel', 'video', 'both', 'trends', 'approve', 'regenerate', 'status', 'help', 'none']);\nconst alias = {\n  trend: 'trends',\n  trending: 'trends',\n  publish: 'approve',\n  post: 'approve',\n  redo: 'regenerate',\n  retry: 'regenerate',\n  reel: 'video',\n  reels: 'video',\n  tiktok: 'video'\n};\n\nlet actionType = String(parsed?.action?.type || 'none').toLowerCase().trim();\nactionType = alias[actionType] || actionType;\nif (!allowed.has(actionType)) actionType = 'none';\n\nlet topic = typeof parsed?.action?.topic === 'string' ? parsed.action.topic.trim() : '';\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.userMemory) staticData.userMemory = {};\nconst chatKey = String(chatData.chatId || '');\nconst mem = staticData.userMemory[chatKey] || {};\nconst pending = staticData.pendingContent?.[chatKey] || {};\n\nconst rawUserText = String(chatData.message || '').trim();\nconst userText = rawUserText.toLowerCase();\nconst isSlash = rawUserText.startsWith('/');\n\nif (isSlash) {\n  const cmd = rawUserText.split(/\\s+/)[0].toLowerCase();\n  const cmdTopic = rawUserText.split(/\\s+/).slice(1).join(' ').trim();\n  const cmdMap = {\n    '/carousel': 'carousel',\n    '/video': 'video',\n    '/trends': 'trends',\n    '/approve': 'approve',\n    '/regenerate': 'regenerate',\n    '/status': 'status',\n    '/help': 'help',\n    '/commands': 'none',\n    '/cmds': 'none',\n    '/creator': 'none',\n    '/setface': 'none',\n    '/setvoiceid': 'none',\n    '/auto': 'none'\n  };\n  if (cmdMap[cmd]) {\n    actionType = cmdMap[cmd];\n    if (cmdTopic) topic = cmdTopic;\n    if (!topic && ['carousel','video'].includes(actionType)) {\n      topic = String(staticData.lastTrendByChat?.[chatKey] || '').trim();\n    }\n  }\n}\n\nif (actionType === 'none' && !isSlash) {\n  const wantsTrends = /(trend|trending|latest news|latest trends|what should .*post|what to post|news)/i.test(userText);\n  const wantsApprove = /(approve|post it|publish|go live|looks good,? post|ship it)/i.test(userText);\n  const wantsRegenerate = /(regenerate|redo|try again|another version|rewrite|new version)/i.test(userText);\n  const wantsStatus = /(status|are you online|bot status|system status|health check)/i.test(userText);\n  const wantsHelp = /(^help$|\\bhelp\\b|what can you do|how do you work|commands)/i.test(userText);\n  const wantsCarousel = /(carousel|carousels|slides|instagram post|instagram carousel)/i.test(userText);\n  const wantsVideo = /(video|reel|reels|tiktok|shorts?)/i.test(userText);\n\n  if (wantsTrends) actionType = 'trends';\n  else if (wantsApprove) actionType = 'approve';\n  else if (wantsRegenerate) actionType = 'regenerate';\n  else if (wantsStatus) actionType = 'status';\n  else if (wantsHelp) actionType = 'help';\n  else if (wantsCarousel && wantsVideo) actionType = 'both';\n  else if (wantsCarousel) actionType = 'carousel';\n  else if (wantsVideo) actionType = 'video';\n}\n\nconst confirmLike = /(\\byes\\b|\\bok\\b|\\bokay\\b|go ahead|do it|make it|sounds good|looks good)/i.test(userText);\nif (actionType === 'none' && confirmLike && ['carousel', 'video', 'both'].includes(mem.lastAction)) {\n  actionType = mem.lastAction;\n}\n\nif (!topic && ['carousel', 'video', 'both'].includes(actionType)) {\n  const aboutMatch = rawUserText.match(/\\b(?:about|on|for)\\s+(.+)$/i);\n  if (aboutMatch?.[1]) {\n    topic = aboutMatch[1].replace(/[.!?]+$/g, '').trim();\n  }\n}\nif (!topic && ['carousel', 'video', 'both'].includes(actionType) && isSlash) {\n  topic = String(mem.lastTopic || pending.args || staticData.lastTrendByChat?.[chatKey] || '').trim();\n}\n\nif (!topic && ['carousel', 'video', 'both'].includes(actionType) && !isSlash) {\n  actionType = 'none';\n}\n\nlet replyText = typeof parsed?.reply === 'string' ? parsed.reply.trim() : '';\nif (!replyText) {\n  replyText = actionType === 'none'\n    ? 'Happy to help. Tell me the topic and whether you want a carousel, a video, or both.'\n    : 'Perfect. I am starting that now.';\n}\nif (replyText.length > 500) {\n  replyText = replyText.slice(0, 480).trim() + '...';\n}\n\nif (actionType === 'none' && !isSlash && /(carousel|carousels|slides|instagram carousel|video|reel|reels|shorts?)/i.test(userText)) {\n  replyText = 'Great. What topic should I cover? For example: dementia early signs in UK families.';\n}\n\nif (rawUserText.startsWith('/carousel')) {\n  replyText = topic\n    ? `Great, I will research \"${topic}\" and build your carousel now.`\n    : 'Great, I will use the latest trend topic and build your carousel now.';\n} else if (rawUserText.startsWith('/video')) {\n  replyText = topic\n    ? `Great, I will research \"${topic}\" and start your video draft now.`\n    : 'Great, I will use the latest trend topic and start your video draft now.';\n} else if (rawUserText.startsWith('/trends')) {\n  replyText = 'I am pulling the latest UK dementia-care trends now.';\n}\n\nif (staticData.conversations && staticData.conversations[chatKey]) {\n  staticData.conversations[chatKey].messages.push({ role: 'assistant', content: replyText });\n  if (staticData.conversations[chatKey].messages.length > 12) {\n    staticData.conversations[chatKey].messages = staticData.conversations[chatKey].messages.slice(-12);\n  }\n}\n\nif (actionType !== 'none') {\n  staticData.userMemory[chatKey] = {\n    lastAction: actionType,\n    lastTopic: topic || mem.lastTopic || '',\n    updatedAt: Date.now()\n  };\n} else {\n  staticData.userMemory[chatKey] = {\n    lastAction: mem.lastAction || 'none',\n    lastTopic: mem.lastTopic || '',\n    updatedAt: Date.now()\n  };\n}\n\nreturn [{ json: {\n  chatId: chatData.chatId,\n  messageId: chatData.messageId,\n  replyText,\n  action: { type: actionType, topic },\n  args: topic || '',\n  command: ''\n} }];"
      },
      "id": "conv-0001-0000-0000-000000000003",
      "name": "Parse AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        240,
        500
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.replyText }}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "conv-0001-0000-0000-000000000004",
      "name": "Send AI Reply",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "webhookId": "conv-0001-0000-0000-w00000000004",
      "position": [
        480,
        500
      ],
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "carousel",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Carousel"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "video",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Video"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "both",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Both"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "trends",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Trends"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "approve",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Approve"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "regenerate",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Regenerate"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "status",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Status"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "help",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Help"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "choose_video",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Choose Video"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "conv-0001-0000-0000-000000000105",
      "name": "Action Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        720,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare args for carousel pipeline with strict explicit-topic preference\nconst data = $input.first().json || {};\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.userMemory) staticData.userMemory = {};\nif (!staticData.trendMetaByTitle) staticData.trendMetaByTitle = {};\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction normalizeTopic(s) {\n  let t = clean(s);\n  for (let i = 0; i < 3; i++) {\n    const first = t.charAt(0);\n    const last = t.charAt(t.length - 1);\n    const pairs = { '\"': '\"', \"'\": \"'\", '(': ')', '[': ']', '{': '}' };\n    if (pairs[first] && pairs[first] === last) t = clean(t.slice(1, -1));\n  }\n  return t;\n}\n\nfunction normTitle(s) {\n  return normalizeTopic(s).toLowerCase().replace(/[^a-z0-9\\s]/g, '').replace(/\\s+/g, ' ').trim();\n}\n\nconst chatKey = String(data.chatId || '');\nconst defaultChatKey = String(staticData.defaultChatId || '');\nconst memoryKey = chatKey || defaultChatKey;\nconst pick = (...vals) => vals.map(v => normalizeTopic(v)).find(Boolean) || '';\n\nconst explicitFromSlash = pick(data.forcedTopic, data.debugTopicSources?.directArgs);\nlet args = pick(explicitFromSlash, data.action?.topic, data.args);\nlet topicSource = String(data.topicSource || '').trim();\n\nif (!args) {\n  args = pick(\n    staticData.pendingTrendTopicByChat[memoryKey],\n    staticData.latestSuggestedTopicByChat[memoryKey],\n    staticData.lastTrendByChat[memoryKey],\n    staticData.userMemory?.[memoryKey]?.lastTopic\n  );\n  if (args && !topicSource) topicSource = 'memory';\n}\n\nif (!topicSource) {\n  topicSource = explicitFromSlash ? 'direct' : (args ? 'resolved' : 'none');\n}\n\nfunction findTrendMeta(topic) {\n  const map = staticData.trendMetaByTitle || {};\n  const exact = map[String(topic || '').toLowerCase()];\n  if (exact) return exact;\n\n  const wanted = normTitle(topic);\n  if (!wanted) return {};\n\n  for (const [key, value] of Object.entries(map)) {\n    if (normTitle(key) === wanted) return value || {};\n    if (normTitle(value?.title || '') === wanted) return value || {};\n  }\n  return {};\n}\n\nconst trendMeta = findTrendMeta(args);\nconst selectedTrendSummary = pick(data.selectedTrendSummary, trendMeta.summary);\nconst selectedTrendCategory = pick(data.selectedTrendCategory, trendMeta.category);\nconst selectedTrendRegion = pick(data.selectedTrendRegion, trendMeta.region);\nconst selectedTrendSourceUrl = pick(data.selectedTrendSourceUrl, trendMeta.sourceUrl);\nconst selectedTrendSourceName = pick(data.selectedTrendSourceName, trendMeta.sourceName);\nconst selectedTrendPublishedAt = pick(data.selectedTrendPublishedAt, trendMeta.publishedAt);\n\nconst topicLocked = Boolean(explicitFromSlash || data.explicitTopicProvided || topicSource === 'direct' || topicSource === 'message' || topicSource === 'reply');\n\nif (chatKey && args) {\n  staticData.userMemory[chatKey] = {\n    ...(staticData.userMemory[chatKey] || {}),\n    lastAction: 'carousel',\n    lastTopic: args,\n    updatedAt: Date.now()\n  };\n\n  staticData.pendingTrendTopicByChat[chatKey] = args;\n  staticData.latestSuggestedTopicByChat[chatKey] = args;\n  staticData.lastTrendByChat[chatKey] = args;\n}\n\nreturn [{\n  json: {\n    ...data,\n    args,\n    requestedTopic: args,\n    topicSource,\n    selectedTrendSummary,\n    selectedTrendCategory,\n    selectedTrendRegion,\n    selectedTrendSourceUrl,\n    selectedTrendSourceName,\n    selectedTrendPublishedAt,\n    topicLocked,\n    chatId: data.chatId,\n    messageId: data.messageId\n  }\n}];\n"
      },
      "id": "conv-0001-0000-0000-000000000006",
      "name": "Prepare Carousel Args",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare args for video pipeline with strict explicit-topic preference + creator profile\nconst data = $input.first().json || {};\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.creatorProfileByChat) staticData.creatorProfileByChat = {};\nif (!staticData.trendMetaByTitle) staticData.trendMetaByTitle = {};\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction normalizeTopic(s) {\n  let t = clean(s);\n  for (let i = 0; i < 3; i++) {\n    const first = t.charAt(0);\n    const last = t.charAt(t.length - 1);\n    const pairs = { '\"': '\"', \"'\": \"'\", '(': ')', '[': ']', '{': '}' };\n    if (pairs[first] && pairs[first] === last) t = clean(t.slice(1, -1));\n  }\n  return t;\n}\n\nfunction normTitle(s) {\n  return normalizeTopic(s).toLowerCase().replace(/[^a-z0-9\\s]/g, '').replace(/\\s+/g, ' ').trim();\n}\n\nfunction normalizeGithubRawUrl(u) {\n  const s = clean(u);\n  if (!s) return '';\n\n  // Convert GitHub blob URLs into raw.githubusercontent.com URLs.\n  // https://github.com/<owner>/<repo>/blob/<branch>/<path>\n  const m = s.match(/^https?:\\/\\/github\\.com\\/([^\\/]+)\\/([^\\/]+)\\/blob\\/([^\\/]+)\\/(.+)$/i);\n  if (m) {\n    const owner = m[1];\n    const repo = m[2];\n    const branch = m[3];\n    const path = m[4];\n    return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;\n  }\n\n  return s;\n}\n\nfunction isHttpUrl(v) {\n  return /^https?:\\/\\//i.test(clean(v));\n}\n\nfunction normalizeUrlList(list) {\n  if (!Array.isArray(list)) return [];\n  const out = [];\n  const seen = new Set();\n  for (const item of list) {\n    const u = normalizeGithubRawUrl(item);\n    if (!isHttpUrl(u)) continue;\n    const key = u.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push(u);\n  }\n  return out;\n}\n\nfunction hashToIndex(str, mod) {\n  const s = String(str || '');\n  let h = 0;\n  for (let i = 0; i < s.length; i++) {\n    h = ((h << 5) - h) + s.charCodeAt(i);\n    h |= 0;\n  }\n  const n = Math.abs(h);\n  return mod ? (n % mod) : 0;\n}\n\nfunction takeStableSlice(arr, n, basis) {\n  const list = Array.isArray(arr) ? arr.filter(Boolean) : [];\n  if (list.length <= n) return list;\n  const start = hashToIndex(String(basis || ''), list.length);\n  const out = [];\n  for (let i = 0; i < list.length && out.length < n; i++) {\n    out.push(list[(start + i) % list.length]);\n  }\n  return out;\n}\n\nconst chatKey = String(data.chatId || '');\nconst defaultChatKey = String(staticData.defaultChatId || '');\nconst memoryKey = chatKey || defaultChatKey;\nconst pick = (...vals) => vals.map(v => String(v || '').trim()).find(Boolean) || '';\n\nconst explicitFromSlash = normalizeTopic(data.forcedTopic || data.debugTopicSources?.directArgs || '');\nconst args = normalizeTopic(pick(\n  explicitFromSlash,\n  data.action?.topic,\n  data.args,\n  staticData.pendingTrendTopicByChat[memoryKey],\n  staticData.latestSuggestedTopicByChat[memoryKey],\n  staticData.lastTrendByChat[memoryKey]\n));\n\nfunction findTrendMeta(topic) {\n  const map = staticData.trendMetaByTitle || {};\n  const exact = map[String(topic || '').toLowerCase()];\n  if (exact) return exact;\n\n  const wanted = normTitle(topic);\n  if (!wanted) return {};\n\n  for (const [key, value] of Object.entries(map)) {\n    if (normTitle(key) === wanted) return value || {};\n    if (normTitle(value?.title || '') === wanted) return value || {};\n  }\n  return {};\n}\n\nconst trendMeta = findTrendMeta(args);\nconst selectedTrendSummary = clean(data.selectedTrendSummary || trendMeta.summary || '');\nconst selectedTrendCategory = clean(data.selectedTrendCategory || trendMeta.category || '');\nconst selectedTrendRegion = clean(data.selectedTrendRegion || trendMeta.region || '');\nconst selectedTrendSourceUrl = clean(data.selectedTrendSourceUrl || trendMeta.sourceUrl || '');\nconst selectedTrendSourceName = clean(data.selectedTrendSourceName || trendMeta.sourceName || '');\nconst selectedTrendPublishedAt = clean(data.selectedTrendPublishedAt || trendMeta.publishedAt || '');\n\nconst defaultCreatorImageUrls = normalizeUrlList([\n  'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_casual.png',\n  'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_houndstooth.png',\n  'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_suit.png'\n]);\n\nconst profile = staticData.creatorProfileByChat[chatKey] || staticData.creatorProfileByChat[defaultChatKey] || {};\n\nconst creatorImageUrls = normalizeUrlList(\n  data.creatorImageUrls\n) || [];\n\nconst profileFaceUrls = normalizeUrlList(profile.faceUrls);\nconst poolAll = (creatorImageUrls.length ? creatorImageUrls : (profileFaceUrls.length ? profileFaceUrls : defaultCreatorImageUrls));\nconst pool = takeStableSlice(poolAll, 3, (args || '') + '|' + (chatKey || defaultChatKey || ''));\n\nlet creatorImageUrl = normalizeGithubRawUrl(pick(data.creatorImageUrl, profile.faceUrl));\nif (!isHttpUrl(creatorImageUrl)) creatorImageUrl = '';\n\nif (!creatorImageUrl) {\n  const basis = (args || '') + '|' + (chatKey || defaultChatKey || '');\n  creatorImageUrl = pool[hashToIndex(basis, pool.length)] || '';\n}\n\nconst creatorVoiceId = pick(data.creatorVoiceId, profile.voiceId, 'GoLTMzQJAHarswiHqv3L');\n\nif (chatKey && args) {\n  staticData.pendingTrendTopicByChat[chatKey] = args;\n  staticData.latestSuggestedTopicByChat[chatKey] = args;\n  staticData.lastTrendByChat[chatKey] = args;\n}\n\nreturn [{\n  json: {\n    ...data,\n    videoMode: clean(data.videoMode) || \"kling_multiclip\",\n    args,\n    chatId: data.chatId,\n    messageId: data.messageId,\n    creatorImageUrl,\n    creatorImageUrls: pool,\n    creatorVoiceId,\n    creatorProfileSet: Boolean(creatorImageUrl || creatorVoiceId),\n    selectedTrendSummary,\n    selectedTrendCategory,\n    selectedTrendRegion,\n    selectedTrendSourceUrl,\n    selectedTrendSourceName,\n    selectedTrendPublishedAt\n  }\n}];\n"
      },
      "id": "conv-0001-0000-0000-000000000007",
      "name": "Prepare Video Args",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"perplexity/sonar-pro\",\n  messages: [\n    {\n      role: \"system\",\n      content: \"You are a UK dementia-care research analyst for Dignitate. Produce factual updates for carers. Return strict JSON only and keep one exact topic.\"\n    },\n    {\n      role: \"user\",\n      content:\n        \"TOPIC LOCK (must stay exact): \" + ($json.args || \"dementia caregiving support in the UK\") +\n        \"\\n\\nSELECTED ARTICLE CONTEXT (PRIMARY EVIDENCE; DO NOT DISCARD):\\n\" +\n        JSON.stringify({\n          summary: $json.selectedTrendSummary || '',\n          category: $json.selectedTrendCategory || '',\n          region: $json.selectedTrendRegion || '',\n          source_url: $json.selectedTrendSourceUrl || '',\n          source_name: $json.selectedTrendSourceName || '',\n          published_at: $json.selectedTrendPublishedAt || ''\n        }, null, 2) +\n        \"\\n\\nTASK: Create a factual update for carers in UK dementia care.\" +\n        \"\\n- Start from SELECTED ARTICLE CONTEXT as the anchor.\" +\n        \"\\n- Use web validation only to supplement; do not switch to a different topic/event.\" +\n        \"\\n- Never output search instructions, recommendations about searching, or lines like 'results do not contain information'.\" +\n        \"\\n- Never invent numbers, dates, organisations, locations, or policy names.\" +\n        \"\\n\\nReturn strict JSON only with this schema:\" +\n        \"\\n{\" +\n        \"\\\"topic\\\":\\\"string\\\",\" +\n        \"\\\"summary\\\":\\\"6-8 sentence factual update in plain UK English\\\",\" +\n        \"\\\"key_facts\\\":[{\\\"fact\\\":\\\"string\\\",\\\"source\\\":\\\"string\\\",\\\"date\\\":\\\"string\\\"}],\" +\n        \"\\\"carer_actions\\\":[\\\"string\\\",\\\"string\\\",\\\"string\\\",\\\"string\\\"],\" +\n        \"\\\"narrative_flow\\\":{\\\"slide1\\\":\\\"string\\\",\\\"slide2\\\":\\\"string\\\",\\\"slide3\\\":\\\"string\\\",\\\"slide4\\\":\\\"string\\\",\\\"slide5\\\":\\\"string\\\"},\" +\n        \"\\\"quality_checks\\\":{\\\"topic_match\\\":\\\"yes/no\\\",\\\"confidence\\\":\\\"high/medium/low\\\",\\\"anchor_used\\\":\\\"yes/no\\\",\\\"evidence_gap\\\":\\\"none/minor/major\\\"}\" +\n        \"}\" +\n        \"\\n\\nRequirements:\" +\n        \"\\n- key_facts: 5 to 8 items.\" +\n        \"\\n- Every key_fact must include a concrete detail (number OR named UK service/guidance/policy) plus source and date text.\" +\n        \"\\n- If selected article context exists, include at least 2 key_facts directly grounded in that context.\" +\n        \"\\n- If selected source URL exists, include at least one fact citing source_name/source_url.\" +\n        \"\\n- carer_actions: 4 to 6 practical actions; each starts with a verb and includes where/when (GP/NHS/council/carers centre/this week).\" +\n        \"\\n- narrative_flow: slide1 promise, slide2 key fact, slide3 what it means, slide4 action, slide5 reassurance + CTA.\" +\n        \"\\n- If external evidence is limited, stay with the selected article context and set quality_checks.confidence to low instead of changing topic.\"\n    }\n  ]\n}) }}\n",
        "options": {}
      },
      "id": "research-0001-0000-0000-000000000001",
      "name": "Research for Carousel",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1180,
        160
      ],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2000,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json || {};\nconst content = response.choices?.[0]?.message?.content;\nconst rawText = Array.isArray(content)\n  ? content.map((c) => c?.text || '').join('\\n')\n  : String(content || response.output_text || response.text || '').trim();\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n\\t]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction parseJsonLoose(text) {\n  const t = String(text || '').trim();\n  if (!t) return null;\n\n  const stripped = t\n    .replace(/^\\x60\\x60\\x60json\\s*/i, '')\n    .replace(/^\\x60\\x60\\x60\\s*/i, '')\n    .replace(/\\x60\\x60\\x60$/i, '')\n    .trim();\n\n  try { return JSON.parse(stripped); } catch (e) {}\n\n  const start = stripped.indexOf('{');\n  const end = stripped.lastIndexOf('}');\n  if (start >= 0 && end > start) {\n    try { return JSON.parse(stripped.slice(start, end + 1)); } catch (e2) {}\n  }\n\n  return null;\n}\n\nfunction isLeakText(text) {\n  const t = clean(text).toLowerCase();\n  if (!t) return true;\n\n  const bad = [\n    'to complete this research task',\n    'search specifically for',\n    'search results provided do not contain',\n    'do not contain any information',\n    'return strict json',\n    'topic lock',\n    'output json only',\n    'schema',\n    'recommendation:',\n    '\"explanation\"',\n    \"'explanation'\"\n  ];\n\n  if (bad.some((p) => t.includes(p))) return true;\n  if (/^\\s*[\\[{]/.test(t) && /\"(fact|summary|slides|narrative_flow|quality_checks)\"/i.test(t)) return true;\n  return false;\n}\n\nfunction hasConcreteDetail(text) {\n  const t = clean(text);\n  if (!t) return false;\n  if (/\\d/.test(t)) return true;\n  return /\\b(nhs|gp|icb|care\\s+board|hospital|memory\\s+clinic|assessment|referral|social\\s+care|carers?\\s+centre|guidance|framework|policy|england|uk)\\b/i.test(t);\n}\n\nfunction normalizeFact(v) {\n  if (!v) return { fact: '', source: '', date: '' };\n  if (typeof v === 'string') return { fact: clean(v), source: '', date: '' };\n  return {\n    fact: clean(v.fact || v.statement || v.text || v.value || ''),\n    source: clean(v.source || ''),\n    date: clean(v.date || v.year || ''),\n  };\n}\n\nfunction normalizeAction(v) {\n  if (!v) return '';\n  if (typeof v === 'string') return clean(v);\n  return clean(v.action || v.step || v.text || v.value || '');\n}\n\nfunction deriveAnchorFacts(summary, source, date) {\n  const s = clean(summary);\n  if (!s || isLeakText(s)) return [];\n\n  const parts = s\n    .split(/(?<=[.!?])\\s+/)\n    .map((x) => clean(x))\n    .filter(Boolean);\n\n  const candidates = parts.length ? parts : [s];\n  const out = [];\n  const seen = new Set();\n\n  for (const line of candidates) {\n    if (!line || isLeakText(line)) continue;\n    if (line.length < 24) continue;\n\n    const key = line.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n\n    out.push({\n      fact: line,\n      source: clean(source),\n      date: clean(date)\n    });\n\n    if (out.length >= 3) break;\n  }\n\n  return out;\n}\n\nfunction dedupeFacts(facts) {\n  const out = [];\n  const seen = new Set();\n\n  for (const f of facts) {\n    const fact = clean(f?.fact || '');\n    if (!fact || isLeakText(fact)) continue;\n\n    const source = clean(f?.source || '');\n    const date = clean(f?.date || '');\n    const key = fact.toLowerCase();\n\n    if (seen.has(key)) continue;\n    seen.add(key);\n\n    if (!hasConcreteDetail(fact) && !source && !date) continue;\n    out.push({ fact, source, date });\n    if (out.length >= 8) break;\n  }\n\n  return out;\n}\n\nlet carouselArgs = {};\ntry {\n  carouselArgs = $('Prepare Carousel Args').first().json || {};\n} catch (e) {\n  try { carouselArgs = $('Regeneration Started').first().json || {}; } catch (e2) {}\n}\n\nconst parsed = parseJsonLoose(rawText) || {};\nconst requestedTopic = clean(carouselArgs.args || parsed.topic || 'dementia caregiving support in the UK');\nconst selectedTrendSummary = clean(carouselArgs.selectedTrendSummary || '');\nconst selectedTrendSourceUrl = clean(carouselArgs.selectedTrendSourceUrl || '');\nconst selectedTrendSourceName = clean(carouselArgs.selectedTrendSourceName || '');\nconst selectedTrendPublishedAt = clean(carouselArgs.selectedTrendPublishedAt || '');\nconst isEventTopic = /\\b(conference|summit|event|meeting|forum|congress|workshop)\\b/i.test(requestedTopic);\n\nconst anchorFacts = deriveAnchorFacts(\n  selectedTrendSummary,\n  selectedTrendSourceName || selectedTrendSourceUrl,\n  selectedTrendPublishedAt\n);\n\nconst rawFacts = Array.isArray(parsed.key_facts) ? parsed.key_facts : [];\nconst modelFacts = rawFacts\n  .map(normalizeFact)\n  .filter((f) => f.fact && !isLeakText(f.fact));\n\nconst modelFactCount = modelFacts.length;\nconst missingEvidenceSignal = /do not contain any information|search results provided|search specifically for|recommendation:|cannot verify/i.test(clean(rawText));\nconst researchBlocked = isEventTopic && modelFactCount === 0 && anchorFacts.length === 0 && missingEvidenceSignal;\nconst researchBlockReason = researchBlocked\n  ? 'Could not verify conference-specific facts from reliable sources for this topic. Please refine the topic or share an official event link before generating images.'\n  : '';\n\nlet researchFacts = dedupeFacts([...anchorFacts, ...modelFacts]);\n\nif (!researchFacts.length) {\n  const fallbackFacts = isEventTopic\n    ? [\n        'Public event programmes can change before publication, so check the official organiser page for confirmed agenda, dates, and registration updates.',\n        'For dementia events, focus on sessions covering diagnosis pathways, delirium prevention, and carer support services relevant to NHS practice in England.',\n        'If details are not published yet, avoid assumptions and track official updates weekly before sharing information with carers.'\n      ]\n    : [\n        'Support needs can change quickly in dementia care, so carers benefit from one named NHS or social-care contact for follow-up questions.',\n        'A written plan for medication, meals, hydration, and sleep helps reduce avoidable stress and improves continuity across appointments.',\n        'Early conversations with GP, memory services, and local carers support can prevent crisis-driven decisions later.'\n      ];\n\n  researchFacts = fallbackFacts.map((fact) => ({ fact, source: '', date: '' }));\n}\n\nlet researchSummary = clean(parsed.summary || '');\nif (!researchSummary || isLeakText(researchSummary)) {\n  researchSummary = clean(selectedTrendSummary || researchFacts.map((f) => f.fact).slice(0, 2).join(' '));\n}\nif (!researchSummary) {\n  researchSummary = isEventTopic\n    ? 'No verified programme details were available in the latest pass, so this carousel uses safe practical guidance and official-check steps for carers.'\n    : 'This carousel uses practical UK dementia-care guidance for carers with one clear next step.';\n}\n\nconst rawActions = Array.isArray(parsed.carer_actions) ? parsed.carer_actions : [];\nlet researchActions = rawActions\n  .map(normalizeAction)\n  .filter((a) => a && !isLeakText(a))\n  .slice(0, 6);\n\nif (!researchActions.length) {\n  researchActions = isEventTopic\n    ? [\n        'Check the official event website this week for confirmed dementia and delirium sessions and save the page link.',\n        'Write down two carer-focused questions and raise them with your GP, memory clinic, or community team before your next appointment.',\n        'Keep one-page notes from any event session and convert them into one action you can use at home this week.',\n        'Share verified updates only from official NHS, organiser, or guideline sources when discussing support options with families.'\n      ]\n    : [\n        'Ask your GP or memory service for a named contact and a written care plan you can refer to at home.',\n        'Create a simple weekly routine for medication, meals, hydration, sleep, and rest breaks for carers.',\n        'Keep a symptom and trigger diary to bring to the next NHS or social-care review.',\n        'Use local carers support groups this week for practical help, respite planning, and emotional support.'\n      ];\n}\n\nconst nf = parsed.narrative_flow && typeof parsed.narrative_flow === 'object' ? parsed.narrative_flow : {};\nconst narrativeFlow = {\n  slide1: clean(nf.slide1 || ''),\n  slide2: clean(nf.slide2 || ''),\n  slide3: clean(nf.slide3 || ''),\n  slide4: clean(nf.slide4 || ''),\n  slide5: clean(nf.slide5 || '')\n};\n\nfor (const k of Object.keys(narrativeFlow)) {\n  if (isLeakText(narrativeFlow[k])) narrativeFlow[k] = '';\n}\n\nconst citations = response.citations\n  || response.choices?.[0]?.message?.annotations?.map((a) => a?.url_citation?.url).filter(Boolean)\n  || [];\n\nreturn [{\n  json: {\n    ...carouselArgs,\n    args: requestedTopic,\n    requestedTopic,\n    researchRaw: rawText,\n    researchSummary,\n    researchFacts,\n    researchActions,\n    narrativeFlow,\n    citations,\n    researchModel: response.model || 'unknown',\n    researchLeakGuard: true,\n    researchBlocked,\n    researchBlockReason,\n    anchorFactCount: anchorFacts.length,\n    modelFactCount\n  }\n}];\n"
      },
      "id": "research-0001-0000-0000-000000000002",
      "name": "Parse Carousel Research",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        160
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"perplexity/sonar-pro\",\n  messages: [\n    {\n      role: \"system\",\n      content: \"You are a UK dementia-care research analyst for Dignitate. Return strict JSON only. Keep one exact topic and avoid speculation.\"\n    },\n    {\n      role: \"user\",\n      content:\n        \"TOPIC LOCK (must stay exact): \" + ($json.args || \"signs of caregiver burnout\") +\n        \"\\n\\nSELECTED ARTICLE CONTEXT (PRIMARY ANCHOR):\\n\" +\n        JSON.stringify({\n          summary: $json.selectedTrendSummary || '',\n          category: $json.selectedTrendCategory || '',\n          region: $json.selectedTrendRegion || '',\n          source_url: $json.selectedTrendSourceUrl || '',\n          source_name: $json.selectedTrendSourceName || '',\n          published_at: $json.selectedTrendPublishedAt || ''\n        }, null, 2) +\n        \"\\n\\nResearch this exact topic for a UK dementia-care short video.\" +\n        \"\\n- Use selected article context first; web research only supplements.\" +\n        \"\\n- Do not switch to a different event/topic.\" +\n        \"\\n- Never output search instructions or meta lines (e.g. recommendation/search results/schema/topic lock).\" +\n        \"\\n- Never invent numbers, dates, organisations, or policy names.\" +\n        \"\\n\\nReturn strict JSON only with this schema:\" +\n        \"\\n{\" +\n        \"\\\"topic\\\":\\\"string\\\",\" +\n        \"\\\"summary\\\":\\\"120-180 words factual summary\\\",\" +\n        \"\\\"key_facts\\\":[{\\\"fact\\\":\\\"string\\\",\\\"source\\\":\\\"string\\\",\\\"date\\\":\\\"string\\\"}],\" +\n        \"\\\"carer_actions\\\":[\\\"string\\\",\\\"string\\\",\\\"string\\\"],\" +\n        \"\\\"hook_options\\\":[\\\"string\\\",\\\"string\\\"],\" +\n        \"\\\"cta\\\":\\\"string\\\",\" +\n        \"\\\"quality_checks\\\":{\\\"topic_match\\\":\\\"yes/no\\\",\\\"confidence\\\":\\\"high/medium/low\\\",\\\"anchor_used\\\":\\\"yes/no\\\"}\" +\n        \"}\" +\n        \"\\n\\nRequirements:\" +\n        \"\\n- key_facts: 4 to 6 items. Each must contain concrete UK detail plus source and date text.\" +\n        \"\\n- If selected article context exists, include at least 2 facts grounded in it.\" +\n        \"\\n- If selected source URL exists, include at least 1 fact citing that source.\" +\n        \"\\n- carer_actions: 3 to 5 practical verb-led steps for this week (GP/NHS/council/carers centre).\" +\n        \"\\n- hook_options: short punchy hooks suitable for 9:16 social video.\" +\n        \"\\n- cta must end with: Follow Dignitate for support.\"\n    }\n  ]\n}) }}\n",
        "options": {}
      },
      "id": "research-0001-0000-0000-000000000003",
      "name": "Research for Video",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1180,
        400
      ],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2000,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Extract and normalize video research with factual anchors.\nconst response = $input.first().json || {};\nconst content = response.choices?.[0]?.message?.content;\nconst rawText = (Array.isArray(content) ? content.map(c => c?.text || '').join('\\n') : content) || response.output_text || response.text || '';\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n\\t]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction parseJsonLoose(text) {\n  const t0 = String(text || '').trim();\n  if (!t0) return null;\n\n  const t1 = t0\n    .replace(/^```json\\s*/i, '')\n    .replace(/^```\\s*/i, '')\n    .replace(/```$/i, '')\n    .trim();\n\n  try { return JSON.parse(t1); } catch (e) {}\n\n  const start = t1.indexOf('{');\n  const end = t1.lastIndexOf('}');\n  if (start >= 0 && end > start) {\n    try { return JSON.parse(t1.slice(start, end + 1)); } catch (e2) {}\n  }\n\n  return null;\n}\n\nfunction isLeakText(text) {\n  const t = clean(text).toLowerCase();\n  if (!t) return true;\n  return [\n    'to complete this research task',\n    'search specifically for',\n    'search results provided do not contain',\n    'do not contain any information',\n    'return strict json',\n    'topic lock',\n    'output json only',\n    'schema',\n    'recommendation:'\n  ].some((p) => t.includes(p));\n}\n\nfunction hasConcreteDetail(text) {\n  const t = clean(text);\n  if (!t) return false;\n  if (/\\d/.test(t)) return true;\n  return /\\b(nhs|gp|icb|hospital|memory\\s+clinic|assessment|referral|social\\s+care|carers?\\s+centre|guidance|framework|policy|england|uk)\\b/i.test(t);\n}\n\nfunction normalizeFact(v) {\n  if (!v) return { fact: '', source: '', date: '' };\n  if (typeof v === 'string') return { fact: clean(v), source: '', date: '' };\n  return {\n    fact: clean(v.fact || v.statement || v.text || v.value || ''),\n    source: clean(v.source || ''),\n    date: clean(v.date || v.year || ''),\n  };\n}\n\nfunction normalizeAction(v) {\n  if (!v) return '';\n  if (typeof v === 'string') return clean(v);\n  return clean(v.action || v.step || v.text || v.value || '');\n}\n\nfunction deriveAnchorFacts(summary, source, date) {\n  const s = clean(summary);\n  if (!s || isLeakText(s)) return [];\n\n  const lines = s\n    .split(/(?<=[.!?])\\s+/)\n    .map((x) => clean(x))\n    .filter(Boolean);\n\n  const out = [];\n  const seen = new Set();\n  for (const line of (lines.length ? lines : [s])) {\n    if (!line || line.length < 24 || isLeakText(line)) continue;\n    const k = line.toLowerCase();\n    if (seen.has(k)) continue;\n    seen.add(k);\n    out.push({ fact: line, source: clean(source), date: clean(date) });\n    if (out.length >= 3) break;\n  }\n  return out;\n}\n\nfunction dedupeFacts(list) {\n  const out = [];\n  const seen = new Set();\n  for (const f of list) {\n    const fact = clean(f?.fact || '');\n    if (!fact || isLeakText(fact)) continue;\n    const source = clean(f?.source || '');\n    const date = clean(f?.date || '');\n    const key = fact.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    if (!hasConcreteDetail(fact) && !source && !date) continue;\n    out.push({ fact, source, date });\n    if (out.length >= 8) break;\n  }\n  return out;\n}\n\nlet videoArgs = {};\ntry { videoArgs = $('Prepare Video Args').first().json || {}; } catch (e) {\n  try { videoArgs = $('Video Regen Started').first().json || {}; } catch (e2) {}\n}\n\nconst parsed = parseJsonLoose(rawText) || {};\nconst selectedTrendSummary = clean(videoArgs.selectedTrendSummary || '');\nconst selectedTrendSourceUrl = clean(videoArgs.selectedTrendSourceUrl || '');\nconst selectedTrendSourceName = clean(videoArgs.selectedTrendSourceName || '');\nconst selectedTrendPublishedAt = clean(videoArgs.selectedTrendPublishedAt || '');\n\nconst anchorFacts = deriveAnchorFacts(\n  selectedTrendSummary,\n  selectedTrendSourceName || selectedTrendSourceUrl,\n  selectedTrendPublishedAt\n);\n\nconst modelFacts = (Array.isArray(parsed.key_facts) ? parsed.key_facts : [])\n  .map(normalizeFact)\n  .filter((f) => f.fact && !isLeakText(f.fact));\n\nconst researchFacts = dedupeFacts([...anchorFacts, ...modelFacts]).slice(0, 6);\n\nconst fallbackActions = [\n  'Ask your GP or memory service this week for one named contact and a written care plan update.',\n  'Write down one warning sign you are seeing at home and bring it to the next NHS or social-care review.',\n  'Use your local carers centre this week for practical support, respite options, and next-step advice.'\n];\n\nlet researchActions = (Array.isArray(parsed.carer_actions) ? parsed.carer_actions : [])\n  .map(normalizeAction)\n  .filter((a) => a && !isLeakText(a))\n  .slice(0, 5);\nif (!researchActions.length) researchActions = fallbackActions;\n\nlet researchSummary = clean(parsed.summary || '');\nif (!researchSummary || isLeakText(researchSummary)) {\n  researchSummary = clean(selectedTrendSummary || researchFacts.map((f) => f.fact).slice(0, 2).join(' '));\n}\nif (!researchSummary) {\n  researchSummary = 'Practical UK dementia-care update for carers with one clear step to take this week.';\n}\n\nconst hookOptions = (Array.isArray(parsed.hook_options) ? parsed.hook_options : [])\n  .map((x) => clean(x))\n  .filter((x) => x && !isLeakText(x))\n  .slice(0, 3);\n\nlet cta = clean(parsed.cta || '');\nif (!cta || isLeakText(cta)) cta = 'Take one small step today and Follow Dignitate for support.';\nif (!/follow\\s+dignitate\\s+for\\s+support\\.?$/i.test(cta)) {\n  cta = clean(cta.replace(/[.!?]*$/, '') + '. Follow Dignitate for support.');\n}\n\nconst factsText = researchFacts.length\n  ? researchFacts.map((f, i) => {\n      const src = [f.source, f.date].filter(Boolean).join(', ');\n      return `${i + 1}) ${f.fact}${src ? ` (${src})` : ''}`;\n    }).join('\\n')\n  : '1) ' + clean(selectedTrendSummary || 'No verified fact available.');\n\nconst actionsText = researchActions.map((a, i) => `${i + 1}) ${a}`).join('\\n');\n\nconst research = [\n  `Summary: ${researchSummary}`,\n  'Key facts:',\n  factsText,\n  'Carer actions:',\n  actionsText,\n  `CTA: ${cta}`\n].join('\\n');\n\nconst citations = response.citations || response.choices?.[0]?.message?.annotations?.map(a => a?.url_citation?.url).filter(Boolean) || [];\n\nreturn [{\n  json: {\n    ...videoArgs,\n    research,\n    researchSummary,\n    researchFacts,\n    researchActions,\n    hookOptions,\n    cta,\n    citations,\n    researchModel: response.model || 'unknown',\n    anchorFactCount: anchorFacts.length,\n    modelFactCount: modelFacts.length\n  }\n}];\n"
      },
      "id": "research-0001-0000-0000-000000000004",
      "name": "Parse Video Research",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Deterministic intent guard before Action Router, with strict topic locking\nconst data = $input.first().json || {};\nconst incoming = data.action || {};\nlet type = String(incoming.type || 'none').toLowerCase().trim();\nlet topic = String(incoming.topic || data.args || '').trim();\nlet autoAction = String(data.autoAction || '').toLowerCase().trim();\nlet topicSource = String(data.topicSource || '').toLowerCase().trim();\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction normalizeTopic(s) {\n  let t = clean(s);\n  for (let i = 0; i < 3; i++) {\n    const first = t.charAt(0);\n    const last = t.charAt(t.length - 1);\n    const pairs = { '\"': '\"', \"'\": \"'\", '(': ')', '[': ']', '{': '}' };\n    if (pairs[first] && pairs[first] === last) t = clean(t.slice(1, -1));\n  }\n  return t;\n}\n\nlet raw = '';\nlet chatId = String(data.chatId || '');\ntry {\n  const load = $('Load Chat History').first().json || {};\n  raw = String(load.message || '');\n  if (!chatId) chatId = String(load.chatId || '');\n} catch (e) {}\nconst msg = raw.toLowerCase();\nconst isSlashMessage = raw.trim().startsWith('/');\n\nconst command = String(data.command || '').toLowerCase().trim();\nconst directArgs = normalizeTopic(data.forcedTopic || data.debugTopicSources?.directArgs || '');\n\ntopic = normalizeTopic(topic);\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.userMemory) staticData.userMemory = {};\nif (!staticData.pendingAutoActionByChat) staticData.pendingAutoActionByChat = {};\n\nconst chatKey = String(chatId || '');\nconst defaultChatKey = String(staticData.defaultChatId || '');\nconst memoryKey = chatKey || defaultChatKey;\nconst pick = (...vals) => vals.map(v => normalizeTopic(v)).find(Boolean) || '';\n\nconst handledExternally = new Set(['/commands', '/cmds', '/auto', '/creator', '/setface', '/setvoiceid']);\nif (handledExternally.has(command)) {\n  return [{\n    json: {\n      ...data,\n      chatId,\n      action: { type: 'none', topic: '' },\n      args: '',\n      autoAction: '',\n      topicSource: 'command',\n      debugEnsureTopic: {\n        chatKey,\n        command,\n        topicResolved: '',\n        topicSource: 'command',\n        autoAction: ''\n      }\n    }\n  }];\n}\n\nif ((command === '/carousel' || command === '/video') && type !== 'trends' && type !== 'choose_video') {\n  type = command.slice(1);\n  if (directArgs) {\n    topic = directArgs;\n    topicSource = 'direct';\n  }\n}\n\nif (!autoAction && chatKey) {\n  autoAction = String(staticData.pendingAutoActionByChat?.[chatKey] || '').toLowerCase().trim();\n}\nif (!['carousel', 'video'].includes(autoAction)) autoAction = '';\n\nif (type === 'none' && !isSlashMessage) {\n  const wantsTrends = /(trend|trending|latest news|latest trends|what should .*post|what to post|news)/i.test(msg);\n  const wantsApprove = /(approve|post it|publish|go live|looks good,? post|ship it)/i.test(msg);\n  const wantsRegenerate = /(regenerate|redo|try again|another version|rewrite|new version)/i.test(msg);\n  const wantsStatus = /(status|are you online|bot status|system status|health check)/i.test(msg);\n  const wantsHelp = /(^help$|\\bhelp\\b|what can you do|how do you work|commands)/i.test(msg);\n  const wantsCarousel = /(carousel|carousels|slides|instagram post|instagram carousel)/i.test(msg);\n  const wantsVideo = /(video|reel|reels|tiktok|shorts?)/i.test(msg);\n\n  if (wantsTrends) type = 'trends';\n  else if (wantsApprove) type = 'approve';\n  else if (wantsRegenerate) type = 'regenerate';\n  else if (wantsStatus) type = 'status';\n  else if (wantsHelp) type = 'help';\n  else if (wantsCarousel && wantsVideo) type = 'both';\n  else if (wantsCarousel) type = 'carousel';\n  else if (wantsVideo) type = 'video';\n}\n\nif (!topic && ['carousel', 'video', 'both'].includes(type)) {\n  const m = raw.match(/\\/(?:carousel|video)(?:@[A-Za-z0-9_]+)?\\s+([\\s\\S]+)$/i)\n    || raw.match(/\\b(?:about|on|for)\\s+(.+)$/i);\n  if (m?.[1]) {\n    topic = normalizeTopic(m[1].replace(/[.!?]+$/g, ''));\n    topicSource = topicSource || 'message';\n  }\n}\n\nif (!topic && ['carousel', 'video', 'both'].includes(type)) {\n  topic = pick(\n    data.args,\n    incoming.topic,\n    staticData.pendingTrendTopicByChat[memoryKey],\n    staticData.latestSuggestedTopicByChat[memoryKey],\n    staticData.lastTrendByChat[memoryKey]\n  );\n  if (topic) topicSource = topicSource || 'memory';\n}\n\nif (!topic && ['carousel', 'video', 'both'].includes(type)) {\n  autoAction = type === 'both' ? 'carousel' : type;\n  type = 'trends';\n  if (chatKey) staticData.pendingAutoActionByChat[chatKey] = autoAction;\n}\n\nif (topic && ['carousel', 'video', 'both'].includes(type) && chatKey) {\n  staticData.userMemory[chatKey] = {\n    ...(staticData.userMemory[chatKey] || {}),\n    lastAction: type,\n    lastTopic: topic,\n    updatedAt: Date.now()\n  };\n\n  if (topicSource === 'direct' || topicSource === 'message' || topicSource === 'reply') {\n    staticData.pendingTrendTopicByChat[chatKey] = topic;\n    staticData.latestSuggestedTopicByChat[chatKey] = topic;\n    staticData.lastTrendByChat[chatKey] = topic;\n  }\n}\n\nconst debugEnsureTopic = {\n  chatKey,\n  memoryKey,\n  typeBeforeFinal: type,\n  topicResolved: topic,\n  topicSource,\n  pendingByChat: String(staticData.pendingTrendTopicByChat?.[chatKey] || ''),\n  latestByChat: String(staticData.latestSuggestedTopicByChat?.[chatKey] || ''),\n  lastByChat: String(staticData.lastTrendByChat?.[chatKey] || ''),\n  autoAction,\n  forcedTopic: directArgs,\n  command\n};\n\nreturn [{\n  json: {\n    ...data,\n    chatId,\n    action: { type, topic },\n    args: topic || data.args || '',\n    autoAction,\n    topicSource,\n    debugEnsureTopic\n  }\n}];"
      },
      "id": "conv-0001-0000-0000-000000000205",
      "name": "Ensure Action Intent",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        500
      ]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst clean = (s) => String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\nconst normTitle = (s) => clean(s).toLowerCase().replace(/[^a-z0-9\\s]/g, '').replace(/\\s+/g, ' ').trim();\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.userMemory) staticData.userMemory = {};\nif (!staticData.globalSuggestedTopic) staticData.globalSuggestedTopic = '';\nif (!staticData.trendMetaByTitle) staticData.trendMetaByTitle = {};\n\nreturn items.map((item, index) => {\n  const d = item.json || {};\n\n  const title = clean(d.title || d.topic || 'Untitled topic').slice(0, 180);\n  const summary = clean(d.summary || d.description || 'No summary available.').slice(0, 1200);\n  const category = clean(d.category || 'caregiving');\n  const region = clean(d.region || 'UK');\n  const sourceUrl = clean(d.source_url || d.sourceUrl || '');\n  const sourceName = clean(d.source_name || d.sourceName || '');\n  const publishedAt = clean(d.published_at || d.publishedAt || '');\n\n  let score = Number(d.engagement_score ?? d.engagementScore ?? 7);\n  if (!Number.isFinite(score)) score = 7;\n  score = Math.max(1, Math.min(10, Math.round(score)));\n\n  const rank = Number.isFinite(Number(d.rank)) ? Number(d.rank) : (index + 1);\n  const total = Number.isFinite(Number(d.totalTopics)) ? Number(d.totalTopics) : items.length;\n\n  const trendMessage = [\n    `Trending Topic ${rank}/${total}:`,\n    '',\n    title,\n    '',\n    summary,\n    '',\n    `Category: ${category}`,\n    `Region: ${region}`,\n    `Engagement Score: ${score}/10`,\n    ...(sourceUrl ? [`Source: ${sourceName || 'link'} - ${sourceUrl}`] : []),\n    ...(publishedAt ? [`Published: ${publishedAt}`] : []),\n    '',\n    'Tap one of the buttons below to generate content for this exact topic.',\n    'Workflow build: 2026-02-18-video-mode-topic-fix',\n    'Manual fallback: type carousel + topic or video + topic'\n  ].join('\\n');\n\n  const chatKey = String(d.chatId || staticData.defaultChatId || '');\n  if (title) {\n    const meta = {\n      title,\n      summary,\n      category,\n      region,\n      sourceUrl,\n      sourceName,\n      publishedAt,\n      updatedAt: Date.now()\n    };\n    staticData.trendMetaByTitle[title.toLowerCase()] = meta;\n    const normalized = normTitle(title);\n    if (normalized) staticData.trendMetaByTitle[normalized] = meta;\n  }\n\n  if (chatKey && title) {\n    staticData.pendingTrendTopicByChat[chatKey] = title;\n    staticData.latestSuggestedTopicByChat[chatKey] = title;\n    staticData.lastTrendByChat[chatKey] = title;\n    staticData.globalSuggestedTopic = title;\n    staticData.userMemory[chatKey] = {\n      ...(staticData.userMemory[chatKey] || {}),\n      lastTopic: title,\n      lastAction: 'trends',\n      updatedAt: Date.now()\n    };\n  }\n\n  return {\n    json: {\n      ...d,\n      title,\n      summary,\n      category,\n      region,\n      engagement_score: score,\n      rank,\n      totalTopics: total,\n      trendMessage,\n      callbackCarousel: '/carousel',\n      callbackVideo: '/video',\n      sourceUrl,\n      sourceName,\n      publishedAt\n    }\n  };\n});\n"
      },
      "id": "trend-0001-0000-0000-000000000001",
      "name": "Format Trend Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        640
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst apiKey = String($('TEST_KEYS').first().json.falKey || '').trim();\nconst modelPath = 'fal-ai/nano-banana-pro';\nconst headers = { Authorization: 'Key ' + apiKey };\n\nconst pollIntervalMs = 2000;\nconst maxChecks = 220;\nconst maxWaitMs = 600000;\nconst resultRetryCount = 8;\nconst transientCodes = new Set([404, 409, 422, 425, 429]);\n\nconst httpRequest =\n  (typeof $httpRequest === 'function' && $httpRequest) ||\n  (this && this.helpers && typeof this.helpers.httpRequest === 'function'\n    ? this.helpers.httpRequest.bind(this)\n    : null);\n\nif (!httpRequest) {\n  throw new Error('n8n HTTP helper is unavailable in this Code node runtime.');\n}\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nfunction getStatusCode(err) {\n  const candidates = [\n    err?.statusCode,\n    err?.status,\n    err?.httpCode,\n    err?.response?.statusCode,\n    err?.response?.status\n  ];\n  for (const c of candidates) {\n    const n = Number(c);\n    if (Number.isFinite(n)) return n;\n  }\n\n  const msg = String(err?.message || '');\n  const m = msg.match(/status\\s*code\\s*(\\d{3})/i) || msg.match(/\\b(\\d{3})\\b/);\n  if (m?.[1]) {\n    const n = Number(m[1]);\n    if (Number.isFinite(n)) return n;\n  }\n  return null;\n}\n\nfunction safeJson(v, maxLen = 500) {\n  try {\n    const s = JSON.stringify(v);\n    if (!s) return '';\n    return s.length > maxLen ? s.slice(0, maxLen) + '...' : s;\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction errText(err) {\n  const base = String(err?.message || err || 'unknown error');\n  const status = getStatusCode(err);\n  const body = safeJson(err?.response?.body || err?.body || err?.data || null);\n  return base + (status ? (' [status ' + status + ']') : '') + (body ? (' body=' + body) : '');\n}\n\nfunction readStatus(json) {\n  // Do not use nested result.status here; it can report completed before assets are fetchable.\n  return String(\n    (json &&\n      (json.status ||\n        json.request_status ||\n        json.state ||\n        json.phase ||\n        (json.data && json.data.status))) ||\n      ''\n  ).toUpperCase();\n}\n\nfunction readQueuePos(json) {\n  const v = json?.queue_position ?? json?.data?.queue_position ?? null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction normalizeImages(payload) {\n  const out = [];\n  const seen = new Set();\n\n  function pushUrl(v) {\n    const u = String(v || '').trim();\n    if (!u || !/^https?:\\/\\//i.test(u) || seen.has(u)) return;\n    seen.add(u);\n    out.push({ url: u });\n  }\n\n  function consume(node, depth = 0) {\n    if (!node || depth > 6) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) consume(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      pushUrl(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    if (typeof node.url === 'string') pushUrl(node.url);\n    if (typeof node.image_url === 'string') pushUrl(node.image_url);\n    if (typeof node.imageUrl === 'string') pushUrl(node.imageUrl);\n\n    if (Array.isArray(node.images)) consume(node.images, depth + 1);\n    if (Array.isArray(node.outputs)) consume(node.outputs, depth + 1);\n    if (Array.isArray(node.output)) consume(node.output, depth + 1);\n\n    if (node.data) consume(node.data, depth + 1);\n    if (node.result) consume(node.result, depth + 1);\n    if (node.response) consume(node.response, depth + 1);\n    if (node.image) consume(node.image, depth + 1);\n  }\n\n  consume(payload);\n  return out;\n}\n\nfunction buildFallbackStatusUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId) + '/status';\n}\n\nfunction buildFallbackResultUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId);\n}\n\nasync function getStatusByUrl(statusUrl, requestId) {\n  const url = statusUrl || buildFallbackStatusUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function getResultByUrl(responseUrl, requestId) {\n  const url = responseUrl || buildFallbackResultUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function waitForOne(item) {\n  const inputJson = item.json || {};\n  const requestId = inputJson.request_id || inputJson.requestId;\n  const statusUrl = String(inputJson.status_url || inputJson.statusUrl || '').trim();\n  const responseUrl = String(inputJson.response_url || inputJson.responseUrl || '').trim();\n\n  const syncImages = normalizeImages(inputJson);\n  if (syncImages.length) {\n    return { json: { ...inputJson, images: syncImages, falStatus: 'COMPLETED_SYNC', falPollAttempts: 0 } };\n  }\n\n  if (!requestId && !statusUrl && !responseUrl) {\n    throw new Error('fal.ai submit did not return request_id/status_url/response_url.');\n  }\n\n  const startedAt = Date.now();\n  let attempts = 0;\n  let statusValue = '';\n  let lastQueuePosition = null;\n\n  while (attempts < maxChecks && (Date.now() - startedAt) < maxWaitMs) {\n    attempts++;\n\n    let statusJson;\n    try {\n      statusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(statusJson);\n      lastQueuePosition = readQueuePos(statusJson);\n    } catch (err) {\n      const code = getStatusCode(err);\n      if (transientCodes.has(code)) {\n        statusValue = statusValue || 'IN_QUEUE';\n      } else {\n        throw new Error('fal.ai status request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n      }\n    }\n\n    if (statusValue === 'COMPLETED') break;\n    if (['FAILED', 'ERROR', 'CANCELLED'].includes(statusValue)) {\n      throw new Error('fal.ai request ' + (requestId || 'unknown') + ' failed with status ' + statusValue + '.');\n    }\n\n    const elapsed = Date.now() - startedAt;\n    const remaining = maxWaitMs - elapsed;\n    if (remaining <= 0) break;\n    await sleep(Math.min(pollIntervalMs, remaining));\n  }\n\n  if (statusValue !== 'COMPLETED') {\n    try {\n      const finalStatusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(finalStatusJson) || statusValue;\n      lastQueuePosition = readQueuePos(finalStatusJson) ?? lastQueuePosition;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  let resultJson = null;\n  const tryGetResult = async () => {\n    for (let i = 0; i < resultRetryCount; i++) {\n      try {\n        const res = await getResultByUrl(responseUrl, requestId || '');\n        if (res && typeof res === 'object') return res;\n      } catch (err) {\n        const code = getStatusCode(err);\n        if (!transientCodes.has(code)) {\n          throw new Error('fal.ai result request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n        }\n      }\n      await sleep(Math.min(1200 + i * 300, 3000));\n    }\n    return null;\n  };\n\n  if (statusValue === 'COMPLETED') {\n    resultJson = await tryGetResult();\n  } else {\n    try {\n      const possible = await tryGetResult();\n      const hasImages = normalizeImages(possible).length > 0;\n      if (hasImages) {\n        resultJson = possible;\n        statusValue = 'COMPLETED_LATE';\n      }\n    } catch (e) {\n      // no-op\n    }\n  }\n\n  if (!resultJson || typeof resultJson !== 'object') {\n    const seconds = Math.max(1, Math.round((Date.now() - startedAt) / 1000));\n    throw new Error(\n      'fal.ai request ' + (requestId || 'unknown') + ' is still ' + (statusValue || 'IN_QUEUE') +\n      ' after ' + attempts + ' checks (~' + seconds + 's), queue_position=' +\n      (lastQueuePosition == null ? 'n/a' : lastQueuePosition) +\n      '. Queue is busy or result is not ready yet. Retry /carousel in 1-2 minutes.'\n    );\n  }\n\n  const normalized = normalizeImages(resultJson);\n  const merged = {\n    ...inputJson,\n    ...resultJson,\n    images: normalized,\n    request_id: requestId || inputJson.request_id || '',\n    falStatus: statusValue || 'COMPLETED',\n    falPollAttempts: attempts,\n  };\n\n  if (!normalized.length) {\n    merged.falError = 'fal.ai completed but returned no image URLs in supported fields.';\n  }\n\n  return { json: merged };\n}\n\nconst out = [];\nlet lastError = null;\n\nfor (const item of items) {\n  try {\n    out.push(await waitForOne(item));\n  } catch (err) {\n    lastError = err;\n    out.push({\n      json: {\n        ...(item.json || {}),\n        falStatus: 'ERROR',\n        falError: String(err.message || err),\n        images: []\n      }\n    });\n  }\n}\n\nconst anyImages = out.some((o) => {\n  const j = o.json || {};\n  return Array.isArray(j.images) && j.images.length > 0;\n});\n\nif (!anyImages && lastError) {\n  throw lastError;\n}\n\nreturn out;",
        "mode": "runOnceForAllItems",
        "language": "javaScript"
      },
      "id": "fal-await-image-result-v1",
      "name": "fal.ai - Await Image Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1660,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// If /carousel or /video had no saved topic, continue automatically after fresh trend is sent.\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingAutoActionByChat) staticData.pendingAutoActionByChat = {};\n\nlet trend = {};\ntry { trend = $('Format Trend Message').first().json || {}; } catch (e) {}\n\nconst chatKey = String(trend.chatId || staticData.defaultChatId || '');\nif (!chatKey) return [];\n\nconst autoAction = String(staticData.pendingAutoActionByChat[chatKey] || '').toLowerCase().trim();\nif (!['carousel', 'video'].includes(autoAction)) return [];\n\nconst topic = String(trend.title || trend.topic || '').trim();\nif (!topic) return [];\n\n// Consume one-shot auto action to avoid repeated triggers.\nstaticData.pendingAutoActionByChat[chatKey] = '';\n\nreturn [{\n  json: {\n    ...trend,\n    chatId: trend.chatId,\n    messageId: trend.messageId,\n    args: topic,\n    action: { type: autoAction, topic },\n    autoAction\n  }\n}];"
      },
      "id": "trend-auto-continue-code-v1",
      "name": "Auto Continue From Trends",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1080,
        700
      ]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n\\t]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction stripMeta(text) {\n  let t = clean(text);\n  if (!t) return t;\n  t = t\n    .replace(/^(why this matters now|what changed|evidence update|what this means for carers|next step|key takeaway|conclusion)\\s*[:\\-]\\s*/i, '')\n    .replace(/\\b(why\\s+this\\s+matters\\s+now|what\\s+changed|evidence\\s+update|key\\s+takeaway|next\\s+step|conclusion)\\b\\s*[:\\-]?\\s*/ig, '')\n    .trim();\n  return t;\n}\n\nfunction hashSeed(text) {\n  const src = clean(text) || 'dignitate';\n  let acc = 0;\n  for (let i = 0; i < src.length; i++) {\n    acc = (acc * 131 + src.charCodeAt(i)) % 1000000000;\n  }\n  return Math.abs(acc);\n}\n\nfunction words(text) {\n  return stripMeta(text).split(/\\s+/).filter(Boolean);\n}\n\nfunction dedupe(text) {\n  let t = clean(text);\n  if (!t) return t;\n  for (let i = 0; i < 2; i++) {\n    t = t\n      .replace(/\\b(\\w+(?:\\s+\\w+){2,8})\\s+\\1\\b/gi, '$1')\n      .replace(/\\b(\\w+(?:\\s+\\w+){1,6})\\s+\\1\\b/gi, '$1');\n  }\n  return clean(t);\n}\n\nfunction headingText(text, fallback) {\n  let h = dedupe(stripMeta(text));\n  if (!h) h = fallback;\n  h = words(h).slice(0, 8).join(' ');\n  if (words(h).length < 3) h = words(fallback).slice(0, 8).join(' ');\n  return h;\n}\n\nfunction bodyText(text, fallback) {\n  let b = dedupe(stripMeta(text));\n  if (!b) b = fallback;\n  const w = words(b);\n  b = w.slice(0, 24).join(' ');\n  if (words(b).length < 12) {\n    const fw = words(fallback).slice(0, 24);\n    b = fw.join(' ');\n  }\n  return b;\n}\n\nfunction extractHeadingBody(d) {\n  const h = clean(d.slideHeading || d.heading || '');\n  const b = clean(d.slideBody || d.subline || '');\n  if (h || b) return { heading: h, body: b };\n\n  const t = clean(d.slideText || d.text || '');\n  const idx = t.indexOf(':');\n  if (idx > 0 && idx < 80) {\n    return { heading: clean(t.slice(0, idx)), body: clean(t.slice(idx + 1)) };\n  }\n\n  const ws = words(t);\n  return { heading: ws.slice(0, 7).join(' '), body: ws.slice(7).join(' ') };\n}\n\nreturn items.map((item) => {\n  const d = item.json || {};\n\n  const title = clean(d.title) || 'Dignitate Dementia Care Update';\n  const topic = clean(d.args || d.title) || 'dementia care support in England';\n  const slideIndex = Number(d.slideIndex || 0);\n  const totalSlides = Number(d.totalSlides || 5);\n  const role = String(d.slideRole || (slideIndex === 0 ? 'cover' : (slideIndex === totalSlides - 1 ? 'conclusion' : 'information'))).toLowerCase();\n\n  const extracted = extractHeadingBody(d);\n\n  let heading = headingText(extracted.heading, 'Dementia Care Update');\n  let body = bodyText(extracted.body, 'Ask your GP for a named contact and keep one written support step for this week.');\n\n  if (role === 'conclusion' && !/\\bfollow\\s+dignitate\\b/i.test(body)) {\n    body = clean(body + ' Follow Dignitate for support.');\n  }\n\n  // Keep body concise enough to avoid overflow and truncation artifacts.\n  if (body.length > 165) {\n    const short = body.slice(0, 165);\n    const cut = short.lastIndexOf(' ');\n    body = clean(cut > 0 ? short.slice(0, cut) : short);\n  }\n\n  const slideImagePrompt = clean(d.imagePrompt || d.image_prompt || d.visualPrompt || d.prompt || '');\n\n  const prompt = [\n    'Create exactly ONE single 4:5 portrait carousel slide image.',\n    'Dignitate style: modern, clean, UK healthcare editorial.',\n    'Layout rules:',\n    '- Top 52%: solid off-white text panel with generous margins.',\n    '- Bottom 48%: one photorealistic UK dementia-care scene that matches the slide meaning.',\n    'Photo scene brief (bottom image only): ' + (slideImagePrompt || 'UK dementia-care documentary moment') + '.',\n    'Critical text rendering rules:',\n    '- Render EXACTLY TWO text blocks ONLY: one Headline and one Subline.',\n    '- Allowed on-canvas text is ONLY the headline and subline provided below.',\n    '- Do NOT add any kicker/eyebrow line, deck, title, footer, date, source, or slide number.',\n    '- Do NOT repeat words or duplicate phrases.',\n    '- Keep headline max 2 lines, subline max 4 lines.',\n    '- If text is tight, shrink font size slightly; never add extra text blocks.',\n    'Do NOT include logos, watermarks, hashtags, charts, icons, UI, or badges.',\n    'Topic context for scene only (NOT rendered as text): ' + topic + '.',\n    'Headline: \"' + heading + '\".',\n    'Subline: \"' + body + '\".'\n  ].join(' ');\n\n  const falSeed = hashSeed('DIGNITATE_CAROUSEL_V3|' + title + '|' + topic + '|slide:' + slideIndex + '|' + heading);\n\n  return {\n    json: {\n      ...d,\n      slideRole: role,\n      slideHeading: heading,\n      slideBody: body,\n      falPrompt: prompt,\n      falSeed,\n      falPromptPreview: prompt.slice(0, 700),\n    }\n  };\n});"
      },
      "id": "fal-build-prompt-v2",
      "name": "Build fal.ai Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1320,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json || {};\nlet raw = '';\ntry { raw = String($('Load Chat History').first().json.message || '').trim(); } catch (e) {}\nif (!raw) return [{ json: data }];\n\nconst isAuto = /^\\/auto(?:\\b|$)/i.test(raw);\nconst isCommands = /^\\/(commands|cmds)(?:\\b|$)/i.test(raw);\nconst isCreator = /^\\/(setface|setvoiceid|creator)(?:\\b|$)/i.test(raw);\nif (!isAuto && !isCommands && !isCreator) return [{ json: data }];\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.autoScheduleByChat) staticData.autoScheduleByChat = {};\nif (!staticData.pendingAutoActionByChat) staticData.pendingAutoActionByChat = {};\nif (!staticData.creatorProfileByChat) staticData.creatorProfileByChat = {};\nif (!staticData.defaultChatId && data.chatId) staticData.defaultChatId = String(data.chatId);\n\nconst chatKey = String(data.chatId || staticData.defaultChatId || '');\nif (!chatKey) {\n  return [{ json: { ...data, action: { type: 'none', topic: '' }, args: '', replyText: 'Could not identify chat for setup.' } }];\n}\n\nconst creatorDefaults = {\n  faceUrls: [\n    'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_casual.png',\n    'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_houndstooth.png',\n    'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_suit.png',\n    'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_shirt.png',\n    'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_layered.png'\n  ],\n  faceUrl: 'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_houndstooth.png',\n  voiceId: 'GoLTMzQJAHarswiHqv3L',\n  updatedAt: Date.now(),\n};\nconst creatorCfg = {\n  ...creatorDefaults,\n  ...(staticData.creatorProfileByChat[chatKey] || {}),\n};\n\nconst cfg = {\n  enabled: false,\n  timezoneOffset: '+00:00',\n  carouselTime: '09:00',\n  videoTime: '18:00',\n  fixedTopic: '',\n  lastRun: {},\n  ...(staticData.autoScheduleByChat[chatKey] || {}),\n  updatedAt: Date.now(),\n};\n\nconst botFatherCommands = [\n  'carousel - Create carousel from topic',\n  'video - Create video from topic',\n  'trends - Get latest trend topic',\n  'approve - Approve pending draft',\n  'regenerate - Regenerate pending draft',\n  'status - Check bot status',\n  'help - Show help',\n  'setface - Set creator face image URL',\n  'setvoiceid - Set ElevenLabs voice ID',\n  'creator - Show creator profile',\n  'commands - Show command list'\n].join('\\n');\n\nfunction normalizeGithubRawUrl(u) {\n  const s = String(u || '').trim();\n  const m = s.match(/^https?:\\/\\/github\\.com\\/([^\\/]+)\\/([^\\/]+)\\/blob\\/([^\\/]+)\\/(.+)$/i);\n  if (m) return `https://raw.githubusercontent.com/${m[1]}/${m[2]}/${m[3]}/${m[4]}`;\n  return s;\n}\n\nfunction isHttpUrl(v) {\n  return /^https?:\\/\\//i.test(String(v || '').trim());\n}\n\nif (isAuto) {\n  cfg.enabled = false;\n  cfg.updatedAt = Date.now();\n  staticData.autoScheduleByChat[chatKey] = cfg;\n  staticData.pendingAutoActionByChat[chatKey] = '';\n  staticData.creatorProfileByChat[chatKey] = creatorCfg;\n\n  return [{\n    json: {\n      ...data,\n      action: { type: 'none', topic: '' },\n      args: '',\n      replyText: [\n        'Auto mode is temporarily disabled.',\n        'Use manual commands for now:',\n        '/carousel <topic>',\n        '/video <topic>',\n        '/trends'\n      ].join('\\n')\n    }\n  }];\n}\n\nif (isCommands) {\n  staticData.autoScheduleByChat[chatKey] = cfg;\n  staticData.pendingAutoActionByChat[chatKey] = '';\n  staticData.creatorProfileByChat[chatKey] = creatorCfg;\n\n  return [{\n    json: {\n      ...data,\n      action: { type: 'none', topic: '' },\n      args: '',\n      replyText: [\n        'Available commands:',\n        '/carousel <topic>',\n        '/video <topic>',\n        '/trends',\n        '/approve',\n        '/regenerate',\n        '/status',\n        '/help',\n        '/setface <public_image_url>',\n        '/setvoiceid <elevenlabs_voice_id>',\n        '/creator',\n        '',\n        'Auto mode is currently disabled.',\n        '',\n        'To show commands in Telegram / menu, use @BotFather /setcommands and paste:',\n        botFatherCommands\n      ].join('\\n')\n    }\n  }];\n}\n\nconst cmd = String(raw.split(/\\s+/)[0] || '').toLowerCase();\nlet reply = '';\n\nif (cmd === '/creator') {\n  reply = [\n    'CREATOR PROFILE',\n    '',\n    'Face URL: ' + (creatorCfg.faceUrl || 'not set'),\n    'Voice ID: ' + (creatorCfg.voiceId || 'not set'),\n    '',\n    'Commands:',\n    '/setface <public_image_url>',\n    '/setvoiceid <elevenlabs_voice_id>',\n    '/creator'\n  ].join('\\n');\n} else if (cmd === '/setface') {\n  const url = raw.replace(/^\\/setface\\s*/i, '').trim();\n  if (!url || !isHttpUrl(url)) {\n    reply = 'Invalid face image URL. Use: /setface https://...';\n  } else {\n    creatorCfg.faceUrl = normalizeGithubRawUrl(url);\n    creatorCfg.updatedAt = Date.now();\n    reply = 'Creator face image saved for future videos.';\n  }\n} else if (cmd === '/setvoiceid') {\n  const voiceId = raw.replace(/^\\/setvoiceid\\s*/i, '').trim();\n  if (!voiceId || /\\s/.test(voiceId) || voiceId.length < 6) {\n    reply = 'Invalid voice ID. Use: /setvoiceid <elevenlabs_voice_id>';\n  } else {\n    creatorCfg.voiceId = voiceId;\n    creatorCfg.updatedAt = Date.now();\n    reply = 'Creator voice ID saved for future videos.';\n  }\n}\n\ncfg.enabled = false;\ncfg.updatedAt = Date.now();\nstaticData.autoScheduleByChat[chatKey] = cfg;\nstaticData.pendingAutoActionByChat[chatKey] = '';\nstaticData.creatorProfileByChat[chatKey] = creatorCfg;\n\nreturn [{\n  json: {\n    ...data,\n    action: { type: 'none', topic: '' },\n    args: '',\n    replyText: reply || 'Creator command updated.',\n    creatorProfile: creatorCfg\n  }\n}];"
      },
      "id": "auto-mode-handler-v1",
      "name": "Handle Auto Mode Commands",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        340,
        340
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{`Image ${$json.slideIndex || 1}/${$json.totalSlides || 1}:\n${$json.imageUrl || \"\"}`}}",
        "additionalFields": {
          "disableWebPagePreview": false
        }
      },
      "id": "send-image-fallback-v1",
      "name": "Send Image URL Fallback",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [
        2080,
        260
      ],
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.imageUrl }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "image/*"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (n8n Telegram Image Fetch)"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "data"
            }
          },
          "timeout": 120000
        }
      },
      "id": "download-carousel-image-binary-v1",
      "name": "Download Carousel Image Binary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1880,
        260
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://queue.fal.run/fal-ai/nano-banana-pro/edit",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Key ' + $('TEST_KEYS').first().json.falKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  prompt: (\n    'Create a photorealistic vertical (9:16) documentary portrait scene of the same person in the reference image. ' +\n    'Keep exact identity, face geometry, skin tone, and hairstyle consistent. ' +\n    'Use topic context: ' + ($json.args || $json.title || 'UK dementia care') + '. ' +\n    'Wardrobe: professional UK founder look (smart suit or blazer or smart shirt), allow subtle variation based on topic, keep consistent within this portrait. ' +\n    'Setting: realistic UK healthcare/community environment. ' +\n    'No text, no logos, no watermark.'\n  ),\n  image_urls: (($json.creatorImageUrls && $json.creatorImageUrls.length) ? $json.creatorImageUrls : [ $json.creatorImageUrl ]),\n  num_images: 1,\n  aspect_ratio: '9:16',\n  output_format: 'png',\n  resolution: '1K',\n  safety_tolerance: '4',\n  limit_generations: true\n}) }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000072",
      "name": "Generate Founder Portrait",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1300,
        400
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2500
    },
    {
      "parameters": {
        "jsCode": "const base = $('Parse Video Response').first().json || {};\nconst out = $input.first().json || {};\n\nfunction looksLikeDirectImageUrl(v) {\n  const u = String(v || '').trim();\n  const lower = u.toLowerCase();\n\n  if (!(lower.startsWith('http://') || lower.startsWith('https://'))) return false;\n  if (lower.includes('queue.fal.run') && lower.includes('/requests/')) return false;\n  if (lower.includes('/status')) return false;\n  if (lower.includes('/cancel')) return false;\n\n  if (lower.includes('fal.media/files/')) return true;\n\n  const bare = lower.split('?')[0].split('#')[0];\n  if (bare.endsWith('.png') || bare.endsWith('.jpg') || bare.endsWith('.jpeg') || bare.endsWith('.webp')) return true;\n\n  return false;\n}\n\nfunction pickGeneratedPortraitUrl(payload) {\n  const urls = [];\n  const seen = new Set();\n\n  function push(v) {\n    const u = String(v || '').trim();\n    if (!u || seen.has(u) || !looksLikeDirectImageUrl(u)) return;\n    seen.add(u);\n    urls.push(u);\n  }\n\n  function walk(node, depth = 0) {\n    if (node == null || depth > 7) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) walk(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      push(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    push(node.image_url);\n    push(node.imageUrl);\n    push(node.url);\n\n    walk(node.images, depth + 1);\n    walk(node.output, depth + 1);\n    walk(node.result, depth + 1);\n    walk(node.data, depth + 1);\n    walk(node.response, depth + 1);\n\n    for (const v of Object.values(node)) {\n      if (v && typeof v === 'object') walk(v, depth + 1);\n    }\n  }\n\n  walk(payload);\n  return urls[0] || '';\n}\n\nconst generatedPortraitUrl = pickGeneratedPortraitUrl(out);\nconst originalCreatorUrl = String(base.creatorImageUrl || '').trim();\n\n// Keep original founder profile image as the identity anchor for clip generation.\nconst clipIdentityImageUrl = generatedPortraitUrl || originalCreatorUrl;\n\nconst founderPortraitSource = generatedPortraitUrl\n  ? (originalCreatorUrl ? 'generated_variant_used' : 'generated_only')\n  : (originalCreatorUrl ? 'fallback_profile' : 'none');\n\nreturn [{\n  json: {\n    ...base,\n    creatorImageUrl: clipIdentityImageUrl,\n    // Preserve the founder portrait pool for downstream scene generation.\n    creatorImageUrls: Array.isArray(out.creatorImageUrls) && out.creatorImageUrls.length\n      ? out.creatorImageUrls\n      : (Array.isArray(base.creatorImageUrls) ? base.creatorImageUrls : []),\n    generatedFounderPortraitUrl: generatedPortraitUrl,\n    founderPortraitSource\n  }\n}];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000073",
      "name": "Resolve Founder Portrait URL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1420,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json || {};\nconst qid = String(data.callbackQueryId || '').trim();\nif (!qid) return [];\nreturn [{ json: { callbackQueryId: qid } }];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000074",
      "name": "Callback Ack Gate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        220
      ]
    },
    {
      "parameters": {
        "resource": "callback",
        "operation": "answerQuery",
        "queryId": "={{ $json.callbackQueryId }}",
        "additionalFields": {
          "text": "Processing your selection..."
        },
        "results": "=[]"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000075",
      "name": "Answer Callback Query",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        0,
        220
      ],
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dignitate-remotion-callback",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000076",
      "name": "Remotion Callback Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -760,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const src = ($json.body && typeof $json.body === 'object') ? $json.body : ($json || {});\nconst chatId = String(src.chatId || '').trim();\nif (!chatId) return [];\n\nconst statusRaw = String(src.status || '').trim();\nconst status = statusRaw ? statusRaw.toLowerCase() : '';\nconst videoUrl = String(src.videoUrl || '').trim();\nconst title = String(src.title || 'Untitled Video').trim();\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingContent) staticData.pendingContent = {};\n\nconst pending = staticData.pendingContent[chatId] && typeof staticData.pendingContent[chatId] === 'object'\n  ? staticData.pendingContent[chatId]\n  : null;\n\nconst pendingCaption = String(pending?.caption || '').trim();\nconst pendingHashtags = Array.isArray(pending?.hashtags) ? pending.hashtags : [];\n\nconst renderOk = status === 'success' && Boolean(videoUrl);\n\n// Persist the final MP4 URL so /approve can use it.\nif (renderOk) {\n  const base = pending && pending.type === 'video'\n    ? { ...pending }\n    : { type: 'video', chatId, title, caption: pendingCaption, hashtags: pendingHashtags, timestamp: Date.now() };\n\n  staticData.pendingContent[chatId] = {\n    ...base,\n    title: base.title || title,\n    finalVideoUrl: videoUrl,\n    videoUrl,\n    renderStatus: 'success',\n    renderedAt: Date.now(),\n  };\n}\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction uniqHashtags(list) {\n  const out = [];\n  const seen = new Set();\n  for (const raw of (Array.isArray(list) ? list : [])) {\n    let h = clean(raw);\n    if (!h) continue;\n    if (!h.startsWith('#')) h = '#' + h;\n    const key = h.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push(h);\n  }\n  return out;\n}\n\nconst hashtags = uniqHashtags(pendingHashtags).slice(0, 12);\n\nlet approvalCaption = '';\nif (renderOk) {\n  const parts = [\n    'VIDEO READY FOR REVIEW',\n    '',\n    'Title: ' + (pending?.title || title),\n  ];\n\n  if (pendingCaption) {\n    parts.push('', 'Draft caption:', pendingCaption);\n  }\n\n  if (hashtags.length) {\n    parts.push('', 'Hashtags: ' + hashtags.join(' '));\n  }\n\n  parts.push('', 'Tap a button below: Approve to post, or Regenerate for a new version.');\n\n  // Telegram video caption max is ~1024 chars.\n  const joined = parts.join('\\n');\n  approvalCaption = joined.length > 1000 ? (joined.slice(0, 997).trim() + '...') : joined;\n}\n\nlet text = '';\nif (renderOk) {\n  text = ['Video render complete.', '', 'Title: ' + (pending?.title || title), '', videoUrl].join('\\n');\n}\n\nif (!renderOk) {\n  const err = String(src.error || 'Unknown render error').slice(0, 700);\n  text = ['Video render failed.', '', 'Title: ' + title, 'Error: ' + err].join('\\n');\n}\n\nreturn [{\n  json: {\n    chatId,\n    title,\n    status: renderOk ? 'success' : (status || 'error'),\n    videoUrl,\n    renderOk,\n    approvalCaption,\n    text,\n  }\n}];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000077",
      "name": "Normalize Render Callback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -520,
        120
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ String($json.renderOk) }}",
                    "rightValue": "true",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Success"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000079",
      "name": "Render Callback Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -360,
        120
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.videoUrl }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "video/*"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (n8n Telegram Video Fetch)"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "data"
            }
          },
          "timeout": 240000
        }
      },
      "id": "download-rendered-video-binary-v1",
      "name": "Download Rendered Video Binary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -200,
        120
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "sendVideo",
        "chatId": "={{ $json.chatId }}",
        "binaryData": true,
        "replyMarkup": "inlineKeyboard",
        "inlineKeyboard": {
          "rows": [
            {
              "row": {
                "buttons": [
                  {
                    "text": "Approve",
                    "additionalFields": {
                      "callback_data": "/approve"
                    }
                  },
                  {
                    "text": "Regenerate",
                    "additionalFields": {
                      "callback_data": "/regenerate"
                    }
                  }
                ]
              }
            }
          ]
        },
        "additionalFields": {
          "caption": "={{ $json.approvalCaption }}"
        },
        "binaryPropertyName": "data"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000080",
      "name": "Send Rendered Video To Telegram",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [
        -120,
        120
      ],
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000078",
      "name": "Send Render Callback To Telegram",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [
        -280,
        120
      ],
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "function clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction uniqHashtags(list) {\n  const out = [];\n  const seen = new Set();\n  for (const raw of (Array.isArray(list) ? list : [])) {\n    let h = clean(raw);\n    if (!h) continue;\n    if (!h.startsWith('#')) h = '#' + h;\n    const k = h.toLowerCase();\n    if (seen.has(k)) continue;\n    seen.add(k);\n    out.push(h);\n  }\n  return out;\n}\n\nconst j = $input.first().json || {};\nif (j.error) return [{ json: j }];\n\nconst chatId = j.chatId;\nconst title = clean(j.title || j.args || 'Dignitate Video');\nconst caption = clean(j.caption || 'Research-backed guidance for carers with clear next steps.');\nconst hashtags = uniqHashtags(j.hashtags || []).slice(0, 12);\n\nconst videoUrl = clean(j.finalVideoUrl || j.videoUrl || '');\nif (!videoUrl) {\n  return [{\n    json: {\n      chatId,\n      error: true,\n      message: 'Video is not rendered yet (no MP4 URL found). Please wait for the render to finish, then approve again.'\n    }\n  }];\n}\n\nconst igCaption = [title, caption, hashtags.join(' ')].filter(Boolean).join('\\n\\n').slice(0, 2100);\n\nconst ytTitleBase = title.length > 90 ? title.slice(0, 87).trim() + '...' : title;\nconst ytTitle = (ytTitleBase + ' #Shorts').slice(0, 100);\nconst ytDescription = [caption, '', hashtags.join(' '), '#Shorts'].filter(Boolean).join('\\n').slice(0, 4500);\n\nconst ttCaption = (caption + (hashtags.length ? (' ' + hashtags.slice(0, 8).join(' ')) : '')).slice(0, 2000);\n\n// Composio v2 requires UUID connectedAccountIds for TikTok/YouTube (not the ac_ ids used in v1).\nconst uuidRe = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n// If you only have Composio Auth Config IDs (ac_...), use entityId mode.\nconst rawTikTokId = '';\nconst rawYouTubeId = 'ac_45guMz9S841I';\n\nconst tiktokConnectedAccountUuid = uuidRe.test(rawTikTokId) ? rawTikTokId : '';\nconst youtubeConnectedAccountUuid = uuidRe.test(rawYouTubeId) ? rawYouTubeId : '';\n\nconst tiktokEntityId = (!tiktokConnectedAccountUuid && rawTikTokId) ? rawTikTokId : '';\nconst youtubeEntityId = (!youtubeConnectedAccountUuid && rawYouTubeId) ? rawYouTubeId : '';\n\nreturn [{\n  json: {\n    ...j,\n    type: 'video',\n    chatId,\n    title,\n    caption,\n    hashtags,\n    videoUrl,\n    instagramCaption: igCaption,\n    youtubeTitle: ytTitle,\n    youtubeDescription: ytDescription,\n    tiktokCaption: ttCaption,\n\n    // Prefer connectedAccount UUIDs; otherwise fall back to entityId mode.\n    tiktokConnectedAccountUuid,\n    youtubeConnectedAccountUuid,\n    tiktokEntityId,\n    youtubeEntityId,\n\n    connectedAccountValidation: {\n      rawTikTokId,\n      rawYouTubeId,\n      tiktokValidUuid: Boolean(tiktokConnectedAccountUuid),\n      youtubeValidUuid: Boolean(youtubeConnectedAccountUuid),\n      tiktokHasEntityId: Boolean(tiktokEntityId),\n      youtubeHasEntityId: Boolean(youtubeEntityId)\n    }\n  }\n}];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000081",
      "name": "Prepare Video Post Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        -80
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ String($json.error) }}",
                    "rightValue": "true",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Error"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000087",
      "name": "Video Post Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        860,
        -80
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{`Posting approved video now...\\n\\nInstagram Reels: starting\\nTikTok: starting\\nYouTube Shorts: starting`}}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000082",
      "name": "Video Posting Started",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "position": [
        940,
        -80
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v1/actions/INSTAGRAM_CREATE_MEDIA_CONTAINER/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ connectedAccountId: 'ac_KNBQIWjdvioh', input: { caption: $json.instagramCaption || '', video_url: $json.videoUrl, media_url: $json.videoUrl, is_carousel: false, media_type: 'REELS' } }) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000083",
      "name": "Composio - Instagram Reels",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1180,
        -80
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v2/actions/TIKTOK_PUBLISH_VIDEO/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify(($json.tiktokConnectedAccountUuid ? { connectedAccountId: $json.tiktokConnectedAccountUuid, text: `Publish this MP4 as a TikTok video. Video URL: ${$json.videoUrl}. Caption: ${$json.tiktokCaption}.` } : ($json.tiktokEntityId ? { appName: 'tiktok', entityId: $json.tiktokEntityId, text: `Publish this MP4 as a TikTok video. Video URL: ${$json.videoUrl}. Caption: ${$json.tiktokCaption}.` } : { text: 'Missing connected account configuration for tiktok' }))) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000084",
      "name": "Composio - TikTok",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1420,
        -80
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": false,
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v2/actions/YOUTUBE_UPLOAD_VIDEO/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify(($json.youtubeConnectedAccountUuid ? { connectedAccountId: $json.youtubeConnectedAccountUuid, text: `Upload this MP4 to YouTube as a Short. Video URL: ${$json.videoUrl}. Title: ${$json.youtubeTitle}. Description: ${$json.youtubeDescription}.` } : ($json.youtubeEntityId ? { appName: 'youtube', entityId: $json.youtubeEntityId, text: `Upload this MP4 to YouTube as a Short. Video URL: ${$json.videoUrl}. Title: ${$json.youtubeTitle}. Description: ${$json.youtubeDescription}.` } : { text: 'Missing connected account configuration for youtube' }))) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000085",
      "name": "Composio - YouTube Shorts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1660,
        -80
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": false,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const base = $('Prepare Video Post Data').first().json || {};\nconst chatId = base.chatId;\n\nfunction statusFrom(nodeName) {\n  try {\n    const j = $(nodeName).first().json || {};\n    if (j.error) return { status: 'Failed', detail: String(j.error?.message || j.message || j.error || '').slice(0, 200) };\n    if (j.successful === false || j.successfull === false) return { status: 'Failed', detail: String(j.message || '').slice(0, 200) };\n    if (j.status && Number(j.status) >= 400) return { status: 'Failed', detail: String(j.message || '').slice(0, 200) };\n    return { status: 'Posted', detail: '' };\n  } catch (e) {\n    return { status: 'Skipped', detail: 'Not configured or not executed.' };\n  }\n}\n\nconst val = base.connectedAccountValidation || {};\nconst ttNote = (!val.tiktokValidUuid && val.rawTikTokId && val.rawTikTokId.startsWith('ac_'))\n  ? ' (using entityId mode with ac_...; if this fails, Composio may require a UUID connected account id)'\n  : (!val.tiktokValidUuid && val.rawTikTokId ? ' (invalid TikTok id)' : '');\nconst ytNote = (!val.youtubeValidUuid && val.rawYouTubeId && val.rawYouTubeId.startsWith('ac_'))\n  ? ' (using entityId mode with ac_...; if this fails, Composio may require a UUID connected account id)'\n  : (!val.youtubeValidUuid && val.rawYouTubeId ? ' (invalid YouTube id)' : '');\n\nconst ig = statusFrom('Composio - Instagram Reels');\nconst tt = (base.tiktokConnectedAccountUuid || base.tiktokEntityId)\n  ? statusFrom('Composio - TikTok')\n  : { status: 'Skipped', detail: 'TikTok account not set' };\nconst yt = (base.youtubeConnectedAccountUuid || base.youtubeEntityId)\n  ? statusFrom('Composio - YouTube Shorts')\n  : { status: 'Skipped', detail: 'YouTube account not set' };\n\nconst lines = [\n  'VIDEO POST RESULTS',\n  '',\n  `Instagram Reels: ${ig.status}${ig.detail ? ` (${ig.detail})` : ''}`,\n  `TikTok: ${tt.status}${ttNote}${tt.detail ? ` (${tt.detail})` : ''}`,\n  `YouTube Shorts: ${yt.status}${ytNote}${yt.detail ? ` (${yt.detail})` : ''}`,\n  '',\n  `Title: ${base.title || ''}`,\n  base.videoUrl ? `MP4: ${base.videoUrl}` : ''\n].filter(Boolean);\n\nreturn [{ json: { chatId, message: lines.join('\\n') } }];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000086",
      "name": "Check Video Post Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1900,
        -80
      ],
      "onError": "continueErrorOutput"
    },
    {
      "id": "3dfc9d09-e1b7-493b-9ec7-7d4f69ea1682",
      "name": "Lookup YouTube Connected Account",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        940,
        -200
      ],
      "continueOnFail": true,
      "parameters": {
        "method": "GET",
        "url": "={{ \"https://backend.composio.dev/api/v3/connected_accounts?toolkit_slugs=youtube&auth_config_ids=\" + encodeURIComponent(String($json.connectedAccountValidation?.rawYouTubeId || $json.connectedAccountValidation?.rawYouTubeId || \"\").trim()) + \"&limit=5\" }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "ak_p_o5n04j9WB8LmAwoRfx"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "options": {
          "response": {
            "responseFormat": "json"
          }
        }
      }
    },
    {
      "id": "acb2add1-5cc1-4745-b5db-e8976acc2dd6",
      "name": "Apply YouTube Connected Account",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        -200
      ],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const base = $('Prepare Video Post Data').first().json || {};\nconst resp = $input.first().json;\n\n// Response shapes: {items:[...]} or {data:[...]} or [...].\nlet items = [];\nif (Array.isArray(resp)) items = resp;\nelse if (Array.isArray(resp?.items)) items = resp.items;\nelse if (Array.isArray(resp?.data)) items = resp.data;\nelse if (Array.isArray(resp?.connected_accounts)) items = resp.connected_accounts;\n\nconst uuidRe = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nlet found = '';\nfor (const it of items) {\n  const id = String(it?.id || it?.connectedAccountId || it?.connected_account_id || '').trim();\n  if (uuidRe.test(id)) { found = id; break; }\n}\n\n// If v3 returns nothing, keep whatever we already had.\nconst merged = { ...base };\nif (found && !merged.youtubeConnectedAccountUuid) {\n  merged.youtubeConnectedAccountUuid = found;\n}\n\nreturn [{ json: merged }];\n"
      }
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst apiKey = String($('TEST_KEYS').first().json.falKey || '').trim();\nconst modelPath = 'fal-ai/nano-banana-pro';\nconst headers = { Authorization: 'Key ' + apiKey };\n\nconst pollIntervalMs = 2000;\nconst maxChecks = 220;\nconst maxWaitMs = 600000;\nconst resultRetryCount = 8;\nconst transientCodes = new Set([404, 409, 422, 425, 429]);\n\nconst httpRequest =\n  (typeof $httpRequest === 'function' && $httpRequest) ||\n  (this && this.helpers && typeof this.helpers.httpRequest === 'function'\n    ? this.helpers.httpRequest.bind(this)\n    : null);\n\nif (!httpRequest) {\n  throw new Error('n8n HTTP helper is unavailable in this Code node runtime.');\n}\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nfunction getStatusCode(err) {\n  const candidates = [\n    err?.statusCode,\n    err?.status,\n    err?.httpCode,\n    err?.response?.statusCode,\n    err?.response?.status\n  ];\n  for (const c of candidates) {\n    const n = Number(c);\n    if (Number.isFinite(n)) return n;\n  }\n\n  const msg = String(err?.message || '');\n  const m = msg.match(/status\\s*code\\s*(\\d{3})/i) || msg.match(/\\b(\\d{3})\\b/);\n  if (m?.[1]) {\n    const n = Number(m[1]);\n    if (Number.isFinite(n)) return n;\n  }\n  return null;\n}\n\nfunction safeJson(v, maxLen = 500) {\n  try {\n    const s = JSON.stringify(v);\n    if (!s) return '';\n    return s.length > maxLen ? s.slice(0, maxLen) + '...' : s;\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction errText(err) {\n  const base = String(err?.message || err || 'unknown error');\n  const status = getStatusCode(err);\n  const body = safeJson(err?.response?.body || err?.body || err?.data || null);\n  return base + (status ? (' [status ' + status + ']') : '') + (body ? (' body=' + body) : '');\n}\n\nfunction readStatus(json) {\n  // Do not use nested result.status here; it can report completed before assets are fetchable.\n  return String(\n    (json &&\n      (json.status ||\n        json.request_status ||\n        json.state ||\n        json.phase ||\n        (json.data && json.data.status))) ||\n      ''\n  ).toUpperCase();\n}\n\nfunction readQueuePos(json) {\n  const v = json?.queue_position ?? json?.data?.queue_position ?? null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction normalizeImages(payload) {\n  const out = [];\n  const seen = new Set();\n\n  function pushUrl(v) {\n    const u = String(v || '').trim();\n    if (!u || !/^https?:\\/\\//i.test(u) || seen.has(u)) return;\n    seen.add(u);\n    out.push({ url: u });\n  }\n\n  function consume(node, depth = 0) {\n    if (!node || depth > 6) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) consume(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      pushUrl(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    if (typeof node.url === 'string') pushUrl(node.url);\n    if (typeof node.image_url === 'string') pushUrl(node.image_url);\n    if (typeof node.imageUrl === 'string') pushUrl(node.imageUrl);\n\n    if (Array.isArray(node.images)) consume(node.images, depth + 1);\n    if (Array.isArray(node.outputs)) consume(node.outputs, depth + 1);\n    if (Array.isArray(node.output)) consume(node.output, depth + 1);\n\n    if (node.data) consume(node.data, depth + 1);\n    if (node.result) consume(node.result, depth + 1);\n    if (node.response) consume(node.response, depth + 1);\n    if (node.image) consume(node.image, depth + 1);\n  }\n\n  consume(payload);\n  return out;\n}\n\nfunction buildFallbackStatusUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId) + '/status';\n}\n\nfunction buildFallbackResultUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId);\n}\n\nasync function getStatusByUrl(statusUrl, requestId) {\n  const url = statusUrl || buildFallbackStatusUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function getResultByUrl(responseUrl, requestId) {\n  const url = responseUrl || buildFallbackResultUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function waitForOne(item) {\n  const inputJson = item.json || {};\n  const requestId = inputJson.request_id || inputJson.requestId;\n  const statusUrl = String(inputJson.status_url || inputJson.statusUrl || '').trim();\n  const responseUrl = String(inputJson.response_url || inputJson.responseUrl || '').trim();\n\n  const syncImages = normalizeImages(inputJson);\n  if (syncImages.length) {\n    return { json: { ...inputJson, images: syncImages, falStatus: 'COMPLETED_SYNC', falPollAttempts: 0 } };\n  }\n\n  if (!requestId && !statusUrl && !responseUrl) {\n    throw new Error('fal.ai submit did not return request_id/status_url/response_url.');\n  }\n\n  const startedAt = Date.now();\n  let attempts = 0;\n  let statusValue = '';\n  let lastQueuePosition = null;\n\n  while (attempts < maxChecks && (Date.now() - startedAt) < maxWaitMs) {\n    attempts++;\n\n    let statusJson;\n    try {\n      statusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(statusJson);\n      lastQueuePosition = readQueuePos(statusJson);\n    } catch (err) {\n      const code = getStatusCode(err);\n      if (transientCodes.has(code)) {\n        statusValue = statusValue || 'IN_QUEUE';\n      } else {\n        throw new Error('fal.ai status request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n      }\n    }\n\n    if (statusValue === 'COMPLETED') break;\n    if (['FAILED', 'ERROR', 'CANCELLED'].includes(statusValue)) {\n      throw new Error('fal.ai request ' + (requestId || 'unknown') + ' failed with status ' + statusValue + '.');\n    }\n\n    const elapsed = Date.now() - startedAt;\n    const remaining = maxWaitMs - elapsed;\n    if (remaining <= 0) break;\n    await sleep(Math.min(pollIntervalMs, remaining));\n  }\n\n  if (statusValue !== 'COMPLETED') {\n    try {\n      const finalStatusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(finalStatusJson) || statusValue;\n      lastQueuePosition = readQueuePos(finalStatusJson) ?? lastQueuePosition;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  let resultJson = null;\n  const tryGetResult = async () => {\n    for (let i = 0; i < resultRetryCount; i++) {\n      try {\n        const res = await getResultByUrl(responseUrl, requestId || '');\n        if (res && typeof res === 'object') return res;\n      } catch (err) {\n        const code = getStatusCode(err);\n        if (!transientCodes.has(code)) {\n          throw new Error('fal.ai result request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n        }\n      }\n      await sleep(Math.min(1200 + i * 300, 3000));\n    }\n    return null;\n  };\n\n  if (statusValue === 'COMPLETED') {\n    resultJson = await tryGetResult();\n  } else {\n    try {\n      const possible = await tryGetResult();\n      const hasImages = normalizeImages(possible).length > 0;\n      if (hasImages) {\n        resultJson = possible;\n        statusValue = 'COMPLETED_LATE';\n      }\n    } catch (e) {\n      // no-op\n    }\n  }\n\n  if (!resultJson || typeof resultJson !== 'object') {\n    const seconds = Math.max(1, Math.round((Date.now() - startedAt) / 1000));\n    // Do not fail the whole workflow if the portrait result isn't ready yet.\n    // Downstream will fall back to the original creator profile image.\n    return {\n      json: {\n        ...inputJson,\n        request_id: requestId || inputJson.request_id || '',\n        images: [],\n        falStatus: 'TIMEOUT',\n        falPollAttempts: attempts,\n        falError:\n          'fal.ai founder portrait request ' + (requestId || 'unknown') +\n          ' not ready after ' + attempts + ' checks (~' + seconds + 's), status=' + (statusValue || 'IN_QUEUE') +\n          ', queue_position=' + (lastQueuePosition == null ? 'n/a' : lastQueuePosition) +\n          '. Using fallback profile image.'\n      }\n    };\n  }\n\n  const normalized = normalizeImages(resultJson);\n  const merged = {\n    ...inputJson,\n    ...resultJson,\n    images: normalized,\n    request_id: requestId || inputJson.request_id || '',\n    falStatus: statusValue || 'COMPLETED',\n    falPollAttempts: attempts,\n  };\n\n  if (!normalized.length) {\n    merged.falError = 'fal.ai completed but returned no image URLs in supported fields.';\n  }\n\n  return { json: merged };\n}\n\nconst out = [];\nlet lastError = null;\n\nfor (const item of items) {\n  try {\n    out.push(await waitForOne(item));\n  } catch (err) {\n    lastError = err;\n    out.push({\n      json: {\n        ...(item.json || {}),\n        falStatus: 'ERROR',\n        falError: String(err.message || err),\n        images: []\n      }\n    });\n  }\n}\n\nconst anyImages = out.some((o) => {\n  const j = o.json || {};\n  return Array.isArray(j.images) && j.images.length > 0;\n});\n\n// If the founder portrait failed, keep going; downstream will use the original creator image.\nreturn out;",
        "mode": "runOnceForAllItems",
        "language": "javaScript"
      },
      "id": "8c9f08ec-92b0-4bc8-a746-1bcdc935fbd7",
      "name": "fal.ai - Await Founder Portrait Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1540,
        520
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://queue.fal.run/fal-ai/nano-banana-pro/edit",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Key ' + $('TEST_KEYS').first().json.falKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  prompt: $json.sceneImagePrompt || $json.videoPrompt || $json.visualPrompt || 'Photorealistic UK healthcare scene, vertical 9:16',\n  image_urls: (($json.creatorImageUrls && $json.creatorImageUrls.length) ? $json.creatorImageUrls : [ $json.creatorImageUrl ]),\n  num_images: 1,\n  aspect_ratio: '9:16',\n  output_format: 'png',\n  resolution: '1K',\n  safety_tolerance: '4',\n  limit_generations: true\n}) }}",
        "options": {
          "timeout": 240000
        }
      },
      "id": "generate-scene-image-v1",
      "name": "fal.ai - Generate Scene Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1500,
        400
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2500
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst apiKey = String($('TEST_KEYS').first().json.falKey || '').trim();\nconst modelPath = 'fal-ai/nano-banana-pro';\nconst headers = { Authorization: 'Key ' + apiKey };\n\nconst pollIntervalMs = 2000;\nconst maxChecks = 220;\nconst maxWaitMs = 600000;\nconst resultRetryCount = 8;\nconst transientCodes = new Set([404, 409, 422, 425, 429]);\n\nconst httpRequest =\n  (typeof $httpRequest === 'function' && $httpRequest) ||\n  (this && this.helpers && typeof this.helpers.httpRequest === 'function'\n    ? this.helpers.httpRequest.bind(this)\n    : null);\n\nif (!httpRequest) {\n  throw new Error('n8n HTTP helper is unavailable in this Code node runtime.');\n}\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nfunction getStatusCode(err) {\n  const candidates = [\n    err?.statusCode,\n    err?.status,\n    err?.httpCode,\n    err?.response?.statusCode,\n    err?.response?.status\n  ];\n  for (const c of candidates) {\n    const n = Number(c);\n    if (Number.isFinite(n)) return n;\n  }\n\n  const msg = String(err?.message || '');\n  const m = msg.match(/status\\s*code\\s*(\\d{3})/i) || msg.match(/\\b(\\d{3})\\b/);\n  if (m?.[1]) {\n    const n = Number(m[1]);\n    if (Number.isFinite(n)) return n;\n  }\n  return null;\n}\n\nfunction safeJson(v, maxLen = 500) {\n  try {\n    const s = JSON.stringify(v);\n    if (!s) return '';\n    return s.length > maxLen ? s.slice(0, maxLen) + '...' : s;\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction errText(err) {\n  const base = String(err?.message || err || 'unknown error');\n  const status = getStatusCode(err);\n  const body = safeJson(err?.response?.body || err?.body || err?.data || null);\n  return base + (status ? (' [status ' + status + ']') : '') + (body ? (' body=' + body) : '');\n}\n\nfunction readStatus(json) {\n  // Do not use nested result.status here; it can report completed before assets are fetchable.\n  return String(\n    (json &&\n      (json.status ||\n        json.request_status ||\n        json.state ||\n        json.phase ||\n        (json.data && json.data.status))) ||\n      ''\n  ).toUpperCase();\n}\n\nfunction readQueuePos(json) {\n  const v = json?.queue_position ?? json?.data?.queue_position ?? null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction normalizeImages(payload) {\n  const out = [];\n  const seen = new Set();\n\n  function pushUrl(v) {\n    const u = String(v || '').trim();\n    if (!u || !/^https?:\\/\\//i.test(u) || seen.has(u)) return;\n    seen.add(u);\n    out.push({ url: u });\n  }\n\n  function consume(node, depth = 0) {\n    if (!node || depth > 6) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) consume(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      pushUrl(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    if (typeof node.url === 'string') pushUrl(node.url);\n    if (typeof node.image_url === 'string') pushUrl(node.image_url);\n    if (typeof node.imageUrl === 'string') pushUrl(node.imageUrl);\n\n    if (Array.isArray(node.images)) consume(node.images, depth + 1);\n    if (Array.isArray(node.outputs)) consume(node.outputs, depth + 1);\n    if (Array.isArray(node.output)) consume(node.output, depth + 1);\n\n    if (node.data) consume(node.data, depth + 1);\n    if (node.result) consume(node.result, depth + 1);\n    if (node.response) consume(node.response, depth + 1);\n    if (node.image) consume(node.image, depth + 1);\n  }\n\n  consume(payload);\n  return out;\n}\n\nfunction buildFallbackStatusUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId) + '/status';\n}\n\nfunction buildFallbackResultUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId);\n}\n\nasync function getStatusByUrl(statusUrl, requestId) {\n  const url = statusUrl || buildFallbackStatusUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function getResultByUrl(responseUrl, requestId) {\n  const url = responseUrl || buildFallbackResultUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function waitForOne(item) {\n  const inputJson = item.json || {};\n  const requestId = inputJson.request_id || inputJson.requestId;\n  const statusUrl = String(inputJson.status_url || inputJson.statusUrl || '').trim();\n  const responseUrl = String(inputJson.response_url || inputJson.responseUrl || '').trim();\n\n  const syncImages = normalizeImages(inputJson);\n  if (syncImages.length) {\n    return { json: { ...inputJson, images: syncImages, falStatus: 'COMPLETED_SYNC', falPollAttempts: 0 } };\n  }\n\n  if (!requestId && !statusUrl && !responseUrl) {\n    throw new Error('fal.ai submit did not return request_id/status_url/response_url.');\n  }\n\n  const startedAt = Date.now();\n  let attempts = 0;\n  let statusValue = '';\n  let lastQueuePosition = null;\n\n  while (attempts < maxChecks && (Date.now() - startedAt) < maxWaitMs) {\n    attempts++;\n\n    let statusJson;\n    try {\n      statusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(statusJson);\n      lastQueuePosition = readQueuePos(statusJson);\n    } catch (err) {\n      const code = getStatusCode(err);\n      if (transientCodes.has(code)) {\n        statusValue = statusValue || 'IN_QUEUE';\n      } else {\n        throw new Error('fal.ai status request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n      }\n    }\n\n    if (statusValue === 'COMPLETED') break;\n    if (['FAILED', 'ERROR', 'CANCELLED'].includes(statusValue)) {\n      throw new Error('fal.ai request ' + (requestId || 'unknown') + ' failed with status ' + statusValue + '.');\n    }\n\n    const elapsed = Date.now() - startedAt;\n    const remaining = maxWaitMs - elapsed;\n    if (remaining <= 0) break;\n    await sleep(Math.min(pollIntervalMs, remaining));\n  }\n\n  if (statusValue !== 'COMPLETED') {\n    try {\n      const finalStatusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(finalStatusJson) || statusValue;\n      lastQueuePosition = readQueuePos(finalStatusJson) ?? lastQueuePosition;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  let resultJson = null;\n  const tryGetResult = async () => {\n    for (let i = 0; i < resultRetryCount; i++) {\n      try {\n        const res = await getResultByUrl(responseUrl, requestId || '');\n        if (res && typeof res === 'object') return res;\n      } catch (err) {\n        const code = getStatusCode(err);\n        if (!transientCodes.has(code)) {\n          throw new Error('fal.ai result request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n        }\n      }\n      await sleep(Math.min(1200 + i * 300, 3000));\n    }\n    return null;\n  };\n\n  if (statusValue === 'COMPLETED') {\n    resultJson = await tryGetResult();\n  } else {\n    try {\n      const possible = await tryGetResult();\n      const hasImages = normalizeImages(possible).length > 0;\n      if (hasImages) {\n        resultJson = possible;\n        statusValue = 'COMPLETED_LATE';\n      }\n    } catch (e) {\n      // no-op\n    }\n  }\n\n  if (!resultJson || typeof resultJson !== 'object') {\n    const seconds = Math.max(1, Math.round((Date.now() - startedAt) / 1000));\n    // Do not fail the whole workflow if the portrait result isn't ready yet.\n    // Downstream will fall back to the original creator profile image.\n    return {\n      json: {\n        ...inputJson,\n        request_id: requestId || inputJson.request_id || '',\n        images: [],\n        falStatus: 'TIMEOUT',\n        falPollAttempts: attempts,\n        falError:\n          'fal.ai scene image request ' + (requestId || 'unknown') +\n          ' not ready after ' + attempts + ' checks (~' + seconds + 's), status=' + (statusValue || 'IN_QUEUE') +\n          ', queue_position=' + (lastQueuePosition == null ? 'n/a' : lastQueuePosition) +\n          '. Using fallback profile image.'\n      }\n    };\n  }\n\n  const normalized = normalizeImages(resultJson);\n  const merged = {\n    ...inputJson,\n    ...resultJson,\n    images: normalized,\n    request_id: requestId || inputJson.request_id || '',\n    falStatus: statusValue || 'COMPLETED',\n    falPollAttempts: attempts,\n  };\n\n  if (!normalized.length) {\n    merged.falError = 'fal.ai completed but returned no image URLs in supported fields.';\n  }\n\n  return { json: merged };\n}\n\nconst out = [];\nlet lastError = null;\n\nfor (const item of items) {\n  try {\n    out.push(await waitForOne(item));\n  } catch (err) {\n    lastError = err;\n    out.push({\n      json: {\n        ...(item.json || {}),\n        falStatus: 'ERROR',\n        falError: String(err.message || err),\n        images: []\n      }\n    });\n  }\n}\n\nconst anyImages = out.some((o) => {\n  const j = o.json || {};\n  return Array.isArray(j.images) && j.images.length > 0;\n});\n\n// If the scene image failed, keep going; downstream will use the original creator image.\nreturn out;"
      },
      "id": "await-scene-image-result-v1",
      "name": "fal.ai - Await Scene Image Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1560,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first().json || {};\n\nfunction looksLikeDirectImageUrl(v) {\n  const u = String(v || '').trim();\n  const lower = u.toLowerCase();\n\n  if (!(lower.startsWith('http://') || lower.startsWith('https://'))) return false;\n  if (lower.includes('queue.fal.run') && lower.includes('/requests/')) return false;\n  if (lower.includes('/status')) return false;\n  if (lower.includes('/cancel')) return false;\n\n  const bare = lower.split('?')[0].split('#')[0];\n  if (bare.endsWith('.png') || bare.endsWith('.jpg') || bare.endsWith('.jpeg') || bare.endsWith('.webp')) return true;\n  if (lower.includes('fal.media/files/')) return true;\n  if (lower.includes('fal.media/')) return true;\n\n  return false;\n}\n\nfunction pickUrl(payload) {\n  const urls = [];\n  const seen = new Set();\n\n  function push(v) {\n    const u = String(v || '').trim();\n    if (!u || seen.has(u) || !looksLikeDirectImageUrl(u)) return;\n    seen.add(u);\n    urls.push(u);\n  }\n\n  function walk(node, depth = 0) {\n    if (node == null || depth > 7) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) walk(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      push(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    push(node.url);\n    push(node.image_url);\n    push(node.imageUrl);\n\n    walk(node.images, depth + 1);\n    walk(node.output, depth + 1);\n    walk(node.outputs, depth + 1);\n    walk(node.result, depth + 1);\n    walk(node.data, depth + 1);\n    walk(node.response, depth + 1);\n\n    for (const v of Object.values(node)) {\n      if (v && typeof v === 'object') walk(v, depth + 1);\n    }\n  }\n\n  walk(payload);\n  return urls[0] || '';\n}\n\nconst sceneImageUrl = pickUrl(item);\n\nreturn [{\n  json: {\n    ...item,\n    sceneImageUrl: sceneImageUrl || String(item.creatorImageUrl || '').trim(),\n    sceneImageSource: sceneImageUrl ? 'generated_scene_image' : 'fallback_creator_image'\n  }\n}];\n"
      },
      "id": "resolve-scene-image-url-v1",
      "name": "Resolve Scene Image URL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1620,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "id": "c9c7aa3b-538c-4f1a-821a-f1fd2a652639",
      "name": "Restore Payload After Voiceover",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        280
      ],
      "parameters": {
        "jsCode": "// ElevenLabs HTTP Request (responseFormat=file) can drop upstream JSON fields.\n// Reattach the real video payload so downstream nodes always have creatorImageUrl(s), args, title, etc.\nconst base = $('Restore Video Payload').first().json || {};\nconst current = $input.first();\n\nreturn [{\n  json: {\n    ...base,\n    ...(current?.json || {})\n  },\n  binary: current?.binary\n}];\n"
      }
    },
    {
      "parameters": {
        "keepOnlySet": false,
        "values": {
          "string": [
            {
              "name": "openrouterKey",
              "value": ""
            },
            {
              "name": "falKey",
              "value": ""
            },
            {
              "name": "elevenLabsKey",
              "value": ""
            },
            {
              "name": "githubPat",
              "value": ""
            },
            {
              "name": "composioKey",
              "value": ""
            }
          ]
        },
        "options": {}
      },
      "id": "acb0ee18-41ad-4208-a791-874b512f31be",
      "name": "TEST_KEYS",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        -428,
        400
      ]
    },
    {
      "id": "5298bbcd-ca15-42c2-94ba-7b355b1f4d10",
      "name": "Skip Reply For Mode Choose",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        520,
        260
      ],
      "parameters": {
        "jsCode": "const d = $input.first().json || {};\nif (String(d.action?.type || '') === 'choose_video') return [];\nreturn [{ json: d }];\n"
      }
    },
    {
      "id": "ae500148-3591-466b-88b3-89f0c2752188",
      "name": "Video - Choose Mode",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [
        940,
        430
      ],
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ \"Choose video style\" + ($json.args ? (\" for:\\n\" + $json.args) : \"\") }}",
        "replyMarkup": "inlineKeyboard",
        "inlineKeyboard": {
          "rows": [
            {
              "row": {
                "buttons": [
                  {
                    "text": "Talking head",
                    "additionalFields": {
                      "callback_data": "/video_talking"
                    }
                  },
                  {
                    "text": "Kling multi-clip",
                    "additionalFields": {
                      "callback_data": "/video_kling"
                    }
                  }
                ]
              }
            }
          ]
        },
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId || $('Ensure Action Intent').first().json.chatId || $('Quick Parse Slash').first().json.chatId || $('Load Chat History').first().json.chatId }}",
        "text": "Trend generation is temporarily busy on n8n Cloud (task runner capacity). Please try again in about 30-60 seconds.",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "c3de8c79-b2ec-4bda-bbf0-2f4e7e66c8f1",
      "name": "Trends Task Runner Fallback",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000081",
      "position": [
        1080,
        840
      ]
    }
  ],
  "connections": {
    "Telegram Trigger": {
      "main": [
        [
          {
            "node": "TEST_KEYS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Chat History": {
      "main": [
        [
          {
            "node": "Callback Ack Gate",
            "type": "main",
            "index": 0
          },
          {
            "node": "Is Slash Command?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Slash Command?": {
      "main": [
        [
          {
            "node": "Quick Parse Slash",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Quick Parse Slash": {
      "main": [
        [
          {
            "node": "Handle Auto Mode Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Conversation": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Quick Parse Slash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response": {
      "main": [
        [
          {
            "node": "Ensure Action Intent",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send AI Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Action Router": {
      "main": [
        [
          {
            "node": "Prepare Carousel Args",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Video Args",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Carousel Args",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Video Args",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OpenRouter - Trends",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Approval",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Regeneration",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Status Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Help Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Video - Choose Mode",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Prepare Carousel Args": {
      "main": [
        [
          {
            "node": "Research for Carousel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Research for Carousel": {
      "main": [
        [
          {
            "node": "Parse Carousel Research",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Carousel Research": {
      "main": [
        [
          {
            "node": "OpenRouter - Carousel Script",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Video Args": {
      "main": [
        [
          {
            "node": "Research for Video",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Research for Video": {
      "main": [
        [
          {
            "node": "Parse Video Research",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Video Research": {
      "main": [
        [
          {
            "node": "OpenRouter - Video Script",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Scheduled Trends Prep",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scheduled Trends Prep": {
      "main": [
        [
          {
            "node": "Action Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter - Carousel Script": {
      "main": [
        [
          {
            "node": "Parse Carousel Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter - Video Script": {
      "main": [
        [
          {
            "node": "Parse Video Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter - Trends": {
      "main": [
        [
          {
            "node": "Parse Trends Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse Trends Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Carousel Response": {
      "main": [
        [
          {
            "node": "Carousel - Status Update",
            "type": "main",
            "index": 0
          },
          {
            "node": "Split Slides",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Video Response": {
      "main": [
        [
          {
            "node": "Video - Status Update",
            "type": "main",
            "index": 0
          },
          {
            "node": "Restore Video Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Trends Response": {
      "main": [
        [
          {
            "node": "Format Trend Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Trends Task Runner Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Carousel - Status Update": {
      "main": [
        []
      ]
    },
    "Split Slides": {
      "main": [
        [
          {
            "node": "Build fal.ai Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "fal.ai - Submit Image": {
      "main": [
        [
          {
            "node": "fal.ai - Await Image Result",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Images": {
      "main": [
        [
          {
            "node": "Package Carousel Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Package Carousel Data": {
      "main": [
        [
          {
            "node": "Store Pending Carousel",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Pending Carousel": {
      "main": [
        [
          {
            "node": "Send Carousel for Approval",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Carousel for Approval": {
      "main": [
        [
          {
            "node": "Split Remaining Images",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Remaining Images": {
      "main": [
        [
          {
            "node": "Download Carousel Image Binary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video - Status Update": {
      "main": [
        []
      ]
    },
    "ElevenLabs - Create Voiceover": {
      "main": [
        [
          {
            "node": "Restore Payload After Voiceover",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Video Scenes": {
      "main": [
        [
          {
            "node": "Collect All Clips",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect All Clips": {
      "main": [
        [
          {
            "node": "Package Video Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Package Video Data": {
      "main": [
        [
          {
            "node": "Prepare Render Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Approval": {
      "main": [
        [
          {
            "node": "Content Type Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Content Type Router": {
      "main": [
        [
          {
            "node": "Approval Confirmed",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Video Post Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Approval Confirmed": {
      "main": [
        [
          {
            "node": "Prepare Post Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Post Data": {
      "main": [
        [
          {
            "node": "Composio - Instagram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - Instagram": {
      "main": [
        [
          {
            "node": "Composio - LinkedIn",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - LinkedIn": {
      "main": [
        [
          {
            "node": "Composio - X/Twitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - X/Twitter": {
      "main": [
        [
          {
            "node": "Check Post Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Post Results": {
      "main": [
        [
          {
            "node": "Post Results Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Regeneration": {
      "main": [
        [
          {
            "node": "Regen Type Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Regen Type Router": {
      "main": [
        [
          {
            "node": "Regeneration Started",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Video Regen Started",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Regeneration Started": {
      "main": [
        [
          {
            "node": "Prepare Carousel Args",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video Regen Started": {
      "main": [
        [
          {
            "node": "Prepare Video Args",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure Action Intent": {
      "main": [
        [
          {
            "node": "Action Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Trend Message": {
      "main": [
        [
          {
            "node": "Auto Continue From Trends",
            "type": "main",
            "index": 0
          },
          {
            "node": "Trends - Send Topic",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Trends Task Runner Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trends - Send Topic": {
      "main": [
        [],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "fal.ai - Await Image Result": {
      "main": [
        [
          {
            "node": "Collect Images",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto Continue From Trends": {
      "main": [
        [
          {
            "node": "Action Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build fal.ai Prompt": {
      "main": [
        [
          {
            "node": "fal.ai - Submit Image",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Auto Mode Commands": {
      "main": [
        [
          {
            "node": "Ensure Action Intent",
            "type": "main",
            "index": 0
          },
          {
            "node": "Skip Reply For Mode Choose",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Remaining Images": {
      "main": [
        [],
        [
          {
            "node": "Send Image URL Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Carousel Image Binary": {
      "main": [
        [
          {
            "node": "Send Remaining Images",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Image URL Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resolve Founder Portrait URL": {
      "main": [
        [
          {
            "node": "Prepare Video Scenes",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Callback Ack Gate": {
      "main": [
        [
          {
            "node": "Answer Callback Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remotion Callback Webhook": {
      "main": [
        [
          {
            "node": "Normalize Render Callback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Render Callback": {
      "main": [
        [
          {
            "node": "Render Callback Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Render Data": {
      "main": [
        [
          {
            "node": "Trigger GitHub Actions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger GitHub Actions": {
      "main": [
        [
          {
            "node": "Video - Rendering Status",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Render Callback Router": {
      "main": [
        [
          {
            "node": "Download Rendered Video Binary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Render Callback To Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Video Post Data": {
      "main": [
        [
          {
            "node": "Video Post Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video Posting Started": {
      "main": [
        [
          {
            "node": "Composio - Instagram Reels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - Instagram Reels": {
      "main": [
        [
          {
            "node": "Composio - TikTok",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - TikTok": {
      "main": [
        [
          {
            "node": "Composio - YouTube Shorts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - YouTube Shorts": {
      "main": [
        [
          {
            "node": "Check Video Post Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Video Post Results": {
      "main": [
        [
          {
            "node": "Post Results Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video Post Router": {
      "main": [
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Lookup YouTube Connected Account",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lookup YouTube Connected Account": {
      "main": [
        [
          {
            "node": "Apply YouTube Connected Account",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply YouTube Connected Account": {
      "main": [
        [
          {
            "node": "Video Posting Started",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Rendered Video Binary": {
      "main": [
        [
          {
            "node": "Send Rendered Video To Telegram",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Render Callback To Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Video Payload": {
      "main": [
        [
          {
            "node": "ElevenLabs - Create Voiceover",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Payload After Voiceover": {
      "main": [
        [
          {
            "node": "Resolve Founder Portrait URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TEST_KEYS": {
      "main": [
        [
          {
            "node": "Load Chat History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Reply For Mode Choose": {
      "main": [
        [
          {
            "node": "Send AI Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trends Task Runner Fallback": {
      "main": [
        []
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 2
}