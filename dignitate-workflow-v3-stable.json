{
  "name": "Dignitate Content Automation (v3.9-direct-after-split-2026-02-10)",
  "nodes": [
    {
      "parameters": {
        "updates": [
          "message",
          "callback_query"
        ]
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000001",
      "name": "Telegram Trigger",
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000001",
      "position": [
        -688,
        400
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000002",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -688,
        700
      ],
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Load conversation history and build LLM context with lightweight memory\nconst update = $input.first().json || {};\nconst telegramMessage = update.message || update.callback_query?.message || {};\nconst message = String(update.message?.text || update.callback_query?.data || '');\nconst chatId = update.message?.chat?.id || update.callback_query?.message?.chat?.id || update.callback_query?.from?.id;\nconst messageId = update.message?.message_id || update.callback_query?.message?.message_id || update.callback_query?.id || null;\nconst replyToText = String(telegramMessage.reply_to_message?.text || '').trim();\nconst replyToMessageId = telegramMessage.reply_to_message?.message_id || null;\nconst repliedByBot = Boolean(telegramMessage.reply_to_message?.from?.is_bot);\nconst isSlash = message.trim().startsWith('/');\n\n// If this is a callback query, keep the original message text for fallback parsing\nconst sourceMessageText = String(update.callback_query?.message?.text || '').trim();\nconst sourceMessageId = update.callback_query?.message?.message_id || null;\nconst callbackQueryId = update.callback_query?.id || null;\n\nconst staticData = $getWorkflowStaticData('global');\nif (chatId) staticData.defaultChatId = String(chatId);\nif (!staticData.conversations) staticData.conversations = {};\nif (!staticData.userMemory) staticData.userMemory = {};\n\nconst chatKey = String(chatId || '');\nconst now = Date.now();\nconst TWO_HOURS = 2 * 60 * 60 * 1000;\n\nif (staticData.conversations[chatKey] && (now - staticData.conversations[chatKey].lastActivity) > TWO_HOURS) {\n  delete staticData.conversations[chatKey];\n}\n\nif (!staticData.conversations[chatKey]) {\n  staticData.conversations[chatKey] = { messages: [], lastActivity: now };\n}\n\nconst conv = staticData.conversations[chatKey];\nconv.lastActivity = now;\n\nif (message) {\n  conv.messages.push({ role: 'user', content: message });\n}\n\nif (conv.messages.length > 12) {\n  conv.messages = conv.messages.slice(-12);\n}\n\nconst pending = staticData.pendingContent?.[chatKey] || null;\nconst mem = staticData.userMemory[chatKey] || {};\n\nconst memorySummary = [\n  pending ? `pending_type=${pending.type || 'unknown'}` : 'pending_type=none',\n  pending ? `pending_title=\"${(pending.title || pending.args || 'untitled').replace(/\"/g, \"'\")}\"` : 'pending_title=none',\n  mem.lastAction ? `last_action=${mem.lastAction}` : 'last_action=none',\n  mem.lastTopic ? `last_topic=\"${String(mem.lastTopic).replace(/\"/g, \"'\")}\"` : 'last_topic=none'\n].join('; ');\n\nconst systemPrompt = `You are Dignitate's assistant in Telegram. Dignitate is a UK charity supporting cultural carers in the dementia journey.\n\nBehave like a natural LLM chat assistant: warm, practical, concise, and context-aware.\n- Default to natural conversation, not command-style instructions.\n- Do not mention slash commands unless the user explicitly asks.\n- Keep most replies to 1-3 short sentences.\n- Ask at most one clarifying question only when essential.\n- If user confirms (for example: yes, do it, go ahead, make it), use prior context and proceed.\n\nCAPABILITIES:\n- Create Instagram carousel drafts with generated images\n- Create short-form video drafts\n- Pull latest dementia-care trends\n- Approve/regenerate pending drafts for posting\n\nALWAYS return valid JSON only, no markdown, no extra text:\n{\"reply\":\"assistant reply\",\"action\":{\"type\":\"carousel|video|both|trends|approve|regenerate|status|help|none\",\"topic\":\"topic or empty\"}}\n\nACTION POLICY:\n- If user clearly asks for a carousel, set type=carousel.\n- If user clearly asks for a video/reel/tiktok, set type=video.\n- If user asks for both formats, set type=both.\n- If user asks for trends or what to post now, set type=trends.\n- If user asks to post/approve/publish, set type=approve.\n- If user asks to redo/regenerate/try again, set type=regenerate.\n- If user asks for status/help, set type=status/help.\n- If it is normal chat without execution request, set type=none.\n- When action is carousel/video/both and topic is implied by context, infer topic from context.`;\n\nconst memoryMessage = `Conversation memory: ${memorySummary}`;\n\nconst aiMessages = [\n  { role: 'system', content: systemPrompt },\n  { role: 'system', content: memoryMessage },\n  ...conv.messages\n];\n\nconst aiMessagesJson = JSON.stringify(aiMessages);\n\nreturn [{\n  json: {\n    message,\n    chatId,\n    messageId,\n    replyToText,\n    replyToMessageId,\n    repliedByBot,\n    isSlash,\n    sourceMessageText,\n    sourceMessageId,\n    callbackQueryId,\n    conversationHistory: conv.messages,\n    aiMessagesJson,\n    memorySummary\n  }\n}];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000003",
      "name": "Load Chat History",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -464,
        400
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ String($json.isSlash) }}",
                    "rightValue": "true",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Slash"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000004",
      "name": "Is Slash Command?",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -240,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"z-ai/glm-5\",\n  temperature: 0.5,\n  messages: [\n    {\n      role: \"system\",\n      content: \"You create educational Instagram carousel scripts for Dignitate (UK dementia-care support for carers). UK English. Factual, compassionate, plain language. Output STRICT JSON only, no markdown, no extra text.\"\n    },\n    {\n      role: \"user\",\n      content:\n        \"TOPIC LOCK (must stay exact): \" + ($json.args || \"dementia caregiving support in the UK\") +\n        \"\\n\\nRESEARCH SUMMARY (use for context only; do not invent numbers):\\n\" + ($json.researchSummary || \"No research summary available.\") +\n        \"\\n\\nRESEARCH FACTS (ONLY source for numbers/claims):\\n\" + JSON.stringify($json.researchFacts || [], null, 2) +\n        \"\\n\\nPRACTICAL ACTIONS FOR CARERS (use as ideas):\\n\" + JSON.stringify($json.researchActions || [], null, 2) +\n        \"\\n\\nTASK: Create exactly 5 slides. Each slide must have a SHORT heading + a USEFUL subline.\\n\\nTEXT RULES (very important):\\n- No meta labels. Never use: Why this matters now, What changed, Evidence update, Key takeaway, Next step, Conclusion.\\n- No colons in the heading.\\n- Heading: 3-7 words.\\n- Subline: 12-18 words.\\n- No dense paragraphs. No bullets. No hashtags inside the slide text.\\n- Avoid generic filler (example: New research shows a link). Every subline must contain either (a) one concrete fact, or (b) one clear action carers can do.\\n- If a number is not present in research facts, do not invent it.\\n\\nCONTENT STRUCTURE:\\n1) cover: punchy promise for carers\\n2) fact: include ONE key number if available\\n3) fact: either another number OR a clear explanation in plain language\\n4) action: one practical step today (specific, not vague)\\n5) action: one practical next step + short CTA: Follow Dignitate for support\\n\\nIMAGE PROMPT RULES (one clean scene each):\\n- 4:5 portrait. Editorial UK healthcare documentary realism.\\n- Each slide must have a DIFFERENT scene idea and DIFFERENT setting.\\n- Scene must match the slide meaning AND reflect the topic using relevant props (e.g. coffee cup, GP leaflet, calendar).\\n- One scene only. No collage/grid/split-screen/storyboard. No text overlays, no logos.\\n\\nOUTPUT JSON ONLY (exact shape):\\n{\\\"title\\\":\\\"...\\\",\\\"slides\\\":[{\\\"role\\\":\\\"cover\\\"|\\\"information\\\"|\\\"conclusion\\\",\\\"heading\\\":\\\"...\\\",\\\"subline\\\":\\\"...\\\",\\\"imagePrompt\\\":\\\"...\\\"}],\\\"hashtags\\\":[\\\"#DementiaCare\\\",\\\"#CarerSupport\\\",\\\"#UKHealth\\\",\\\"#Dignitate\\\"],\\\"caption\\\":\\\"...\\\"}\"\n    }\n  ]\n}) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000007",
      "name": "OpenRouter - Carousel Script",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        460,
        160
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"z-ai/glm-5\",\n  temperature: 0.6,\n  messages: [\n    {\n      role: \"system\",\n      content: \"You write high-retention, compassionate UK short-form vertical video scripts for Dignitate (dementia-care support for carers). Use UK English. Sound like a real person speaking to one carer. Short sentences. Concrete steps. Output STRICT JSON only (no markdown, no extra text).\"\n    },\n    {\n      role: \"user\",\n      content:\n        \"TOPIC LOCK (must stay exact): \" + ($json.args || \"signs of caregiver burnout\") +\n        \"\\n\\nRESEARCH SOURCE TEXT (ONLY source for claims/numbers; if not present, do NOT invent):\\n\" + ($json.research || \"No research available.\") +\n        \"\\n\\nTASK: Write ONE 30-second vertical short split into exactly 2 scenes (2 x 15s).\\n\\nSCRIPT RULES:\\n- Hook fast. First line must be a pattern interrupt (question or bold statement).\\n- Speak directly to one person (you, your).\\n- Keep it simple. No academic tone. No waffle.\\n- Use at most ONE statistic, and only if it appears in the research text.\\n- Never use these phrases anywhere: Why this matters now, What changed, Evidence update, Key takeaway, Next step, Conclusion. If you use them, the output is invalid.\\n- No bullets, no headings, no labels, no stage directions. No citations like [1] and no URLs.\\n\\nTIMING:\\n- Scene 1 narration: 28-38 words. Hook + one clear point.\\n- Scene 2 narration: 28-38 words. Give 3 practical actions (short, specific). End with: Follow Dignitate for support.\\n\\nVISUAL PROMPTS (one per scene):\\n- Vertical 9:16, documentary/editorial photorealism, natural skin texture, realistic lighting.\\n- Two different environments. No studio portrait background.\\n- IMPORTANT: do not describe the subject as talking to camera. Avoid visible lip movement. The clip should work as silent b-roll under voiceover (reading, walking, listening, writing, gentle gestures).\\n- Frame: chest-up, centred subject, eyes sharp, hands visible if possible. Leave bottom 30% clean for subtitles.\\n- No collage, no grid, no split-screen, no storyboard, no text overlays, no logos, no watermark.\\n\\nOUTPUT JSON ONLY (exact shape):\\n{\\\"title\\\":\\\"...\\\",\\\"scenes\\\":[{\\\"type\\\":\\\"hook\\\",\\\"narration\\\":\\\"...\\\",\\\"visualPrompt\\\":\\\"...\\\",\\\"duration\\\":15},{\\\"type\\\":\\\"cta\\\",\\\"narration\\\":\\\"...\\\",\\\"visualPrompt\\\":\\\"...\\\",\\\"duration\\\":15}],\\\"hashtags\\\":[\\\"#DementiaCare\\\",\\\"#CarerSupport\\\",\\\"#UKHealth\\\",\\\"#Dignitate\\\"],\\\"caption\\\":\\\"...\\\"}\"\n    }\n  ]\n}) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000008",
      "name": "OpenRouter - Video Script",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        460,
        400
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"perplexity/sonar-pro\",\n  messages: [\n    {\n      role: \"system\",\n      content: \"You are a trend analyst for Dignitate, a UK dementia-care organisation supporting cultural carers. Return strict JSON only.\"\n    },\n    {\n      role: \"user\",\n      content:\n        \"Find 12 diverse high-engagement trend topics about dementia care and carers from the last 7 days (prioritize last 72 hours).\" +\n        \" Focus UK first, but include major global developments with clear UK relevance.\" +\n        \" Cover varied areas: policy, clinical research, caregiving practice, social care delivery, community support, legal rights, workforce, prevention, digital health, finance, and lived-experience stories.\" +\n        \" Avoid near-duplicate topics and avoid repeating the same angle.\" +\n        \" Return ONLY JSON array with exactly 12 items and this schema:\" +\n        \" [{\\\"title\\\":\\\"...\\\",\\\"summary\\\":\\\"2-3 sentences\\\",\\\"engagement_score\\\":8,\\\"category\\\":\\\"policy|research|caregiving|community|technology|finance|legal|clinical\\\",\\\"region\\\":\\\"UK|Global-UK\\\"}]\"\n    }\n  ]\n}) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000009",
      "name": "OpenRouter - Trends",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        460,
        640
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "Everything is running smoothly.\\nBuild: v3-stable-2026-02-11-lock-throttle-fix\\n\\nI can research a topic, create carousel or video drafts, pull trends, and post approved drafts.\\n\\nTell me what you want to create, for example: \"Create a carousel about caregiver burnout in South Asian families.\"",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000010",
      "name": "Status Response",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000010",
      "position": [
        0,
        820
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "I can work like a normal chat assistant.\n\nTry prompts like:\n- Create a carousel about dementia-friendly home routines\n- Make a short video about signs of caregiver burnout\n- What are the latest UK dementia-care trends?\n- This looks good, post it\n- Regenerate this with a more hopeful tone\n\nCreator profile for realistic videos:\n- /setface <public_image_url>\n- /setvoiceid <elevenlabs_voice_id>\n- /creator\n- /commands\n\nAuto mode is currently disabled.\n\nGive me your topic and preferred format, and I will handle the workflow.",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000011",
      "name": "Help Response",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000011",
      "position": [
        0,
        1020
      ]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json || {};\nconst rawContent = response.choices?.[0]?.message?.content || '{}';\nconst content = Array.isArray(rawContent)\n  ? rawContent.map((c) => c?.text || '').join('\\n')\n  : String(rawContent || '{}');\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n\\t]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction stripMeta(text) {\n  let t = clean(text);\n  if (!t) return t;\n  t = t\n    .replace(/^(why this matters now|what changed|evidence update|what this means for carers|next step|key takeaway|conclusion)\\s*[:\\-]\\s*/i, '')\n    .replace(/\\b(why this matters now|what changed|evidence update|key takeaway|next step)\\b\\s*[:\\-]?\\s*/ig, '')\n    .trim();\n  return t;\n}\n\nfunction parseJsonLoose(text) {\n  const t = String(text || '').trim();\n  if (!t) return null;\n  const stripped = t\n    .replace(/^\\x60\\x60\\x60json\\s*/i, '')\n    .replace(/^\\x60\\x60\\x60\\s*/i, '')\n    .replace(/\\x60\\x60\\x60$/i, '')\n    .trim();\n  try { return JSON.parse(stripped); } catch (e) {}\n  const start = stripped.indexOf('{');\n  const end = stripped.lastIndexOf('}');\n  if (start >= 0 && end > start) {\n    try { return JSON.parse(stripped.slice(start, end + 1)); } catch (e) {}\n  }\n  return null;\n}\n\nfunction tokenize(text) {\n  const stop = new Set(['the','and','for','with','that','this','from','into','onto','your','about','what','need','know','over','more','less','than','have','has','had','are','was','were','can','will','their','they','them','our','out','now','new','how','why']);\n  return clean(text)\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, ' ')\n    .split(/\\s+/)\n    .filter((w) => w.length > 2 && !stop.has(w));\n}\n\nfunction clampWords(text, minWords, maxWords, fillerWord = 'support') {\n  let words = stripMeta(text).split(/\\s+/).filter(Boolean);\n  if (!words.length) words = ['Dementia', 'care'];\n  if (words.length > maxWords) words = words.slice(0, maxWords);\n  while (words.length < minWords) words.push(fillerWord);\n  return words.join(' ');\n}\n\nfunction sentence(text, maxWords) {\n  let t = stripMeta(text);\n  if (!t) return '';\n  t = t.replace(/[.!?]+$/g, '');\n  t = clampWords(t, 6, maxWords, 'care');\n\n  // Avoid ending mid-thought (e.g., \"prevalence of\").\n  const trailing = new Set(['of','for','to','in','on','with','and','or','the','a','an','at','by','from']);\n  let words = t.split(/\\s+/).filter(Boolean);\n  while (words.length > 6 && trailing.has(words[words.length - 1].toLowerCase())) {\n    words.pop();\n  }\n  return words.join(' ');\n}\n\nfunction titleCase(text, maxWords) {\n  const words = stripMeta(text).split(/\\s+/).filter(Boolean).slice(0, maxWords);\n  return words.map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');\n}\n\nfunction sanitizeImagePrompt(text) {\n  let t = clean(text);\n  if (!t) return '';\n  t = t\n    .replace(/#[0-9a-f]{3,8}\\b/gi, '')\n    .replace(/\\b(?:rgb|rgba|hsl|hsla|cmyk)\\s*\\([^)]*\\)/gi, '')\n    .replace(/\\b(collage|grid|mosaic|split\\s*screen|diptych|triptych|quad\\s*panel|four\\s*panel|multi\\s*panel|storyboard|contact\\s*sheet|comic\\s*panel|tiled?)\\b/gi, '')\n    .replace(/\\s{2,}/g, ' ')\n    .trim();\n\n  const words = t.split(/\\s+/).filter(Boolean);\n  if (words.length < 6) return '';\n  return t;\n}\n\nlet parsed = parseJsonLoose(content) || {};\n\nlet base = {};\ntry { base = $('Parse Carousel Research').first().json || {}; } catch (e) {}\n\nlet commandData = {};\ntry { commandData = $('Load Chat History').first().json || {}; } catch (e) {}\n\nconst requestedTopic = clean(base.args || base.requestedTopic || commandData.args || parsed.title || 'Dementia care support for UK carers');\nconst topicTokens = tokenize(requestedTopic);\n\nconst facts = Array.isArray(base.researchFacts) ? base.researchFacts : [];\nconst actions = Array.isArray(base.researchActions) ? base.researchActions : [];\nconst summary = clean(base.researchSummary || '');\n\nconst title = titleCase(parsed.title || requestedTopic || 'Dementia Care Update', 8) || 'Dementia Care Update';\n\nfunction pick(arr, i, key = 'fact') {\n  const v = arr[i];\n  if (!v) return '';\n  if (typeof v === 'string') return clean(v);\n  if (typeof v === 'object') return clean(v[key] || v.text || v.value || '');\n  return '';\n}\n\nfunction fallbackSlides() {\n  const f1 = pick(facts, 0) || summary || ('What carers should know about ' + requestedTopic);\n  const f2 = pick(facts, 1) || pick(facts, 0) || 'Support needs can change quickly, and carers often carry it alone.';\n  const f3 = pick(facts, 2) || pick(facts, 1) || 'Small routines and early contact with services reduce crisis moments.';\n\n  const a1 = pick(actions, 0, 'action') || pick(actions, 0, '') || 'Ask for a named contact at your GP or memory service.';\n  const a2 = pick(actions, 1, 'action') || pick(actions, 1, '') || 'Write a simple daily plan for meals, meds, rest, water.';\n  const a3 = pick(actions, 2, 'action') || pick(actions, 2, '') || 'Share the plan with one person who can help.';\n\n  return [\n    {\n      role: 'cover',\n      heading: clampWords(title, 3, 7, 'care'),\n      subline: sentence(f1, 18),\n      imagePrompt: 'Single UK dementia-care editorial photo: carer and professional in a calm NHS clinic setting, warm natural light, 4:5 portrait, one scene only'\n    },\n    {\n      role: 'information',\n      heading: clampWords(pick(facts, 1) || 'Care gaps show up early', 3, 7, 'care'),\n      subline: sentence(f2, 18),\n      imagePrompt: 'Single UK home-care scene: carer reviewing notes with calm focus at a kitchen table, realistic props, 4:5 portrait, one scene only'\n    },\n    {\n      role: 'information',\n      heading: clampWords(pick(actions, 0, 'action') || 'One action that helps', 3, 7, 'support'),\n      subline: sentence(f3, 18),\n      imagePrompt: 'Single UK community health centre scene: supportive conversation, documentary realism, 4:5 portrait, one scene only'\n    },\n    {\n      role: 'information',\n      heading: 'Do this today',\n      subline: sentence(a1 + ' ' + a2, 18),\n      imagePrompt: 'Single UK care-planning moment: simple calendar and leaflet on table, documentary photo, 4:5 portrait, one scene only'\n    },\n    {\n      role: 'conclusion',\n      heading: 'One next step',\n      subline: sentence(a3 + ' Follow Dignitate for support', 18),\n      imagePrompt: 'Single hopeful UK living room scene: gentle supportive routine, warm light, 4:5 portrait, one scene only'\n    }\n  ];\n}\n\nconst rawSlides = Array.isArray(parsed.slides) ? parsed.slides : [];\nconst roles = ['cover', 'information', 'information', 'information', 'conclusion'];\n\nconst fallbacks = fallbackSlides();\n\nlet slides = [];\nfor (let i = 0; i < 5; i++) {\n  const role = roles[i];\n  const s = rawSlides[i] || {};\n\n  // Support both schemas:\n  // A) {heading, subline, imagePrompt}\n  // B) {text: \"Heading: subline\"}\n  const text = clean(s.text || s.caption || '');\n  let heading = stripMeta(clean(s.heading || ''));\n  let subline = stripMeta(clean(s.subline || ''));\n\n  if ((!heading || !subline) && text) {\n    const idx = text.indexOf(':');\n    if (idx > 0 && idx < 60) {\n      heading = heading || stripMeta(text.slice(0, idx));\n      subline = subline || stripMeta(text.slice(idx + 1));\n    } else {\n      // No colon: treat first 7 words as heading.\n      const words = stripMeta(text).split(/\\s+/).filter(Boolean);\n      heading = heading || words.slice(0, 7).join(' ');\n      subline = subline || words.slice(7).join(' ');\n    }\n  }\n\n  if (!heading) heading = fallbacks[i].heading;\n  if (!subline) subline = fallbacks[i].subline;\n\n  // Enforce length\n  heading = clampWords(heading, 3, 7, 'care');\n  subline = clampWords(subline, 10, 18, 'support');\n\n  // Enforce usefulness: subline must include a number OR an action verb.\n  const hasNumber = /\\d/.test(subline);\n  const hasAction = /\\b(ask|check|book|call|write|plan|track|try|share|speak|request|tell|save|note)\\b/i.test(subline);\n  if (!hasNumber && !hasAction) {\n    subline = fallbacks[i].subline;\n  }\n\n  // Never allow the bad phrase to appear.\n  const banned = /\\b(why\\s+this\\s+matters\\s+now|evidence\\s+update|key\\s+takeaway|next\\s+step|what\\s+changed|conclusion|what\\s+you\\s+might\\s+notice|what\\s+helps\\s+most|try\\s+this\\s+today|next\\s+step\\s+for\\s+you)\\b/i;\n  if (banned.test(heading)) heading = fallbacks[i].heading;\n  if (banned.test(subline)) subline = fallbacks[i].subline;\n\n  let imagePrompt = sanitizeImagePrompt(s.imagePrompt || s.image_prompt || s.visualPrompt || s.prompt || s.image || '');\n  if (!imagePrompt) imagePrompt = sanitizeImagePrompt(fallbacks[i].imagePrompt);\n\n  slides.push({\n    role,\n    heading,\n    subline,\n    text: heading + ': ' + subline,\n    imagePrompt,\n  });\n}\n\nfunction topicHit(text) {\n  if (!topicTokens.length) return true;\n  const set = new Set(tokenize(text));\n  return topicTokens.some((t) => set.has(t));\n}\n\nconst relevanceHits = slides.filter((s) => topicHit(s.text + ' ' + s.imagePrompt)).length;\nlet driftCorrected = false;\n// If topic drift is extreme, swap to fallbacks.\nif (topicTokens.length > 0 && relevanceHits < 3) {\n  slides = fallbacks.map((s) => ({\n    role: s.role,\n    heading: s.heading,\n    subline: s.subline,\n    text: s.heading + ': ' + s.subline,\n    imagePrompt: sanitizeImagePrompt(s.imagePrompt),\n  }));\n  driftCorrected = true;\n}\n\nlet hashtags = Array.isArray(parsed.hashtags) ? parsed.hashtags : [];\nif (!hashtags.length) hashtags = ['#DementiaCare', '#CarerSupport', '#UKHealth', '#Dignitate'];\nhashtags = [...new Set(hashtags.map((h) => String(h || '').trim()).filter(Boolean))].slice(0, 12);\n\nlet caption = clean(parsed.caption || '');\nif (!caption) {\n  caption = clean((summary || requestedTopic) + ' Five slides: what to notice, what helps, and one next step you can take today.');\n}\nif (caption.length > 700) caption = caption.slice(0, 697) + '...';\n\nreturn [{\n  json: {\n    title,\n    slides,\n    hashtags,\n    caption,\n    chatId: base.chatId || commandData.chatId,\n    args: requestedTopic,\n    coherence: { relevanceHits, driftCorrected }\n  }\n}];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000012",
      "name": "Parse Carousel Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json || {};\nconst rawContent = response.choices?.[0]?.message?.content || '{}';\nconst content = Array.isArray(rawContent)\n  ? rawContent.map((c) => c?.text || '').join('\\n')\n  : String(rawContent || '{}');\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction parseJsonLoose(text) {\n  const t = clean(text);\n  if (!t) return null;\n  const stripped = t\n    .replace(/^\\x60\\x60\\x60json\\s*/i, '')\n    .replace(/^\\x60\\x60\\x60\\s*/i, '')\n    .replace(/\\x60\\x60\\x60$/i, '')\n    .trim();\n  try { return JSON.parse(stripped); } catch (e) {}\n  const start = stripped.indexOf('{');\n  const end = stripped.lastIndexOf('}');\n  if (start >= 0 && end > start) {\n    try { return JSON.parse(stripped.slice(start, end + 1)); } catch (e) {}\n  }\n  return null;\n}\n\nfunction tokenize(text) {\n  const stop = new Set(['the','and','for','with','that','this','from','into','your','about','over','more','than','have','has','had','are','was','were','will','can','their','they','them','our','out','now','new','how','why']);\n  return clean(text)\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, ' ')\n    .split(/\\s+/)\n    .filter((w) => w.length > 2 && !stop.has(w));\n}\n\nfunction stripMetaLabels(text) {\n  let t = clean(text);\n  if (!t) return t;\n  // Remove common robotic meta labels if the model adds them anyway.\n  t = t\n    .replace(/^(why this matters now|what changed|evidence update|what this means for carers|next step|key takeaway)\\s*[:\\-]\\s*/i, '')\n    .replace(/\b(key takeaway)\\s*[:\\-].*$/i, '')\n    .trim();\n  return t;\n}\n\nfunction clampWords(text, minWords, maxWords) {\n  let words = clean(text).split(/\\s+/).filter(Boolean);\n  if (!words.length) return '';\n  if (words.length > maxWords) words = words.slice(0, maxWords);\n  return words.join(' ');\n}\n\nfunction ensureSentence(text) {\n  const t = clean(text);\n  if (!t) return t;\n  return /[.!?]$/.test(t) ? t : (t + '.');\n}\n\nfunction ensureRoleText(idx, text, fallback) {\n  let t = clean(text || fallback);\n  if (!t) t = clean(fallback);\n\n  // Keep narration natural (no meta labels), and keep timing roughly 15s per scene.\n  t = stripMetaLabels(t);\n  t = clampWords(t, 26, 34);\n  return ensureSentence(t);\n}\n\nlet parsed = parseJsonLoose(content) || {};\n\nlet base = {};\ntry { base = $('Parse Video Research').first().json || {}; } catch (e) {}\n\nlet commandData = {};\ntry { commandData = $('Load Chat History').first().json || {}; } catch (e) {}\n\nconst requestedTopic = clean(base.args || base.requestedTopic || commandData.args || parsed.title || 'Dementia care support for UK carers');\nconst topicTokens = tokenize(requestedTopic);\nconst researchSummary = clean(base.research || '');\n\nconst creatorImageUrl = clean(base.creatorImageUrl || '');\nconst creatorVoiceId = clean(base.creatorVoiceId || 'GoLTMzQJAHarswiHqv3L');\n\nfunction enrichPrompt(rawPrompt, fallbackPrompt) {\n  const raw = clean(rawPrompt || fallbackPrompt);\n\n  const has = (re) => re.test(raw);\n  const segments = [raw];\n\n  if (!has(/\\btopic context:/i)) {\n    segments.push('topic context: ' + requestedTopic);\n  }\n\n  if (creatorImageUrl) {\n    if (!has(/same exact person identity|preserve face consistency|reference image/i)) {\n      segments.push('same exact person identity as the provided reference image, preserve face consistency across scenes');\n    }\n  } else if (!has(/same main person identity/i)) {\n    segments.push('same main person identity across all scenes');\n  }\n\n  if (!has(/photorealistic human|natural skin texture|documentary realism|cinematic natural lighting|realistic movement/i)) {\n    segments.push('photorealistic human, natural skin texture, documentary realism, cinematic natural lighting, realistic movement');\n  }\n\n  if (!has(/single scene only|no collage|no grid|no split-screen|no storyboard|no text overlays|no logos/i)) {\n    segments.push('single scene only, no collage, no grid, no split-screen, no storyboard, no text overlays, no logos');\n  }\n\n  return segments\n    .map((s) => clean(s))\n    .filter(Boolean)\n    .filter((s, idx, arr) => arr.findIndex((x) => x.toLowerCase() === s.toLowerCase()) === idx)\n    .join(', ');\n}\n\nfunction topicHit(text) {\n  if (!topicTokens.length) return true;\n  const set = new Set(tokenize(text));\n  return topicTokens.some((t) => set.has(t));\n}\n\nconst fallbackNarrationBase = researchSummary || ('Current focus: ' + requestedTopic);\n\nconst fallbackScenes = [\n  {\n    narration: ensureRoleText(\n      0,\n      '',\n      'Quick question: are you carrying dementia care mostly on your own? This update stays on the topic and what the evidence suggests. If you feel stretched, you're not failing. You need clearer steps and support.'\n    ),\n    visualPrompt: enrichPrompt(\n      'realistic UK carer in conversation with dementia specialist in a calm clinical setting, documentary style',\n      'realistic UK caregiving opening scene'\n    )\n  },\n  {\n    narration: ensureRoleText(\n      1,\n      '',\n      'Try this today: write a 2-line plan for the next 24 hours, ask your GP or memory service for a named contact, and pick one steady routine (meals, meds, water, rest). Share it with one person who can help. Follow Dignitate.'\n    ),\n    visualPrompt: enrichPrompt(\n      'realistic UK home-care planning session with carer and professional reviewing a simple weekly support plan, hopeful close',\n      'realistic UK guidance closing scene'\n    )\n  }\n];\n\nconst rawHook = parsed.hook || null;\nconst rawMiddle = Array.isArray(parsed.scenes) ? parsed.scenes : [];\nconst rawCta = parsed.cta || null;\n\n// Support both formats:\n// 1) Legacy: {hook, scenes:[...], cta}\n// 2) Two-shot: {scenes:[{...},{...}]}\nlet rawList;\nif (rawHook || rawCta) {\n  rawList = [rawHook || {}, ...rawMiddle, rawCta || {}];\n} else if (rawMiddle.length >= 2) {\n  rawList = rawMiddle;\n} else {\n  rawList = [rawMiddle[0] || {}, {}];\n}\n\n// Keep only 2 scenes for cost/time control.\nrawList = rawList.slice(0, 2);\nwhile (rawList.length < 2) rawList.push({});\n\nconst fallback2 = [fallbackScenes[0], fallbackScenes[fallbackScenes.length - 1]];\n\nlet candidate = rawList.map((s, idx) => {\n  const fallback = fallback2[idx] || fallback2[fallback2.length - 1];\n  const narration = ensureRoleText(idx, s?.narration || s?.text || '', fallback.narration);\n  const visualPrompt = enrichPrompt(\n    s?.visualPrompt || s?.imagePrompt || s?.prompt || s?.image || '',\n    fallback.visualPrompt\n  );\n  const duration = Number(s?.duration);\n  return { narration, visualPrompt, duration: Number.isFinite(duration) && duration > 0 ? duration : 15, type: s?.type };\n});\n\nconst relevanceHits = candidate.filter((s) => topicHit(s.narration + ' ' + s.visualPrompt)).length;\nconst lowInfo = candidate.some((s) => clean(s.narration).split(/\\s+/).filter(Boolean).length < 12);\n\nlet driftCorrected = false;\nif ((topicTokens.length > 0 && relevanceHits < 1) || lowInfo) {\n  candidate = fallbackScenes;\n  driftCorrected = true;\n}\n\nconst total = candidate.length;\nconst allScenes = candidate.map((s, idx) => ({\n  narration: s.narration,\n  visualPrompt: s.visualPrompt,\n  type: clean(s.type) || (idx === 0 ? 'hook' : (idx === total - 1 ? 'cta' : 'scene')),\n  duration: Number(s.duration) || 15,\n  index: idx\n}));\n\nconst fullNarration = allScenes.map((s) => stripMetaLabels(clean(s.narration))).filter(Boolean).join(' ');\n\nlet hashtags = Array.isArray(parsed.hashtags) ? parsed.hashtags : [];\nif (!hashtags.length) hashtags = ['#DementiaCare', '#CarerSupport', '#UKHealth', '#Dignitate'];\nhashtags = [...new Set(hashtags.map((h) => clean(h)).filter(Boolean))].slice(0, 12);\n\nlet caption = clean(parsed.caption || '');\nif (!caption) {\n  caption = clean(requestedTopic + '. Short-form, research-backed guidance for carers in two connected 15-second scenes: evidence, practical steps, and a clear CTA.');\n}\nif (caption.length > 700) caption = caption.slice(0, 697) + '...';\n\nlet title = clean(parsed.title || requestedTopic || 'Dementia Care Video');\nif (title.length > 120) title = title.slice(0, 117) + '...';\n\nreturn [{\n  json: {\n    title,\n    hook: allScenes[0],\n    scenes: allScenes.slice(1, -1),\n    cta: allScenes[allScenes.length - 1],\n    hashtags,\n    caption,\n    fullNarration,\n    allScenes,\n    sceneCount: allScenes.length,\n    chatId: base.chatId || commandData.chatId,\n    args: requestedTopic,\n    creatorImageUrl,\n    creatorVoiceId,\n    coherence: {\n      relevanceHits,\n      driftCorrected,\n      lowInfo\n    }\n  }\n}];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000013",
      "name": "Parse Video Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Telegram sendMessage nodes replace the current item with Telegram's API response.\n// Restore the real video payload (title/scenes/narration/creator refs) so downstream nodes use correct data.\nconst base = $('Parse Video Response').first().json || {};\nlet args = {};\ntry { args = $('Prepare Video Args').first().json || {}; } catch (e) {}\n\nreturn [{\n  json: {\n    ...args,\n    ...base,\n    // Keep creatorImageUrls pool if present\n    creatorImageUrls: base.creatorImageUrls || args.creatorImageUrls || [],\n  }\n}];\n"
      },
      "id": "restore-video-payload-v1",
      "name": "Restore Video Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        920,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json || {};\nconst rawContent = response.choices?.[0]?.message?.content ?? response.output_text ?? response.text ?? '[]';\nconst content = Array.isArray(rawContent)\n  ? rawContent.map((c) => (typeof c === 'string' ? c : (c?.text || JSON.stringify(c)))).join('\\n')\n  : String(rawContent || '[]');\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction asArray(v) {\n  if (Array.isArray(v)) return v;\n  if (v && typeof v === 'object') {\n    for (const key of ['topics', 'trends', 'items', 'results', 'data']) {\n      if (Array.isArray(v[key])) return v[key];\n    }\n    if (v.title || v.topic) return [v];\n  }\n  return [];\n}\n\nfunction parseJsonLoose(text) {\n  const t = String(text || '').trim();\n  if (!t) return [];\n\n  const stripped = t\n    .replace(/^\\x60\\x60\\x60json\\s*/i, '')\n    .replace(/^\\x60\\x60\\x60\\s*/i, '')\n    .replace(/\\x60\\x60\\x60$/i, '')\n    .trim();\n\n  try {\n    const parsed = JSON.parse(stripped);\n    const arr = asArray(parsed);\n    if (arr.length) return arr;\n  } catch (e) {}\n\n  const aStart = stripped.indexOf('[');\n  const aEnd = stripped.lastIndexOf(']');\n  if (aStart >= 0 && aEnd > aStart) {\n    try {\n      const parsed = JSON.parse(stripped.slice(aStart, aEnd + 1));\n      const arr = asArray(parsed);\n      if (arr.length) return arr;\n    } catch (e) {}\n  }\n\n  const oStart = stripped.indexOf('{');\n  const oEnd = stripped.lastIndexOf('}');\n  if (oStart >= 0 && oEnd > oStart) {\n    try {\n      const parsed = JSON.parse(stripped.slice(oStart, oEnd + 1));\n      const arr = asArray(parsed);\n      if (arr.length) return arr;\n    } catch (e) {}\n  }\n\n  return [];\n}\n\nfunction normTitle(s) {\n  return clean(s).toLowerCase().replace(/[^a-z0-9\\s]/g, '').replace(/\\s+/g, ' ').trim();\n}\n\nconst allowedCategories = new Set(['policy', 'research', 'caregiving', 'community', 'technology', 'finance', 'legal', 'clinical']);\nconst parsed = parseJsonLoose(content);\n\nlet topics = parsed\n  .map((t) => {\n    const title = clean(t?.title || t?.topic || '');\n    const summary = clean(t?.summary || t?.description || '');\n    let engagement_score = Number(t?.engagement_score ?? t?.engagementScore ?? 7);\n    if (!Number.isFinite(engagement_score)) engagement_score = 7;\n    engagement_score = Math.max(1, Math.min(10, Math.round(engagement_score)));\n\n    const rawCat = clean(t?.category || '').toLowerCase();\n    const category = allowedCategories.has(rawCat) ? rawCat : 'caregiving';\n    const region = clean(t?.region || 'UK');\n\n    return { title, summary, engagement_score, category, region };\n  })\n  .filter((t) => t.title && t.summary);\n\nconst fallbackPool = [\n  {\n    title: 'NHS Dementia Diagnosis Pathway Performance Update',\n    summary: 'Latest NHS pathway performance and waiting-time changes are affecting early diagnosis and support access for carers in the UK.',\n    engagement_score: 8,\n    category: 'clinical',\n    region: 'UK'\n  },\n  {\n    title: 'Local Authority Social Care Funding Pressures and Carer Impact',\n    summary: 'Council-level social care budget pressures are changing respite availability, home support capacity, and carer strain.',\n    engagement_score: 8,\n    category: 'finance',\n    region: 'UK'\n  },\n  {\n    title: 'Dementia Research Trial Recruitment and What It Means for Families',\n    summary: 'UK trial recruitment trends are shifting opportunities for participation and information access for families and carers.',\n    engagement_score: 7,\n    category: 'research',\n    region: 'UK'\n  },\n  {\n    title: 'Carer Legal Rights: Attendance Allowance and Support Entitlements',\n    summary: 'Recent guidance changes on entitlements and assessments are influencing financial and practical support for carers.',\n    engagement_score: 8,\n    category: 'legal',\n    region: 'UK'\n  },\n  {\n    title: 'Community Dementia Hubs Expanding Practical Support Services',\n    summary: 'Community hubs are introducing local support models that improve navigation, peer support, and caregiver wellbeing.',\n    engagement_score: 7,\n    category: 'community',\n    region: 'UK'\n  },\n  {\n    title: 'Digital Tools for Dementia Care Coordination in Primary Care',\n    summary: 'Digital coordination tools are being adopted to improve care continuity between GPs, memory clinics, and carers.',\n    engagement_score: 7,\n    category: 'technology',\n    region: 'UK'\n  },\n  {\n    title: 'Workforce Shortages in Dementia Services and Care Quality Risks',\n    summary: 'Staffing pressures across dementia services are affecting continuity, communication, and experience of care.',\n    engagement_score: 8,\n    category: 'policy',\n    region: 'UK'\n  },\n  {\n    title: 'Culturally Tailored Carer Support Programmes Expanding Across the UK',\n    summary: 'New culturally responsive support services are improving access and outcomes for carers from diverse communities.',\n    engagement_score: 8,\n    category: 'caregiving',\n    region: 'UK'\n  }\n];\n\nconst seenIncoming = new Set();\ntopics = topics.filter((t) => {\n  const k = normTitle(t.title);\n  if (!k || seenIncoming.has(k)) return false;\n  seenIncoming.add(k);\n  return true;\n});\n\nif (topics.length < 8) {\n  for (const f of fallbackPool) {\n    const key = normTitle(f.title);\n    if (seenIncoming.has(key)) continue;\n    topics.push(f);\n    seenIncoming.add(key);\n    if (topics.length >= 8) break;\n  }\n}\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.sentTrends) staticData.sentTrends = [];\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.globalSuggestedTopic) staticData.globalSuggestedTopic = '';\nif (!staticData.userMemory) staticData.userMemory = {};\nif (!staticData.trendCursorByChat) staticData.trendCursorByChat = {};\nif (!staticData.trendHistoryByChat) staticData.trendHistoryByChat = {};\n\nlet chatId = clean(response.chatId || response.chat_id || '');\nif (!chatId) {\n  try { chatId = clean($('Quick Parse Slash').first().json.chatId); } catch (e) {}\n}\nif (!chatId) {\n  try { chatId = clean($('Load Chat History').first().json.chatId); } catch (e) {}\n}\nif (!chatId) chatId = clean(staticData.defaultChatId || '');\nif (!chatId) return [];\n\nconst chatKey = String(chatId);\nconst now = Date.now();\nconst dedupeWindowMs = 72 * 60 * 60 * 1000;\nstaticData.sentTrends = staticData.sentTrends.filter((t) => now - Number(t.timestamp || 0) < dedupeWindowMs);\n\nconst historyWindowMs = 24 * 60 * 60 * 1000;\nconst history = Array.isArray(staticData.trendHistoryByChat[chatKey]) ? staticData.trendHistoryByChat[chatKey] : [];\nconst recentHistory = history.filter((h) => now - Number(h.timestamp || 0) < historyWindowMs);\nstaticData.trendHistoryByChat[chatKey] = recentHistory;\n\nconst recentlySentGlobal = new Set(staticData.sentTrends.map((t) => normTitle(t.title || '')));\nconst recentlySentChat = new Set(recentHistory.map((t) => normTitle(t.title || '')));\n\nlet fresh = topics.filter((t) => !recentlySentGlobal.has(normTitle(t.title)) && !recentlySentChat.has(normTitle(t.title)));\nif (!fresh.length) fresh = topics.filter((t) => !recentlySentChat.has(normTitle(t.title)));\nconst pool = fresh.length ? fresh : topics;\n\nconst sorted = [...pool].sort((a, b) => b.engagement_score - a.engagement_score);\nconst selected = [];\nconst usedCat = new Set();\n\nfor (const t of sorted) {\n  if (!usedCat.has(t.category)) {\n    selected.push(t);\n    usedCat.add(t.category);\n  }\n  if (selected.length >= 8) break;\n}\nfor (const t of sorted) {\n  if (selected.length >= 8) break;\n  if (!selected.includes(t)) selected.push(t);\n}\n\nlet ordered = selected.slice(0, 8);\nconst cursor = Number(staticData.trendCursorByChat[chatKey] || 0);\nif (ordered.length > 1) {\n  const shift = ((cursor % ordered.length) + ordered.length) % ordered.length;\n  ordered = ordered.slice(shift).concat(ordered.slice(0, shift));\n}\nstaticData.trendCursorByChat[chatKey] = cursor + 1;\n\nconst lastTopNorm = normTitle(staticData.lastTrendByChat[chatKey] || '');\nif (ordered.length > 1 && normTitle(ordered[0]?.title || '') === lastTopNorm) {\n  const swapIdx = ordered.findIndex((t, i) => i > 0 && normTitle(t.title) !== lastTopNorm);\n  if (swapIdx > 0) {\n    const tmp = ordered[0];\n    ordered[0] = ordered[swapIdx];\n    ordered[swapIdx] = tmp;\n  }\n}\n\nconst finalTopics = ordered.slice(0, 8);\nfor (const t of finalTopics) {\n  staticData.sentTrends.push({ title: t.title, category: t.category, timestamp: now });\n}\n\nif (finalTopics[0]?.title) {\n  const selectedTitle = String(finalTopics[0].title).trim();\n  staticData.lastTrendByChat[chatKey] = selectedTitle;\n  staticData.latestSuggestedTopicByChat[chatKey] = selectedTitle;\n  staticData.pendingTrendTopicByChat[chatKey] = selectedTitle;\n  staticData.globalSuggestedTopic = selectedTitle;\n  staticData.userMemory[chatKey] = {\n    ...(staticData.userMemory[chatKey] || {}),\n    lastTopic: selectedTitle,\n    lastAction: 'trends',\n    updatedAt: now\n  };\n}\n\nstaticData.trendHistoryByChat[chatKey] = [\n  ...recentHistory,\n  ...finalTopics.map((t) => ({ title: t.title, timestamp: now }))\n].slice(-60);\n\nreturn finalTopics.map((t, idx) => ({\n  json: {\n    ...t,\n    chatId,\n    rank: idx + 1,\n    totalTopics: finalTopics.length\n  }\n}));\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000014",
      "name": "Parse Trends Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        640
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{`Creating Carousel (v3.9-direct-after-split)...\n\nTitle: ${$json.title || 'Untitled Carousel'}\nSlides: ${Array.isArray($json.slides) ? $json.slides.length : 0}\nFirst slide text: ${(() => {\n  const t = String($json.slides?.[0]?.text || 'n/a').trim();\n  if (t.length <= 140) return t;\n  const cut = t.slice(0, 140);\n  const i = cut.lastIndexOf(' ');\n  return (i > 60 ? cut.slice(0, i) : cut) + '...';\n})()}\n\nGenerating unique images per slide with fal.ai...`}}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000015",
      "name": "Carousel - Status Update",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000015",
      "position": [
        940,
        160
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{`Creating Video...\\n\\nTitle: ${$json.title || 'Untitled Video'}\\nScenes: ${$json.sceneCount || 0}\\nCreator face: ${$json.creatorImageUrl ? 'set' : 'not set'}\\nCreator voice: ${$json.creatorVoiceId ? 'set' : 'default'}\\n\\nWorkflow build: 2026-02-15-gh-fal-v1\\n\\nStep 1/4: Creating voiceover with ElevenLabs...`}}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000016",
      "name": "Video - Status Update",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000016",
      "position": [
        940,
        400
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.trendMessage || \"Trending topic unavailable.\" }}",
        "replyMarkup": "inlineKeyboard",
        "inlineKeyboard": {
          "rows": [
            {
              "row": {
                "buttons": [
                  {
                    "text": "Carousel",
                    "additionalFields": {
                      "callback_data": "/carousel"
                    }
                  },
                  {
                    "text": "Video",
                    "additionalFields": {
                      "callback_data": "/video"
                    }
                  }
                ]
              }
            }
          ]
        },
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000017",
      "name": "Trends - Send Topic",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000017",
      "position": [
        940,
        640
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 2000
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json || {};\nlet data = input;\n\n// Fallback in case upstream node accidentally passes Telegram API response.\nif (!Array.isArray(data.slides) || data.slides.length === 0) {\n  try { data = $('Parse Carousel Response').first().json || data; } catch (e) {}\n}\n\nconst slides = Array.isArray(data.slides) ? data.slides : [];\nif (!slides.length) {\n  throw new Error('No slides found in carousel payload. Ensure Split Slides receives Parse Carousel Response output.');\n}\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n\\t]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nreturn slides.map((slide, idx) => {\n  const heading = clean(slide.heading || '');\n  const body = clean(slide.subline || slide.body || '');\n  const text = clean(slide.text || slide.caption || '');\n\n  return {\n    json: {\n      slideIndex: idx,\n      totalSlides: slides.length,\n      slideRole: String(slide.role || (idx === 0 ? 'cover' : (idx === slides.length - 1 ? 'conclusion' : 'information'))),\n      imagePrompt: slide.imagePrompt || slide.image_prompt || slide.visualPrompt || slide.prompt || '',\n      slideText: text,\n      slideHeading: heading,\n      slideBody: body,\n      chatId: data.chatId,\n      title: data.title,\n      hashtags: data.hashtags,\n      caption: data.caption,\n      args: data.args\n    }\n  };\n});\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000018",
      "name": "Split Slides",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1180,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://queue.fal.run/fal-ai/nano-banana-pro",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Key ' + $('TEST_KEYS').first().json.falKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  prompt: $json.falPrompt || 'Clean UK dementia-care editorial slide, 4:5, no logos',\n  num_images: 1,\n  seed: $json.falSeed,\n  aspect_ratio: \"4:5\",\n  output_format: \"png\",\n  resolution: \"1K\"\n}) }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000019",
      "name": "fal.ai - Submit Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1420,
        160
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": false
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000020",
      "name": "Collect Images",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1900,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nlet carouselData = {};\ntry { carouselData = $('Parse Carousel Response').first().json || {}; } catch (e) {}\n\nconst allImageUrls = [];\nconst expectedCandidates = [];\nconst failedRequests = [];\n\nfunction collectUrls(node, out) {\n  if (!node) return;\n  if (Array.isArray(node)) {\n    for (const x of node) collectUrls(x, out);\n    return;\n  }\n  if (typeof node === 'string') {\n    const u = node.trim();\n    if (/^https?:\\/\\//i.test(u)) out.push(u);\n    return;\n  }\n  if (typeof node !== 'object') return;\n\n  const candidates = [node.url, node.image_url, node.imageUrl];\n  for (const v of candidates) {\n    const u = String(v || '').trim();\n    if (/^https?:\\/\\//i.test(u)) out.push(u);\n  }\n\n  if (node.images) collectUrls(node.images, out);\n  if (node.image) collectUrls(node.image, out);\n  if (node.output) collectUrls(node.output, out);\n  if (node.outputs) collectUrls(node.outputs, out);\n  if (node.data) collectUrls(node.data, out);\n  if (node.result) collectUrls(node.result, out);\n  if (node.response) collectUrls(node.response, out);\n}\n\nfor (const item of items) {\n  const j = item?.json || {};\n\n  if (j.falError) {\n    failedRequests.push({ request_id: j.request_id || j.requestId || '', error: String(j.falError) });\n  }\n\n  collectUrls(j, allImageUrls);\n\n  if (Number.isFinite(Number(j.totalSlides)) && Number(j.totalSlides) > 0) {\n    expectedCandidates.push(Number(j.totalSlides));\n  }\n\n  const nestedData = Array.isArray(j.data) ? j.data : [];\n  for (const row of nestedData) {\n    const rowJson = row?.json || row || {};\n    collectUrls(rowJson, allImageUrls);\n\n    if (Number.isFinite(Number(rowJson.totalSlides)) && Number(rowJson.totalSlides) > 0) {\n      expectedCandidates.push(Number(rowJson.totalSlides));\n    }\n  }\n}\n\nconst uniqueUrls = [...new Set(allImageUrls)];\nlet expectedSlides = Array.isArray(carouselData.slides) ? carouselData.slides.length : 0;\nif (!expectedSlides && expectedCandidates.length) {\n  expectedSlides = Math.max(...expectedCandidates);\n}\nif (!expectedSlides) expectedSlides = 5;\n\nif (!uniqueUrls.length) {\n  const reason = failedRequests.length\n    ? (' fal.ai details: ' + failedRequests.map((f) => (f.request_id ? '[' + f.request_id + '] ' : '') + f.error).join(' | ').slice(0, 700))\n    : '';\n  throw new Error('No image URLs were returned from fal.ai.' + reason);\n}\n\nconst partialGeneration = uniqueUrls.length < expectedSlides;\nconst missingSlides = partialGeneration ? Math.max(0, expectedSlides - uniqueUrls.length) : 0;\n\nreturn [{ json: {\n  ...carouselData,\n  allImageUrls: uniqueUrls,\n  imageUrl: uniqueUrls[0] || '',\n  firstImageUrl: uniqueUrls[0] || '',\n  imageCount: uniqueUrls.length,\n  expectedSlides,\n  partialGeneration,\n  missingSlides,\n  failedRequests\n} }];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000021",
      "name": "Package Carousel Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2140,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingContent) staticData.pendingContent = {};\n\nconst data = $input.first().json;\nconst chatId = String(data.chatId);\n\nstaticData.pendingContent[chatId] = {\n  type: 'carousel',\n  title: data.title,\n  slides: data.slides,\n  hashtags: data.hashtags,\n  caption: data.caption,\n  allImageUrls: data.allImageUrls || [],\n  imageUrl: data.imageUrl,\n  firstImageUrl: data.firstImageUrl,\n  imageCount: data.imageCount,\n  chatId: data.chatId,\n  args: data.args,\n  timestamp: Date.now()\n};\n\nreturn [{ json: data }];\n\nif (!staticData.activeGenerationByChat) staticData.activeGenerationByChat = {};\ndelete staticData.activeGenerationByChat[chatId];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000022",
      "name": "Store Pending Carousel",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2140,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{`CAROUSEL READY FOR REVIEW\\n\\nTitle: ${$json.title || \"Untitled Carousel\"}\\nSlides: ${Array.isArray($json.slides) ? $json.slides.length : 0}\\nImages generated: ${$json.imageCount ?? 0}${$json.partialGeneration ? `\\nWarning: ${$json.missingSlides || 0} slide image(s) are missing due to model queue delays.` : \"\"}\\n\\nTap a button below: Approve to post, or Regenerate for a new version.`}}",
        "additionalFields": {
          "disableWebPagePreview": true
        },
        "replyMarkup": "inlineKeyboard",
        "inlineKeyboard": {
          "rows": [
            {
              "row": {
                "buttons": [
                  {
                    "text": "Approve",
                    "additionalFields": {
                      "callback_data": "/approve"
                    }
                  },
                  {
                    "text": "Regenerate",
                    "additionalFields": {
                      "callback_data": "/regenerate"
                    }
                  }
                ]
              }
            }
          ]
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000023",
      "name": "Send Carousel for Approval",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000023",
      "position": [
        2380,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "let data = $input.first().json || {};\n\n// When upstream is Telegram send-message output, recover the real carousel payload.\nif (!Array.isArray(data.allImageUrls) || data.allImageUrls.length === 0) {\n  try { data = $('Store Pending Carousel').first().json || data; } catch (e) {}\n}\nif (!Array.isArray(data.allImageUrls) || data.allImageUrls.length === 0) {\n  try { data = $('Package Carousel Data').first().json || data; } catch (e) {}\n}\n\nconst urls = Array.isArray(data.allImageUrls) ? data.allImageUrls.filter(Boolean) : [];\nif (!urls.length) {\n  throw new Error('No carousel image URLs found to send on Telegram.');\n}\n\nreturn urls.map((url, idx) => ({\n  json: {\n    chatId: data.chatId,\n    imageUrl: String(url),\n    slideIndex: idx + 1,\n    totalSlides: urls.length,\n    title: data.title || ''\n  }\n}));"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000024",
      "name": "Split Remaining Images",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2620,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "sendPhoto",
        "chatId": "={{ $json.chatId }}",
        "binaryData": true,
        "binaryPropertyName": "data",
        "additionalFields": {
          "caption": "={{`Slide ${$json.slideIndex || 1}/${$json.totalSlides || 1}${$json.title ? ` - ${$json.title}` : \"\"}`}}"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000025",
      "name": "Send Remaining Images",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000025",
      "position": [
        2860,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ 'https://api.elevenlabs.io/v1/text-to-speech/' + ($json.creatorVoiceId || 'GoLTMzQJAHarswiHqv3L') }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "xi-api-key",
              "value": "={{ $('TEST_KEYS').first().json.elevenLabsKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  text: ($json.fullNarration || \"Supporting cultural carers through the dementia journey.\"),\n  model_id: \"eleven_multilingual_v2\",\n  voice_settings: {\n    stability: 0.5,\n    similarity_boost: 0.75,\n    style: 0.4\n  }\n}) }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "audioFile"
            }
          }
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000026",
      "name": "ElevenLabs - Create Voiceover",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1180,
        400
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000
    },
    {
      "parameters": {
        "jsCode": "const videoData = $('Resolve Founder Portrait URL').first().json || $('Parse Video Response').first().json || {};\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n\\t]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction uniq(parts) {\n  const out = [];\n  const seen = new Set();\n  for (const p of parts) {\n    const t = clean(p);\n    if (!t) continue;\n    const k = t.toLowerCase();\n    if (seen.has(k)) continue;\n    seen.add(k);\n    out.push(t);\n  }\n  return out.join(', ');\n}\n\nfunction stripMetaLabels(text) {\n  let t = clean(text);\n  if (!t) return t;\n  t = t\n    .replace(/^(why this matters now|what changed|evidence update|what this means for carers|next step|key takeaway)\\s*[:\\-]\\s*/i, '')\n    .replace(/\\b(key takeaway)\\s*[:\\-].*$/i, '')\n    .trim();\n  return t;\n}\n\nfunction intentFromNarration(text) {\n  const t = stripMetaLabels(text);\n  return t || 'practical UK dementia-care guidance for carers';\n}\n\nfunction visualCore(raw) {\n  return clean(String(raw || '').split(/topic context:/i)[0]);\n}\n\nfunction stripIdentityDrift(text) {\n  return clean(text)\n    .replace(/\\bresembling[^,.;]*/ig, '')\n    .replace(/\\b(?:a|an)?\\s*(?:young|middle-aged|elderly)\\s+(?:man|woman|person)\\b/ig, '')\n    .replace(/\\b(?:man|woman)\\s+with\\s+[^,.;]*/ig, '')\n    .replace(/\\b(?:male|female)\\b/ig, '')\n    .replace(/\\b(?:blonde|red-haired|blue-eyed|green-eyed)\\b/ig, '')\n    .replace(/\\b(?:same man|same woman|different person)\\b/ig, '');\n}\n\nfunction hashSeed(str) {\n  const s = String(str || '');\n  let h = 0;\n  for (let i = 0; i < s.length; i++) {\n    h = ((h << 5) - h + s.charCodeAt(i)) | 0;\n  }\n  return Math.abs(h);\n}\n\nconst scenes = Array.isArray(videoData.allScenes) ? videoData.allScenes : [];\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.videoContinuityByChat) staticData.videoContinuityByChat = {};\nconst chatKey = String(videoData.chatId || staticData.defaultChatId || '');\n\nconst continuityDefaults = {\n  identityAnchor: 'same exact founder identity from reference image, match face geometry, skin tone, hairstyle, no identity drift',\n  wardrobeAnchor: 'wardrobe consistent across scenes, professional UK healthcare editorial clothing',\n  cameraAnchor: 'vertical 9:16, chest-up framing, eyes sharp, natural skin texture, documentary realism',\n  negative: 'no borders, no black bars, no letterboxing, no text, no captions, no logos, no watermark, no UI, no collage, no grid, no split-screen'\n};\n\nconst continuity = {\n  ...continuityDefaults,\n  ...(chatKey ? (staticData.videoContinuityByChat[chatKey] || {}) : {})\n};\nif (chatKey) staticData.videoContinuityByChat[chatKey] = continuity;\n\nconst settingByType = {\n  hook: 'quiet NHS clinic consult room or community health centre, soft daylight, calm tone',\n  scene: 'UK home-care planning moment at a kitchen table, practical props (calendar, leaflet, pill organiser), soft daylight',\n  cta: 'warm UK living room or community centre, hopeful closing moment, calm and reassuring'\n};\n\nconst motionByType = {\n  hook: 'gentle dolly-in, natural pacing',\n  scene: 'subtle handheld documentary motion, small natural gestures',\n  cta: 'slow cinematic push-in, calm finish'\n};\n\nconst shotByIndex = [\n  'vertical medium shot, camera at eye level',\n  'vertical close-up, subtle expression detail'\n];\n\nreturn scenes.map((scene, idx) => {\n  const sceneType = String(scene?.type || (idx === 0 ? 'hook' : (idx === scenes.length - 1 ? 'cta' : 'scene'))).toLowerCase();\n  const shot = shotByIndex[idx % shotByIndex.length];\n  const motion = motionByType[sceneType] || motionByType.scene;\n\n  const intent = intentFromNarration(scene?.narration || '');\n  const visualHint = stripIdentityDrift(visualCore(scene?.visualPrompt || ''));\n  const fallbackSetting = settingByType[sceneType] || settingByType.scene;\n\n  const framingLock = 'composition: subject centred, face in upper-middle (upper third), hands visible if possible, leave bottom 30% uncluttered for subtitles';\n\n  const videoPrompt = uniq([\n    'Photorealistic UK documentary scene: ' + intent,\n    visualHint || fallbackSetting,\n    continuity.identityAnchor,\n    continuity.wardrobeAnchor,\n    continuity.cameraAnchor,\n    framingLock,\n    motion,\n    shot,\n    continuity.negative\n  ]);\n\n  const sceneImagePrompt = uniq([\n    'Create a NEW photorealistic still frame (start image) for a vertical 9:16 short.',\n    'Same exact founder identity as reference images (strict).',\n    'Change the environment/background completely (do NOT keep the original portrait/studio background).',\n    'Scene: ' + (visualHint || fallbackSetting) + '. Must match the narration meaning: ' + intent,\n    continuity.identityAnchor,\n    continuity.wardrobeAnchor,\n    continuity.cameraAnchor,\n    framingLock,\n    'lighting: natural window light, neutral-warm grade, realistic skin texture',\n    'no other prominent people, no distorted hands, no extra fingers',\n    continuity.negative\n  ]);\n\n  const sceneSeed = hashSeed(String(videoData.title || '') + '|' + String(videoData.chatId || '') + '|' + String(idx));\n\n  return {\n    json: {\n      ...scene,\n      sceneIndex: idx,\n      totalScenes: scenes.length,\n      chatId: videoData.chatId,\n      title: videoData.title,\n      hashtags: videoData.hashtags,\n      caption: videoData.caption,\n      fullNarration: videoData.fullNarration,\n      creatorImageUrl: videoData.creatorImageUrl || '',\n      creatorImageUrls: Array.isArray(videoData.creatorImageUrls) ? videoData.creatorImageUrls : [],\n      creatorVoiceId: videoData.creatorVoiceId || 'GoLTMzQJAHarswiHqv3L',\n      continuityProfile: continuity,\n      videoPrompt,\n      sceneImagePrompt,\n      sceneSeed,\n    }\n  };\n});\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000027",
      "name": "Prepare Video Scenes",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1420,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($json.sceneImageUrl || $json.creatorImageUrl) ? 'https://queue.fal.run/fal-ai/kling-video/v3/standard/image-to-video' : 'https://queue.fal.run/fal-ai/kling-video/v3/standard/text-to-video' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Key ' + $('TEST_KEYS').first().json.falKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify(\n  ($json.sceneImageUrl || $json.creatorImageUrl)\n    ? {\n        start_image_url: ($json.sceneImageUrl || $json.creatorImageUrl),\n        prompt: ($json.videoPrompt || $json.visualPrompt || 'photorealistic UK dementia-care documentary scene, vertical 9:16, no borders'),\n        duration: String($json.duration || 15),\n        aspect_ratio: '9:16',\n        generate_audio: false\n      }\n    : {\n        prompt: ($json.videoPrompt || $json.visualPrompt || 'photorealistic UK dementia-care documentary scene, vertical 9:16, no borders'),\n        duration: String($json.duration || 15),\n        aspect_ratio: '9:16',\n        generate_audio: false\n      }\n) }}",
        "options": {
          "timeout": 900000
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000028",
      "name": "Kling v3 - Generate Clip",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1660,
        400
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst apiKey = String($('TEST_KEYS').first().json.falKey || '').trim();\nconst headers = { Authorization: 'Key ' + apiKey };\n\nconst pollIntervalMs = 1800;\nconst maxChecks = 400; // ~12 minutes\nconst maxWaitMs = 900000; // 15 min hard cap\nconst resultRetryCount = 40;\nconst transientCodes = new Set([404, 409, 422, 425, 429]);\n\nconst httpRequest =\n  (typeof $httpRequest === 'function' && $httpRequest) ||\n  (this && this.helpers && typeof this.helpers.httpRequest === 'function'\n    ? this.helpers.httpRequest.bind(this)\n    : null);\n\nif (!httpRequest) {\n  throw new Error('n8n HTTP helper is unavailable in this Code node runtime.');\n}\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction getStatusCode(err) {\n  const candidates = [\n    err?.statusCode,\n    err?.status,\n    err?.httpCode,\n    err?.response?.statusCode,\n    err?.response?.status\n  ];\n  for (const c of candidates) {\n    const n = Number(c);\n    if (Number.isFinite(n)) return n;\n  }\n\n  const msg = String(err?.message || '');\n  const m = msg.match(/status\\s*code\\s*(\\d{3})/i) || msg.match(/\\b(\\d{3})\\b/);\n  if (m?.[1]) {\n    const n = Number(m[1]);\n    if (Number.isFinite(n)) return n;\n  }\n  return null;\n}\n\nfunction safeJson(v, maxLen = 600) {\n  try {\n    const s = JSON.stringify(v);\n    if (!s) return '';\n    return s.length > maxLen ? s.slice(0, maxLen) + '...' : s;\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction errText(err) {\n  const base = String(err?.message || err || 'unknown error');\n  const status = getStatusCode(err);\n  const body = safeJson(err?.response?.body || err?.body || err?.data || null);\n  return base + (status ? (' [status ' + status + ']') : '') + (body ? (' body=' + body) : '');\n}\n\nfunction readStatus(json) {\n  return String(\n    (json &&\n      (json.status ||\n        json.request_status ||\n        json.state ||\n        json.phase ||\n        (json.data && json.data.status))) ||\n      ''\n  ).toUpperCase();\n}\n\nfunction readQueuePos(json) {\n  const v = json?.queue_position ?? json?.data?.queue_position ?? null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction looksLikeVideoUrl(u) {\n  const s = String(u || '').trim();\n  if (!/^https?:\\/\\//i.test(s)) return false;\n  const lower = s.toLowerCase();\n  const bare = lower.split('?')[0].split('#')[0];\n  if (bare.endsWith('.mp4') || bare.endsWith('.mov') || bare.endsWith('.webm') || bare.endsWith('.m3u8')) return true;\n  if (lower.includes('fal.media/files/')) return true;\n  return false;\n}\n\nfunction pickVideoUrl(payload) {\n  const urls = [];\n  const seen = new Set();\n\n  function push(v) {\n    const u = String(v || '').trim();\n    if (!u || seen.has(u) || !looksLikeVideoUrl(u)) return;\n    seen.add(u);\n    urls.push(u);\n  }\n\n  function walk(node, depth = 0) {\n    if (node == null || depth > 7) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) walk(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      push(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    push(node.video?.url);\n    push(node.data?.video?.url);\n    push(node.output?.video?.url);\n    push(node.result?.video?.url);\n    push(node.response?.video?.url);\n    push(node.url);\n    push(node.video_url);\n    push(node.videoUrl);\n\n    walk(node.video, depth + 1);\n    walk(node.videos, depth + 1);\n    walk(node.data, depth + 1);\n    walk(node.output, depth + 1);\n    walk(node.result, depth + 1);\n    walk(node.response, depth + 1);\n\n    for (const v of Object.values(node)) {\n      if (v && typeof v === 'object') walk(v, depth + 1);\n    }\n  }\n\n  walk(payload);\n  return urls[0] || '';\n}\n\nasync function getJson(url) {\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function waitForOne(item) {\n  const inputJson = item.json || {};\n\n  // If already has a final video URL, just pass through.\n  const direct = pickVideoUrl(inputJson);\n  if (direct) {\n    return { json: { ...inputJson, videoUrl: direct, falStatus: inputJson.falStatus || 'COMPLETED_SYNC' } };\n  }\n\n  const requestId = inputJson.request_id || inputJson.requestId;\n  const statusUrl = clean(inputJson.status_url || inputJson.statusUrl);\n  const responseUrl = clean(inputJson.response_url || inputJson.responseUrl);\n\n  if (!requestId && !statusUrl && !responseUrl) {\n    return {\n      json: {\n        ...inputJson,\n        falStatus: 'ERROR',\n        falError: 'fal.ai submit did not return request_id/status_url/response_url.',\n      }\n    };\n  }\n\n  const startedAt = Date.now();\n  let attempts = 0;\n  let statusValue = '';\n  let lastQueuePosition = null;\n\n  while (attempts < maxChecks && (Date.now() - startedAt) < maxWaitMs) {\n    attempts++;\n\n    try {\n      const statusJson = await getJson(statusUrl || (requestId ? `https://queue.fal.run/fal-ai/kling-video/requests/${encodeURIComponent(requestId)}/status` : ''));\n      statusValue = readStatus(statusJson);\n      lastQueuePosition = readQueuePos(statusJson);\n    } catch (err) {\n      const code = getStatusCode(err);\n      if (!transientCodes.has(code)) {\n        return {\n          json: {\n            ...inputJson,\n            falStatus: 'ERROR',\n            falError: 'fal.ai status request failed: ' + errText(err),\n          }\n        };\n      }\n      statusValue = statusValue || 'IN_QUEUE';\n    }\n\n    if (statusValue === 'COMPLETED') {\n      // fal sometimes reports COMPLETED before the mp4 URL is fetchable.\n      // Try fetching the result; if the URL is missing, keep polling.\n      try {\n        const resultJson = await getJson(responseUrl || (requestId ? `https://queue.fal.run/fal-ai/kling-video/requests/${encodeURIComponent(requestId)}` : ''));\n        const videoUrl = pickVideoUrl(resultJson) || pickVideoUrl(inputJson);\n        if (videoUrl) {\n          return {\n            json: {\n              ...inputJson,\n              ...(resultJson && typeof resultJson === 'object' ? resultJson : {}),\n              videoUrl,\n              falStatus: 'COMPLETED',\n              falPollAttempts: attempts,\n            }\n          };\n        }\n      } catch (err) {\n        const code = getStatusCode(err);\n        if (!transientCodes.has(code)) {\n          return {\n            json: {\n              ...inputJson,\n              falStatus: 'ERROR',\n              falError: 'fal.ai result request failed: ' + errText(err),\n            }\n          };\n        }\n      }\n      // No URL yet; keep polling until maxWait.\n    }\n    if (['FAILED', 'ERROR', 'CANCELLED'].includes(statusValue)) {\n      return {\n        json: {\n          ...inputJson,\n          falStatus: statusValue,\n          falError: 'fal.ai request failed with status ' + statusValue,\n        }\n      };\n    }\n\n    const elapsed = Date.now() - startedAt;\n    const remaining = maxWaitMs - elapsed;\n    if (remaining <= 0) break;\n    await sleep(Math.min(pollIntervalMs, remaining));\n  }\n\n  // Fetch result\n  let resultJson = null;\n  for (let i = 0; i < resultRetryCount; i++) {\n    try {\n      resultJson = await getJson(responseUrl || (requestId ? `https://queue.fal.run/fal-ai/kling-video/requests/${encodeURIComponent(requestId)}` : ''));\n      break;\n    } catch (err) {\n      const code = getStatusCode(err);\n      if (!transientCodes.has(code)) {\n        return {\n          json: {\n            ...inputJson,\n            falStatus: 'ERROR',\n            falError: 'fal.ai result request failed: ' + errText(err),\n          }\n        };\n      }\n      await sleep(Math.min(1200 + i * 400, 3500));\n    }\n  }\n\n  const videoUrl = pickVideoUrl(resultJson) || pickVideoUrl(inputJson);\n  if (!videoUrl) {\n    const seconds = Math.max(1, Math.round((Date.now() - startedAt) / 1000));\n    return {\n      json: {\n        ...inputJson,\n        ...((resultJson && typeof resultJson === 'object') ? resultJson : {}),\n        falStatus: statusValue || 'UNKNOWN',\n        falPollAttempts: attempts,\n        falError:\n          'kling video not ready or no mp4 URL yet after ' + attempts + ' checks (~' + seconds + 's), status=' + (statusValue || 'IN_QUEUE') +\n          ', queue_position=' + (lastQueuePosition == null ? 'n/a' : lastQueuePosition)\n      }\n    };\n  }\n\n  return {\n    json: {\n      ...inputJson,\n      ...(resultJson && typeof resultJson === 'object' ? resultJson : {}),\n      videoUrl,\n      falStatus: statusValue || 'COMPLETED',\n      falPollAttempts: attempts,\n    }\n  };\n}\n\n\nasync function runWithLimit(arr, limit, fn) {\n  const results = new Array(arr.length);\n  let cursor = 0;\n  let lastErr = null;\n\n  async function worker() {\n    while (true) {\n      const i = cursor++;\n      if (i >= arr.length) return;\n      try {\n        results[i] = await fn(arr[i]);\n      } catch (e) {\n        lastErr = e;\n        results[i] = { json: { ...(arr[i]?.json || {}), falStatus: 'ERROR', falError: String(e.message || e) } };\n      }\n    }\n  }\n\n  const workers = [];\n  const w = Math.max(1, Math.min(limit, arr.length));\n  for (let i = 0; i < w; i++) workers.push(worker());\n  await Promise.all(workers);\n\n  return { results, lastErr };\n}\n\n// Kling O3 clips can take ~6-7 minutes each. Sequential waiting can exceed\n// n8n Cloud timeouts. Run waits concurrently.\nconst { results, lastErr } = await runWithLimit(items, 3, waitForOne);\n\nconst anyVideo = results.some((o) => looksLikeVideoUrl(o?.json?.videoUrl) || pickVideoUrl(o?.json));\nif (!anyVideo && lastErr) {\n  throw lastErr;\n}\n\nreturn results;\n"
      },
      "id": "await-kling-video-result-v1",
      "name": "fal.ai - Await Clip Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1820,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000029",
      "name": "Collect All Clips",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1900,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Package a lightweight video job for GitHub Actions.\n// All heavy generation (scene images + Kling clips) is done in GitHub Actions to avoid n8n Cloud timeouts.\n\nconst items = $input.all();\nconst parseVideoData = $('Parse Video Response').first().json || {};\nconst first = items[0]?.json || {};\n\nconst dataArr = Array.isArray(first.data) ? first.data : [];\n\nfunction clean(s) {\n  return String(s ?? '').replace(/\\s+/g, ' ').trim();\n}\n\nfunction pick(...vals) {\n  for (const v of vals) {\n    const t = clean(v);\n    if (t) return t;\n  }\n  return '';\n}\n\nfunction asNumber(v, fallback) {\n  const n = Number(v);\n  return Number.isFinite(n) && n > 0 ? n : fallback;\n}\n\n// Scenes coming from Prepare Video Scenes contain videoPrompt + sceneImagePrompt.\nconst scenes = (dataArr.length ? dataArr : (Array.isArray(parseVideoData.allScenes) ? parseVideoData.allScenes : [])).map((s, idx) => {\n  const duration = asNumber(s?.duration, 15);\n  return {\n    narration: pick(s?.narration, s?.text),\n    visualPrompt: pick(s?.visualPrompt, s?.imagePrompt, s?.prompt),\n    type: pick(s?.type, idx === 0 ? 'hook' : (idx === 1 ? 'cta' : 'scene')),\n    duration,\n    index: Number.isFinite(Number(s?.index)) ? Number(s.index) : idx,\n\n    // Added by Prepare Video Scenes\n    videoPrompt: pick(s?.videoPrompt, s?.visualPrompt),\n    sceneImagePrompt: pick(s?.sceneImagePrompt, s?.visualPrompt),\n\n    // Identity anchors\n    creatorImageUrl: pick(s?.creatorImageUrl, parseVideoData.creatorImageUrl),\n    creatorImageUrls: Array.isArray(s?.creatorImageUrls) ? s.creatorImageUrls : (Array.isArray(parseVideoData.creatorImageUrls) ? parseVideoData.creatorImageUrls : []),\n  };\n});\n\nconst title = pick(parseVideoData.title, first.title, 'Untitled Video');\nconst chatId = pick(parseVideoData.chatId, first.chatId);\nconst args = pick(parseVideoData.args, first.args);\nconst hashtags = Array.isArray(parseVideoData.hashtags) ? parseVideoData.hashtags : (Array.isArray(first.hashtags) ? first.hashtags : []);\nconst caption = pick(parseVideoData.caption, first.caption);\nconst fullNarration = pick(parseVideoData.fullNarration, first.fullNarration, scenes.map(s => clean(s.narration)).filter(Boolean).join(' '));\n\nconst creatorVoiceId = pick(parseVideoData.creatorVoiceId, first.creatorVoiceId, 'GoLTMzQJAHarswiHqv3L');\n\nconst creatorImageUrl = pick(\n  scenes[0]?.creatorImageUrl,\n  parseVideoData.creatorImageUrl,\n  first.creatorImageUrl\n);\n\nconst creatorImageUrls = (Array.isArray(scenes[0]?.creatorImageUrls) && scenes[0].creatorImageUrls.length)\n  ? scenes[0].creatorImageUrls\n  : (Array.isArray(parseVideoData.creatorImageUrls) ? parseVideoData.creatorImageUrls : []);\n\nconst out = {\n  type: 'video',\n  title,\n  hashtags,\n  caption,\n  chatId,\n  args,\n\n  // Clip generation is handled in GitHub Actions; these are optional.\n  clipUrls: [],\n  clipRequests: [],\n  clipCount: scenes.length,\n\n  scenes,\n  fullNarration,\n  narrationText: fullNarration,\n  creatorVoiceId,\n  creatorImageUrl,\n  creatorImageUrls,\n\n  status: 'queued'\n};\n\n// Clear active-generation lock for this chat (best-effort)\ntry {\n  const chatKey = String(chatId || '');\n  const staticData = $getWorkflowStaticData('global');\n  if (staticData?.activeGenerationByChat && chatKey) delete staticData.activeGenerationByChat[chatKey];\n} catch (e) {}\n\nreturn [{ json: out }];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000030",
      "name": "Package Video Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2140,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Prepare payload for GitHub rendering.\n// Renderer can synthesize audio from narrationText + voiceId if audioUrl is empty.\nconst data = $input.first().json || {};\n\nlet hasVoiceoverBinary = false;\ntry {\n  const audioBinary = $('ElevenLabs - Create Voiceover').first().binary;\n  hasVoiceoverBinary = Boolean(audioBinary?.audioFile?.data);\n} catch (e) {\n  hasVoiceoverBinary = false;\n}\n\nreturn [{\n  json: {\n    ...data,\n    audioUrl: String(data.audioUrl || '').trim(),\n    narrationText: String(data.narrationText || data.fullNarration || '').trim(),\n    creatorVoiceId: String(data.creatorVoiceId || 'GoLTMzQJAHarswiHqv3L').trim(),\n    hasVoiceoverBinary\n  }\n}];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000031",
      "name": "Prepare Render Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2380,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.github.com/repos/dignitatesocial/dignitatevideo/dispatches",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.githubPat }}"
            },
            {
              "name": "Accept",
              "value": "application/vnd.github.v3+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  event_type: 'render-video',\n  client_payload: {\n    job: {\n      clipUrls: $json.clipUrls || [],\n      clipRequests: $json.clipRequests || [],\n      creatorImageUrl: $json.creatorImageUrl || '',\n      creatorImageUrls: $json.creatorImageUrls || [],\n      audioUrl: $json.audioUrl || '',\n      narrationText: $json.narrationText || $json.fullNarration || '',\n      voiceId: $json.creatorVoiceId || 'GoLTMzQJAHarswiHqv3L',\n      scenes: $json.scenes,\n      title: $json.title,\n      chatId: String($json.chatId),\n      n8nWebhookUrl: 'https://dignitate.app.n8n.cloud/webhook/dignitate-remotion-callback',\n      renderConfig: {\n        aspectRatio: '9:16',\n        subtitles: {\n          enabled: true,\n          mode: 'word-highlight',\n          placement: 'bottom-center',\n          maxWordsOnScreen: 8\n        },\n        animation: {\n          preset: 'smooth-cinematic',\n          transition: 'crossfade',\n          sceneMotion: 'subtle-zoom'\n        },\n        branding: {\n          style: 'dignitate-teal-logo',\n          enabled: true\n        }\n      },\n      postMeta: {\n        hashtags: $json.hashtags,\n        caption: $json.caption\n      }\n    }\n  }\n}) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000032",
      "name": "Trigger GitHub Actions",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 5000,
      "position": [
        2620,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "chatId": "={{ $('Package Video Data').first().json.chatId }}",
        "text": "={{`Assembling your video with Remotion...\\n\\nTitle: ${$('Package Video Data').first().json.title || 'Untitled Video'}\\nClips: ${$('Package Video Data').first().json.clipCount || 0}\\nVoice: ${($('Package Video Data').first().json.creatorVoiceId || '') ? 'configured' : 'default'}\\nPortrait source: ${$('Package Video Data').first().json.founderPortraitSource || 'n/a'}\\nSubtitles: Word-by-word highlight\\nBranding: Dignitate teal + logo\\n\\nThis takes about 10-20 minutes (clip generation + render). You will receive the finished MP4 automatically.`}}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000060",
      "name": "Video - Rendering Status",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000060",
      "position": [
        2860,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "const staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingContent) staticData.pendingContent = {};\n\nconst commandData = $('Load Chat History').first().json;\nconst chatId = String(commandData.chatId);\nconst pending = staticData.pendingContent[chatId];\n\nif (!pending) {\n  return [{ json: { chatId: commandData.chatId, error: true, message: 'No pending content found. Generate content first with /carousel or /video.' } }];\n}\n\nconst contentData = { ...pending };\ndelete staticData.pendingContent[chatId];\n\nreturn [{ json: { ...contentData, chatId: commandData.chatId, approved: true } }];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000033",
      "name": "Handle Approval",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        -200
      ]
    },
    {
      "parameters": {
        "jsCode": "const staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingContent) staticData.pendingContent = {};\n\nconst commandData = $('Load Chat History').first().json;\nconst chatId = String(commandData.chatId);\nconst pending = staticData.pendingContent[chatId];\n\nif (!pending) {\n  return [{ json: { chatId: commandData.chatId, error: true, message: 'No pending content found. Generate content first with /carousel or /video.' } }];\n}\n\nconst contentData = { ...pending };\ndelete staticData.pendingContent[chatId];\n\nreturn [{ json: { ...contentData, chatId: commandData.chatId, regenerate: true } }];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000034",
      "name": "Handle Regeneration",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        -400
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "carousel",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Carousel"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "video",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Video"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000035",
      "name": "Content Type Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        240,
        -200
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "carousel",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Carousel"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "video",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Video"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000036",
      "name": "Regen Type Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        240,
        -400
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "Carousel approved! Posting to social media now...",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000037",
      "name": "Approval Confirmed",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000037",
      "position": [
        460,
        -280
      ]
    },
    {
      "parameters": {
        "jsCode": "function clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction stripPrefixes(text) {\n  return clean(text)\n    .replace(/^why this matters now:\\s*/i, '')\n    .replace(/^what changed:\\s*/i, '')\n    .replace(/^evidence update:\\s*/i, '')\n    .replace(/^what this means for carers:\\s*/i, '')\n    .replace(/^what carers can do next:\\s*/i, '')\n    .trim();\n}\n\nfunction uniqHashtags(list) {\n  const out = [];\n  const seen = new Set();\n  for (const raw of (Array.isArray(list) ? list : [])) {\n    let h = clean(raw);\n    if (!h) continue;\n    if (!h.startsWith('#')) h = '#' + h;\n    const key = h.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push(h);\n  }\n  return out;\n}\n\nconst input = $input.first().json || {};\nlet data = { ...input };\n\n// After Telegram confirmation nodes, payload can be replaced by Telegram API response.\n// Recover canonical approved content from Handle Approval when needed.\nconst looksLikeTelegramOnly = !data.title && !data.caption && !Array.isArray(data.slides) && !data.imageUrl;\nif (looksLikeTelegramOnly) {\n  try {\n    const approved = $('Handle Approval').first().json || {};\n    data = { ...approved };\n  } catch (e) {}\n}\n\nconst title = clean(data.title || data.args || 'Dementia Care Update');\nconst slides = Array.isArray(data.slides) ? data.slides : [];\nconst allImageUrls = Array.isArray(data.allImageUrls) ? data.allImageUrls.filter(Boolean) : [];\nconst imageUrl = clean(data.imageUrl || allImageUrls[0] || '');\nconst chatId = data.chatId;\nconst type = clean(data.type || 'carousel').toLowerCase();\n\nlet hashtags = uniqHashtags(data.hashtags || []);\nif (!hashtags.length) {\n  hashtags = ['#DementiaCare', '#CarerSupport', '#UKHealth', '#Dignitate'];\n}\n\nlet baseCaption = clean(data.caption || '');\nif (!baseCaption) {\n  baseCaption = 'Evidence-led update for carers with practical next steps and clear takeaways.';\n}\n\nconst keyPoints = slides\n  .map((s) => stripPrefixes(s?.text || s?.caption || ''))\n  .filter(Boolean)\n  .slice(0, 5);\n\nconst pointLines = keyPoints.map((p) => '- ' + p);\n\nconst defaultIntro = 'A practical update from Dignitate for carers and families navigating dementia support.';\nconst intro = baseCaption || defaultIntro;\n\nconst instagramCaption = [\n  title,\n  intro,\n  pointLines.length ? 'Key points:\\n' + pointLines.join('\\n') : '',\n  'Save and share with carers who need clear, practical guidance.',\n  hashtags.join(' ')\n].filter(Boolean).join('\\n\\n').slice(0, 2100);\n\nconst linkedinText = [\n  title,\n  intro,\n  pointLines.length ? 'Highlights:\\n' + pointLines.join('\\n') : '',\n  'Dignitate shares evidence-led dementia content to support cultural carers and families across the UK.',\n  hashtags.slice(0, 8).join(' ')\n].filter(Boolean).join('\\n\\n').slice(0, 2900);\n\nconst xCore = [\n  title,\n  keyPoints[0] ? keyPoints[0] : intro,\n  'Practical next steps for carers in the full carousel.'\n].filter(Boolean).join(' ');\nconst xTags = hashtags.slice(0, 3).join(' ');\nconst xText = (xCore + (xTags ? (' ' + xTags) : '')).slice(0, 275);\n\nreturn [{\n  json: {\n    chatId,\n    type,\n    title,\n    caption: baseCaption,\n    hashtags,\n    allImageUrls,\n    imageUrl,\n    slides,\n    instagramCaption,\n    linkedinText,\n    xText\n  }\n}];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000038",
      "name": "Prepare Post Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        -280
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v1/actions/INSTAGRAM_CREATE_MEDIA_CONTAINER/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ connectedAccountId: 'ac_KNBQIWjdvioh', input: { image_url: $('Prepare Post Data').first().json.imageUrl, image_urls: $('Prepare Post Data').first().json.allImageUrls, allImageUrls: $('Prepare Post Data').first().json.allImageUrls, caption: $('Prepare Post Data').first().json.instagramCaption || '', is_carousel: true, media_type: 'CAROUSEL' } }) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000039",
      "name": "Composio - Instagram",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        940,
        -280
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v1/actions/LINKEDIN_CREATE_POST/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ connectedAccountId: 'ac_T2GUOXxT7_hq', input: { text: $('Prepare Post Data').first().json.linkedinText || '', media_url: $('Prepare Post Data').first().json.imageUrl } }) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000040",
      "name": "Composio - LinkedIn",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1180,
        -280
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v1/actions/TWITTER_CREATE_TWEET/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ connectedAccountId: 'ac_lrFu5_tsVghC', input: { text: $('Prepare Post Data').first().json.xText || '', media_url: $('Prepare Post Data').first().json.imageUrl } }) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000041",
      "name": "Composio - X/Twitter",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1420,
        -280
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const postData = $('Prepare Post Data').first().json;\nlet igStatus = 'Failed';\nlet liStatus = 'Failed';\nlet twStatus = 'Failed';\n\ntry {\n  const igResult = $('Composio - Instagram').first().json;\n  if (igResult && !igResult.error) igStatus = 'Posted';\n} catch(e) {}\n\ntry {\n  const liResult = $('Composio - LinkedIn').first().json;\n  if (liResult && !liResult.error) liStatus = 'Posted';\n} catch(e) {}\n\ntry {\n  const twResult = $('Composio - X/Twitter').first().json;\n  if (twResult && !twResult.error) twStatus = 'Posted';\n} catch(e) {}\n\nconst allSucceeded = igStatus === 'Posted' && liStatus === 'Posted' && twStatus === 'Posted';\nconst noneSucceeded = igStatus === 'Failed' && liStatus === 'Failed' && twStatus === 'Failed';\n\nlet summary;\nif (allSucceeded) {\n  summary = 'CAROUSEL POSTED SUCCESSFULLY!\\n\\nInstagram: ' + igStatus + '\\nLinkedIn: ' + liStatus + '\\nX/Twitter: ' + twStatus + '\\n\\nLive on all platforms!';\n} else if (noneSucceeded) {\n  summary = 'POSTING FAILED\\n\\nInstagram: ' + igStatus + '\\nLinkedIn: ' + liStatus + '\\nX/Twitter: ' + twStatus + '\\n\\nPlease check API credentials and try again.';\n} else {\n  summary = 'POSTING PARTIALLY COMPLETE\\n\\nInstagram: ' + igStatus + '\\nLinkedIn: ' + liStatus + '\\nX/Twitter: ' + twStatus + '\\n\\nSome platforms may need attention.';\n}\n\nreturn [{ json: { chatId: postData.chatId, message: summary } }];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000042",
      "name": "Check Post Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1660,
        -280
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000043",
      "name": "Post Results Message",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000043",
      "position": [
        1900,
        -280
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "Regenerating carousel content with a fresh script...",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000048",
      "name": "Regeneration Started",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000048",
      "position": [
        460,
        -480
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "Regenerating video content with a fresh script...",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000049",
      "name": "Video Regen Started",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000049",
      "position": [
        460,
        -340
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId || $('Load Chat History').first().json.chatId }}",
        "text": "={{(() => {\n  const j = $json || {};\n  const detail = j.error?.message || j.error?.description || j.error?.details || j.body?.detail || j.detail || j.message || (typeof j.error === 'string' ? j.error : '') || 'An unexpected error occurred. Please try again.';\n  const slideInfo = (j.slideIndex !== undefined && j.totalSlides !== undefined) ? `\\nSlide: ${Number(j.slideIndex) + 1}/${j.totalSlides}` : '';\n  return `Error: Something went wrong.\\n\\n${String(detail).slice(0, 700)}${slideInfo}\\n\\nTry running the command again or use /status to check bot health.`;\n})()}}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000050",
      "name": "Error Notification",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "webhookId": "a0b1c2d3-e4f5-6789-abcd-w00000000050",
      "position": [
        940,
        1100
      ]
    },
    {
      "parameters": {
        "jsCode": "const staticData = $getWorkflowStaticData('global');\nif (!staticData.autoScheduleByChat) staticData.autoScheduleByChat = {};\nif (!staticData.pendingAutoActionByChat) staticData.pendingAutoActionByChat = {};\n\nconst nowMs = Date.now();\n\nfor (const key of Object.keys(staticData.autoScheduleByChat)) {\n  const cfg = staticData.autoScheduleByChat[key] || {};\n  staticData.autoScheduleByChat[key] = {\n    ...cfg,\n    enabled: false,\n    updatedAt: nowMs,\n  };\n}\n\nfor (const key of Object.keys(staticData.pendingAutoActionByChat)) {\n  staticData.pendingAutoActionByChat[key] = '';\n}\n\nreturn [];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000051",
      "name": "Scheduled Trends Prep",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -464,
        700
      ]
    },
    {
      "parameters": {
        "jsCode": "// Deterministic slash parser for button-first trend flow + generation lock\nconst data = $input.first().json || {};\nconst rawMessage = String(data.message || '').trim();\nconst replyToText = String(data.replyToText || '').trim();\nconst sourceMessageText = String(data.sourceMessageText || '').trim();\n\nlet actionType = 'none';\nlet args = '';\nlet command = '';\nlet directArgs = '';\nlet topicSource = 'none';\nlet customReply = '';\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction normalizeTopic(s) {\n  let t = clean(s);\n  for (let i = 0; i < 3; i++) {\n    const first = t.charAt(0);\n    const last = t.charAt(t.length - 1);\n    const pairs = { '\"': '\"', \"'\": \"'\", '(': ')', '[': ']', '{': '}' };\n    if (pairs[first] && pairs[first] === last) t = clean(t.slice(1, -1));\n  }\n  return t;\n}\n\nfunction extractTopicFromTrendMessage(text, cmd) {\n  const t = String(text || '').trim();\n  if (!t) return '';\n\n  const cmdRe = new RegExp('^\\\\s*' + cmd.replace('/', '\\\\/') + '\\\\s+(.+)$', 'im');\n  const cmdMatch = t.match(cmdRe);\n  if (cmdMatch?.[1]) return normalizeTopic(cmdMatch[1]);\n\n  const trendingMatch = t.match(/Trending Topic(?:\\s+\\d+\\/\\d+)?\\s*:\\s*[\\r\\n]+([^\\n\\r]+)/i);\n  if (trendingMatch?.[1]) return normalizeTopic(trendingMatch[1]);\n\n  const lines = t.split(/\\r?\\n/).map((x) => x.trim()).filter(Boolean);\n  if (!lines.length) return '';\n  const idx = lines.findIndex((x) => /^Trending Topic/i.test(x));\n  if (idx >= 0 && lines[idx + 1]) return normalizeTopic(lines[idx + 1]);\n\n  return '';\n}\n\nconst slash = rawMessage.match(/^\\/([a-z0-9_]+)(?:@[A-Za-z0-9_]+)?(?:\\s+([\\s\\S]+))?$/i);\nif (slash) {\n  command = '/' + String(slash[1] || '').toLowerCase();\n  directArgs = normalizeTopic(String(slash[2] || ''));\n} else if (rawMessage.startsWith('/')) {\n  command = rawMessage.split(/\\s+/)[0].toLowerCase();\n}\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.userMemory) staticData.userMemory = {};\nif (!staticData.pendingAutoActionByChat) staticData.pendingAutoActionByChat = {};\nif (!staticData.lastManualCommandAtByChat) staticData.lastManualCommandAtByChat = {};\nif (!staticData.globalSuggestedTopic) staticData.globalSuggestedTopic = '';\nif (!staticData.activeGenerationByChat) staticData.activeGenerationByChat = {};\nif (!staticData.recentTapByChat) staticData.recentTapByChat = {};\nif (!staticData.recentCallbackIdsByChat) staticData.recentCallbackIdsByChat = {};\n\nconst now = Date.now();\nconst LOCK_MS = 10 * 60 * 1000;\nconst chatKey = String(data.chatId || '');\nconst defaultChatKey = String(staticData.defaultChatId || '');\nconst memoryKey = chatKey || defaultChatKey;\nconst lockKey = chatKey || memoryKey;\nconst pick = (...vals) => vals.map((v) => normalizeTopic(v)).find(Boolean) || '';\nconst isCallbackTap = Boolean(sourceMessageText || data.sourceMessageId || data.callbackQueryId);\nconst callbackQueryId = String(data.callbackQueryId || '').trim();\n\nif (lockKey && isCallbackTap) {\n  const CALLBACK_TTL_MS = 30 * 60 * 1000;\n  const cbSeen = staticData.recentCallbackIdsByChat[lockKey] || {};\n  for (const [k, ts] of Object.entries(cbSeen)) {\n    if ((Date.now() - Number(ts || 0)) > CALLBACK_TTL_MS) delete cbSeen[k];\n  }\n\n  if (callbackQueryId && cbSeen[callbackQueryId]) {\n    return [];\n  }\n\n  if (callbackQueryId) cbSeen[callbackQueryId] = Date.now();\n  staticData.recentCallbackIdsByChat[lockKey] = cbSeen;\n}\n\nconst active = staticData.activeGenerationByChat[lockKey];\nif (active && (now - Number(active.startedAt || 0) > LOCK_MS)) {\n  delete staticData.activeGenerationByChat[lockKey];\n}\n\nif (slash) {\n  const map = {\n    '/carousel': 'carousel',\n    '/video': 'video',\n    '/trends': 'trends',\n    '/status': 'status',\n    '/approve': 'approve',\n    '/regenerate': 'regenerate',\n    '/help': 'help',\n    '/stop': 'stop',\n    '/cancel': 'stop',\n    '/auto': 'none',\n    '/commands': 'none',\n    '/cmds': 'none',\n    '/creator': 'none',\n    '/setface': 'none',\n    '/setvoiceid': 'none'\n  };\n  actionType = map[command] || 'none';\n  args = directArgs;\n  if (args && ['carousel', 'video'].includes(actionType)) topicSource = 'direct';\n}\n\nif (actionType === 'stop') {\n  if (lockKey) delete staticData.activeGenerationByChat[lockKey];\n  if (chatKey) staticData.pendingAutoActionByChat[chatKey] = '';\n  actionType = 'none';\n  args = '';\n  topicSource = 'stop';\n  customReply = 'Stopped. I cleared the active generation lock for this chat. You can send /carousel <topic> or /video <topic> again.';\n}\n\nconst fallbackTopic = pick(\n  staticData.pendingTrendTopicByChat[memoryKey],\n  staticData.latestSuggestedTopicByChat[memoryKey],\n  staticData.lastTrendByChat[memoryKey],\n  staticData.userMemory[memoryKey]?.lastTopic,\n  staticData.globalSuggestedTopic\n);\n\nif (!args && ['carousel', 'video'].includes(actionType)) {\n  const replyTopic = extractTopicFromTrendMessage(replyToText, command || '/carousel');\n  if (replyTopic) {\n    args = replyTopic;\n    topicSource = 'reply';\n  }\n}\n\nif (!args && ['carousel', 'video'].includes(actionType) && sourceMessageText) {\n  const sourceTopic = extractTopicFromTrendMessage(sourceMessageText, command || '/carousel');\n  if (sourceTopic) {\n    args = sourceTopic;\n    topicSource = 'source_message';\n  }\n}\n\nif (!args && ['carousel', 'video'].includes(actionType)) {\n  args = fallbackTopic;\n  if (args && topicSource === 'none') topicSource = 'memory';\n}\n\n// Debounce repeated inline button taps for the same topic/message.\nif (['carousel', 'video'].includes(actionType) && lockKey && isCallbackTap) {\n  const tapSig = [\n    actionType,\n    String(data.sourceMessageId || data.messageId || ''),\n    normalizeTopic(args || '')\n  ].join('|');\n  const lastTap = staticData.recentTapByChat[lockKey];\n  const TAP_DEDUPE_MS = 10 * 60 * 1000;\n\n  if (lastTap && lastTap.sig === tapSig && (now - Number(lastTap.ts || 0) < TAP_DEDUPE_MS)) {\n    return [];\n  }\n\n  staticData.recentTapByChat[lockKey] = { sig: tapSig, ts: now };\n}\n\n// Prevent repeated taps/commands from spawning duplicate image generations.\nif (['carousel', 'video'].includes(actionType) && lockKey) {\n  const lock = staticData.activeGenerationByChat[lockKey];\n  if (lock && (now - Number(lock.startedAt || 0) < LOCK_MS)) {\n    const sameAction = String(lock.type || '') === String(actionType || '');\n    const sameSource = String(lock.sourceMessageId || '') === String(data.sourceMessageId || '');\n\n    if (isCallbackTap && sameAction && sameSource) {\n      return [];\n    }\n\n    const mins = Math.max(1, Math.ceil((LOCK_MS - (now - Number(lock.startedAt || 0))) / 60000));\n    actionType = 'none';\n    args = '';\n    topicSource = 'active_lock';\n    customReply = 'A ' + String(lock.type || 'content') + ' generation is already running for this chat. Please wait about ' + mins + ' minute(s), or send /stop to unlock immediately.';\n  }\n}\n\nlet autoAction = '';\nif (!args && ['carousel', 'video'].includes(actionType)) {\n  autoAction = actionType;\n  actionType = 'trends';\n  if (chatKey) staticData.pendingAutoActionByChat[chatKey] = autoAction;\n}\n\nif (args && ['carousel', 'video'].includes(actionType)) {\n  const writeKey = chatKey || memoryKey;\n  if (writeKey) {\n    staticData.userMemory[writeKey] = {\n      ...(staticData.userMemory[writeKey] || {}),\n      lastAction: actionType,\n      lastTopic: args,\n      updatedAt: now\n    };\n    staticData.pendingTrendTopicByChat[writeKey] = args;\n    staticData.latestSuggestedTopicByChat[writeKey] = args;\n    staticData.lastTrendByChat[writeKey] = args;\n    staticData.pendingAutoActionByChat[writeKey] = '';\n    staticData.activeGenerationByChat[writeKey] = {\n      type: actionType,\n      topic: args,\n      startedAt: now,\n      messageId: String(data.messageId || ''),\n      sourceMessageId: String(data.sourceMessageId || '')\n    };\n  }\n}\n\nif (chatKey && ['carousel', 'video', 'trends', 'approve', 'regenerate'].includes(actionType)) {\n  staticData.lastManualCommandAtByChat[chatKey] = now;\n}\n\nconst replies = {\n  carousel: args ? 'Great, I will create your carousel on: ' + args : 'I could not resolve a topic for carousel.',\n  video: args ? 'Great, I will create your video draft on: ' + args : 'I could not resolve a topic for video.',\n  trends: autoAction\n    ? 'I could not find a saved topic, so I am fetching fresh trends now and will start your ' + autoAction + ' automatically.'\n    : 'I am pulling broader, diverse dementia-care trends now.',\n  status: 'Everything is online and ready. I can create content whenever you are ready.',\n  approve: 'Perfect, I am approving your latest draft for posting now.',\n  regenerate: 'Understood, I am regenerating your latest draft with fresh research now.',\n  help: 'Tell me a topic and format, for example: /carousel dementia support in UK carers',\n  none: 'Tell me what you want to create and the topic, and I will take it from there.'\n};\n\nreturn [{\n  json: {\n    chatId: data.chatId,\n    messageId: data.messageId,\n    replyToText,\n    replyToMessageId: data.replyToMessageId || null,\n    args,\n    action: { type: actionType, topic: actionType === 'trends' ? '' : args },\n    autoAction,\n    topicSource,\n    explicitTopicProvided: Boolean(directArgs),\n    forcedTopic: directArgs || '',\n    replyText: customReply || replies[actionType] || replies.none,\n    command,\n    debugTopicSources: {\n      chatKey,\n      defaultChatKey,\n      memoryKey,\n      directArgs,\n      replyTopicCandidate: extractTopicFromTrendMessage(replyToText, command || '/carousel'),\n      sourceMessageTopicCandidate: extractTopicFromTrendMessage(sourceMessageText, command || '/carousel'),\n      fallbackTopic,\n      autoAction,\n      topicSource,\n      activeGeneration: staticData.activeGenerationByChat[lockKey] || null,\n      command\n    }\n  }\n}];\n"
      },
      "id": "conv-0001-0000-0000-000000000001",
      "name": "Quick Parse Slash",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        200
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"z-ai/glm-5\",\n  messages: ($json.aiMessagesJson ? (typeof $json.aiMessagesJson === \"string\" ? JSON.parse($json.aiMessagesJson) : $json.aiMessagesJson) : [])\n}) }}",
        "options": {}
      },
      "id": "conv-0001-0000-0000-000000000002",
      "name": "AI Conversation",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        0,
        500
      ],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2000,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response into reply + structured action, with deterministic intent fallback\nconst response = $input.first().json || {};\nconst chatData = $('Load Chat History').first().json;\nconst rawContent = response.choices?.[0]?.message?.content;\nconst content = Array.isArray(rawContent)\n  ? rawContent.map(c => c?.text || '').join('\\n')\n  : (rawContent || '{}');\n\nfunction safeJsonParse(text) {\n  const cleaned = String(text || '').replace(/```json\\n?/gi, '').replace(/```/g, '').trim();\n  try {\n    return JSON.parse(cleaned);\n  } catch (_) {\n    const start = cleaned.indexOf('{');\n    const end = cleaned.lastIndexOf('}');\n    if (start >= 0 && end > start) {\n      try { return JSON.parse(cleaned.slice(start, end + 1)); } catch (_) {}\n    }\n  }\n  return null;\n}\n\nconst parsed = safeJsonParse(content) || {\n  reply: String(content || '').trim() || 'Happy to help. Tell me what you want to create.',\n  action: { type: 'none', topic: '' }\n};\n\nconst allowed = new Set(['carousel', 'video', 'both', 'trends', 'approve', 'regenerate', 'status', 'help', 'none']);\nconst alias = {\n  trend: 'trends',\n  trending: 'trends',\n  publish: 'approve',\n  post: 'approve',\n  redo: 'regenerate',\n  retry: 'regenerate',\n  reel: 'video',\n  reels: 'video',\n  tiktok: 'video'\n};\n\nlet actionType = String(parsed?.action?.type || 'none').toLowerCase().trim();\nactionType = alias[actionType] || actionType;\nif (!allowed.has(actionType)) actionType = 'none';\n\nlet topic = typeof parsed?.action?.topic === 'string' ? parsed.action.topic.trim() : '';\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.userMemory) staticData.userMemory = {};\nconst chatKey = String(chatData.chatId || '');\nconst mem = staticData.userMemory[chatKey] || {};\nconst pending = staticData.pendingContent?.[chatKey] || {};\n\nconst rawUserText = String(chatData.message || '').trim();\nconst userText = rawUserText.toLowerCase();\nconst isSlash = rawUserText.startsWith('/');\n\nif (isSlash) {\n  const cmd = rawUserText.split(/\\s+/)[0].toLowerCase();\n  const cmdTopic = rawUserText.split(/\\s+/).slice(1).join(' ').trim();\n  const cmdMap = {\n    '/carousel': 'carousel',\n    '/video': 'video',\n    '/trends': 'trends',\n    '/approve': 'approve',\n    '/regenerate': 'regenerate',\n    '/status': 'status',\n    '/help': 'help',\n    '/commands': 'none',\n    '/cmds': 'none',\n    '/creator': 'none',\n    '/setface': 'none',\n    '/setvoiceid': 'none',\n    '/auto': 'none'\n  };\n  if (cmdMap[cmd]) {\n    actionType = cmdMap[cmd];\n    if (cmdTopic) topic = cmdTopic;\n    if (!topic && ['carousel','video'].includes(actionType)) {\n      topic = String(staticData.lastTrendByChat?.[chatKey] || '').trim();\n    }\n  }\n}\n\nif (actionType === 'none' && !isSlash) {\n  const wantsTrends = /(trend|trending|latest news|latest trends|what should .*post|what to post|news)/i.test(userText);\n  const wantsApprove = /(approve|post it|publish|go live|looks good,? post|ship it)/i.test(userText);\n  const wantsRegenerate = /(regenerate|redo|try again|another version|rewrite|new version)/i.test(userText);\n  const wantsStatus = /(status|are you online|bot status|system status|health check)/i.test(userText);\n  const wantsHelp = /(^help$|\\bhelp\\b|what can you do|how do you work|commands)/i.test(userText);\n  const wantsCarousel = /(carousel|carousels|slides|instagram post|instagram carousel)/i.test(userText);\n  const wantsVideo = /(video|reel|reels|tiktok|shorts?)/i.test(userText);\n\n  if (wantsTrends) actionType = 'trends';\n  else if (wantsApprove) actionType = 'approve';\n  else if (wantsRegenerate) actionType = 'regenerate';\n  else if (wantsStatus) actionType = 'status';\n  else if (wantsHelp) actionType = 'help';\n  else if (wantsCarousel && wantsVideo) actionType = 'both';\n  else if (wantsCarousel) actionType = 'carousel';\n  else if (wantsVideo) actionType = 'video';\n}\n\nconst confirmLike = /(\\byes\\b|\\bok\\b|\\bokay\\b|go ahead|do it|make it|sounds good|looks good)/i.test(userText);\nif (actionType === 'none' && confirmLike && ['carousel', 'video', 'both'].includes(mem.lastAction)) {\n  actionType = mem.lastAction;\n}\n\nif (!topic && ['carousel', 'video', 'both'].includes(actionType)) {\n  const aboutMatch = rawUserText.match(/\\b(?:about|on|for)\\s+(.+)$/i);\n  if (aboutMatch?.[1]) {\n    topic = aboutMatch[1].replace(/[.!?]+$/g, '').trim();\n  }\n}\nif (!topic && ['carousel', 'video', 'both'].includes(actionType) && isSlash) {\n  topic = String(mem.lastTopic || pending.args || staticData.lastTrendByChat?.[chatKey] || '').trim();\n}\n\nif (!topic && ['carousel', 'video', 'both'].includes(actionType) && !isSlash) {\n  actionType = 'none';\n}\n\nlet replyText = typeof parsed?.reply === 'string' ? parsed.reply.trim() : '';\nif (!replyText) {\n  replyText = actionType === 'none'\n    ? 'Happy to help. Tell me the topic and whether you want a carousel, a video, or both.'\n    : 'Perfect. I am starting that now.';\n}\nif (replyText.length > 500) {\n  replyText = replyText.slice(0, 480).trim() + '...';\n}\n\nif (actionType === 'none' && !isSlash && /(carousel|carousels|slides|instagram carousel|video|reel|reels|shorts?)/i.test(userText)) {\n  replyText = 'Great. What topic should I cover? For example: dementia early signs in UK families.';\n}\n\nif (rawUserText.startsWith('/carousel')) {\n  replyText = topic\n    ? `Great, I will research \"${topic}\" and build your carousel now.`\n    : 'Great, I will use the latest trend topic and build your carousel now.';\n} else if (rawUserText.startsWith('/video')) {\n  replyText = topic\n    ? `Great, I will research \"${topic}\" and start your video draft now.`\n    : 'Great, I will use the latest trend topic and start your video draft now.';\n} else if (rawUserText.startsWith('/trends')) {\n  replyText = 'I am pulling the latest UK dementia-care trends now.';\n}\n\nif (staticData.conversations && staticData.conversations[chatKey]) {\n  staticData.conversations[chatKey].messages.push({ role: 'assistant', content: replyText });\n  if (staticData.conversations[chatKey].messages.length > 12) {\n    staticData.conversations[chatKey].messages = staticData.conversations[chatKey].messages.slice(-12);\n  }\n}\n\nif (actionType !== 'none') {\n  staticData.userMemory[chatKey] = {\n    lastAction: actionType,\n    lastTopic: topic || mem.lastTopic || '',\n    updatedAt: Date.now()\n  };\n} else {\n  staticData.userMemory[chatKey] = {\n    lastAction: mem.lastAction || 'none',\n    lastTopic: mem.lastTopic || '',\n    updatedAt: Date.now()\n  };\n}\n\nreturn [{ json: {\n  chatId: chatData.chatId,\n  messageId: chatData.messageId,\n  replyText,\n  action: { type: actionType, topic },\n  args: topic || '',\n  command: ''\n} }];"
      },
      "id": "conv-0001-0000-0000-000000000003",
      "name": "Parse AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        240,
        500
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.replyText }}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "conv-0001-0000-0000-000000000004",
      "name": "Send AI Reply",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "webhookId": "conv-0001-0000-0000-w00000000004",
      "position": [
        480,
        500
      ],
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "carousel",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Carousel"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "video",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Video"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "both",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Both"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "trends",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Trends"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "approve",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Approve"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "regenerate",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Regenerate"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "status",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Status"
            },
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.action.type }}",
                    "rightValue": "help",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Help"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "conv-0001-0000-0000-000000000105",
      "name": "Action Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        720,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare args for carousel pipeline with strict explicit-topic preference\nconst data = $input.first().json || {};\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.userMemory) staticData.userMemory = {};\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction normalizeTopic(s) {\n  let t = clean(s);\n  for (let i = 0; i < 3; i++) {\n    const first = t.charAt(0);\n    const last = t.charAt(t.length - 1);\n    const pairs = { '\"': '\"', \"'\": \"'\", '(': ')', '[': ']', '{': '}' };\n    if (pairs[first] && pairs[first] === last) t = clean(t.slice(1, -1));\n  }\n  return t;\n}\n\nconst chatKey = String(data.chatId || '');\nconst defaultChatKey = String(staticData.defaultChatId || '');\nconst memoryKey = chatKey || defaultChatKey;\nconst pick = (...vals) => vals.map(v => normalizeTopic(v)).find(Boolean) || '';\n\nconst explicitFromSlash = pick(data.forcedTopic, data.debugTopicSources?.directArgs);\nlet args = pick(explicitFromSlash, data.action?.topic, data.args);\nlet topicSource = String(data.topicSource || '').trim();\n\nif (!args) {\n  args = pick(\n    staticData.pendingTrendTopicByChat[memoryKey],\n    staticData.latestSuggestedTopicByChat[memoryKey],\n    staticData.lastTrendByChat[memoryKey],\n    staticData.userMemory?.[memoryKey]?.lastTopic\n  );\n  if (args && !topicSource) topicSource = 'memory';\n}\n\nif (!topicSource) {\n  topicSource = explicitFromSlash ? 'direct' : (args ? 'resolved' : 'none');\n}\n\nconst topicLocked = Boolean(explicitFromSlash || data.explicitTopicProvided || topicSource === 'direct' || topicSource === 'message' || topicSource === 'reply');\n\nif (chatKey && args) {\n  staticData.userMemory[chatKey] = {\n    ...(staticData.userMemory[chatKey] || {}),\n    lastAction: 'carousel',\n    lastTopic: args,\n    updatedAt: Date.now()\n  };\n\n  staticData.pendingTrendTopicByChat[chatKey] = args;\n  staticData.latestSuggestedTopicByChat[chatKey] = args;\n  staticData.lastTrendByChat[chatKey] = args;\n}\n\nreturn [{\n  json: {\n    ...data,\n    args,\n    requestedTopic: args,\n    topicSource,\n    topicLocked,\n    chatId: data.chatId,\n    messageId: data.messageId\n  }\n}];"
      },
      "id": "conv-0001-0000-0000-000000000006",
      "name": "Prepare Carousel Args",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare args for video pipeline with strict explicit-topic preference + creator profile\nconst data = $input.first().json || {};\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.creatorProfileByChat) staticData.creatorProfileByChat = {};\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction normalizeTopic(s) {\n  let t = clean(s);\n  for (let i = 0; i < 3; i++) {\n    const first = t.charAt(0);\n    const last = t.charAt(t.length - 1);\n    const pairs = { '\"': '\"', \"'\": \"'\", '(': ')', '[': ']', '{': '}' };\n    if (pairs[first] && pairs[first] === last) t = clean(t.slice(1, -1));\n  }\n  return t;\n}\n\nfunction normalizeGithubRawUrl(u) {\n  const s = clean(u);\n  if (!s) return '';\n\n  // Convert GitHub blob URLs into raw.githubusercontent.com URLs.\n  // https://github.com/<owner>/<repo>/blob/<branch>/<path>\n  const m = s.match(/^https?:\\/\\/github\\.com\\/([^\\/]+)\\/([^\\/]+)\\/blob\\/([^\\/]+)\\/(.+)$/i);\n  if (m) {\n    const owner = m[1];\n    const repo = m[2];\n    const branch = m[3];\n    const path = m[4];\n    return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;\n  }\n\n  return s;\n}\n\nfunction isHttpUrl(v) {\n  return /^https?:\\/\\//i.test(clean(v));\n}\n\nfunction normalizeUrlList(list) {\n  if (!Array.isArray(list)) return [];\n  const out = [];\n  const seen = new Set();\n  for (const item of list) {\n    const u = normalizeGithubRawUrl(item);\n    if (!isHttpUrl(u)) continue;\n    const key = u.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push(u);\n  }\n  return out;\n}\n\nfunction hashToIndex(str, mod) {\n  const s = String(str || '');\n  let h = 0;\n  for (let i = 0; i < s.length; i++) {\n    h = ((h << 5) - h) + s.charCodeAt(i);\n    h |= 0;\n  }\n  const n = Math.abs(h);\n  return mod ? (n % mod) : 0;\n}\n\nconst chatKey = String(data.chatId || '');\nconst defaultChatKey = String(staticData.defaultChatId || '');\nconst memoryKey = chatKey || defaultChatKey;\nconst pick = (...vals) => vals.map(v => String(v || '').trim()).find(Boolean) || '';\n\nconst explicitFromSlash = normalizeTopic(data.forcedTopic || data.debugTopicSources?.directArgs || '');\nconst args = normalizeTopic(pick(\n  explicitFromSlash,\n  data.action?.topic,\n  data.args,\n  staticData.pendingTrendTopicByChat[memoryKey],\n  staticData.latestSuggestedTopicByChat[memoryKey],\n  staticData.lastTrendByChat[memoryKey]\n));\n\nconst defaultCreatorImageUrls = normalizeUrlList([\n  'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_casual.png',\n  'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_houndstooth.png',\n  'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_suit.png',\n  'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_shirt.png',\n  'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_layered.png'\n]);\n\nconst profile = staticData.creatorProfileByChat[chatKey] || staticData.creatorProfileByChat[defaultChatKey] || {};\n\nconst creatorImageUrls = normalizeUrlList(\n  data.creatorImageUrls\n) || [];\n\nconst profileFaceUrls = normalizeUrlList(profile.faceUrls);\nconst pool = (creatorImageUrls.length ? creatorImageUrls : (profileFaceUrls.length ? profileFaceUrls : defaultCreatorImageUrls));\n\nlet creatorImageUrl = normalizeGithubRawUrl(pick(data.creatorImageUrl, profile.faceUrl));\nif (!isHttpUrl(creatorImageUrl)) creatorImageUrl = '';\n\nif (!creatorImageUrl) {\n  const basis = (args || '') + '|' + (chatKey || defaultChatKey || '');\n  creatorImageUrl = pool[hashToIndex(basis, pool.length)] || '';\n}\n\nconst creatorVoiceId = pick(data.creatorVoiceId, profile.voiceId, 'GoLTMzQJAHarswiHqv3L');\n\nif (chatKey && args) {\n  staticData.pendingTrendTopicByChat[chatKey] = args;\n  staticData.latestSuggestedTopicByChat[chatKey] = args;\n  staticData.lastTrendByChat[chatKey] = args;\n}\n\nreturn [{\n  json: {\n    ...data,\n    args,\n    chatId: data.chatId,\n    messageId: data.messageId,\n    creatorImageUrl,\n    creatorImageUrls: pool,\n    creatorVoiceId,\n    creatorProfileSet: Boolean(creatorImageUrl || creatorVoiceId)\n  }\n}];\n"
      },
      "id": "conv-0001-0000-0000-000000000007",
      "name": "Prepare Video Args",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"perplexity/sonar-pro\",\n  messages: [\n    {\n      role: \"system\",\n      content: \"You are a UK dementia-care research analyst for Dignitate. Return strict JSON only. Keep one consistent topic and avoid speculation.\"\n    },\n    {\n      role: \"user\",\n      content:\n        \"Topic lock (do not change): \" + ($json.args || \"dementia caregiving support in the UK\") +\n        \"\\n\\nResearch this exact topic in the UK dementia care and carers context. Use recent and verifiable information (prefer 2024-2026 if available).\" +\n        \"\\nDo not invent numbers, dates, organizations, or claims.\" +\n        \"\\n\\nReturn strict JSON only with this schema:\" +\n        \"\\n{\" +\n        \"\\\"topic\\\":\\\"string\\\",\" +\n        \"\\\"summary\\\":\\\"6-8 sentence factual summary with one coherent storyline\\\",\" +\n        \"\\\"key_facts\\\":[{\\\"fact\\\":\\\"string\\\",\\\"source\\\":\\\"string\\\",\\\"date\\\":\\\"string\\\"}],\" +\n        \"\\\"carer_actions\\\":[\\\"string\\\",\\\"string\\\",\\\"string\\\",\\\"string\\\"],\" +\n        \"\\\"narrative_flow\\\":{\\\"slide1\\\":\\\"string\\\",\\\"slide2\\\":\\\"string\\\",\\\"slide3\\\":\\\"string\\\",\\\"slide4\\\":\\\"string\\\",\\\"slide5\\\":\\\"string\\\"},\" +\n        \"\\\"quality_checks\\\":{\\\"topic_match\\\":\\\"yes/no\\\",\\\"confidence\\\":\\\"high/medium/low\\\"}\" +\n        \"}\" +\n        \"\\n\\nRequirements:\" +\n        \"\\n- key_facts must contain 5 to 8 items.\" +\n        \"\\n- Every fact should include source and date text.\" +\n        \"\\n- Keep all facts on the same topic.\" +\n        \"\\n- carer_actions must contain 4 to 6 practical actions for carers in the UK.\" +\n        \"\\n- If evidence is limited, say so explicitly in summary.\"\n    }\n  ]\n}) }}",
        "options": {}
      },
      "id": "research-0001-0000-0000-000000000001",
      "name": "Research for Carousel",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1180,
        160
      ],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2000,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse and normalize carousel research as structured data\nconst response = $input.first().json || {};\nconst content = response.choices?.[0]?.message?.content;\nconst rawText = Array.isArray(content)\n  ? content.map((c) => c?.text || '').join('\\n')\n  : String(content || response.output_text || response.text || '').trim();\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction parseJsonLoose(text) {\n  const t = String(text || '').trim();\n  if (!t) return null;\n\n  const stripped = t\n    .replace(/^\\x60\\x60\\x60json\\s*/i, '')\n    .replace(/^\\x60\\x60\\x60\\s*/i, '')\n    .replace(/\\x60\\x60\\x60$/i, '')\n    .trim();\n\n  try { return JSON.parse(stripped); } catch (e) {}\n\n  const start = stripped.indexOf('{');\n  const end = stripped.lastIndexOf('}');\n  if (start >= 0 && end > start) {\n    const mid = stripped.slice(start, end + 1);\n    try { return JSON.parse(mid); } catch (e) {}\n  }\n\n  return null;\n}\n\nlet carouselArgs = {};\ntry {\n  carouselArgs = $('Prepare Carousel Args').first().json || {};\n} catch (e) {\n  try { carouselArgs = $('Regeneration Started').first().json || {}; } catch (e2) {}\n}\n\nconst parsed = parseJsonLoose(rawText) || {};\nconst requestedTopic = clean(carouselArgs.args || parsed.topic || 'dementia caregiving support in the UK');\n\nconst rawFacts = Array.isArray(parsed.key_facts) ? parsed.key_facts : [];\nconst researchFacts = rawFacts\n  .map((f) => ({\n    fact: clean(f?.fact || f?.statement || f?.text || ''),\n    source: clean(f?.source || ''),\n    date: clean(f?.date || f?.year || '')\n  }))\n  .filter((f) => f.fact)\n  .slice(0, 8);\n\nif (!researchFacts.length) {\n  const lines = String(rawText || '')\n    .split(/\\n+/)\n    .map(clean)\n    .filter((l) => l.length > 35)\n    .slice(0, 5);\n  for (const line of lines) {\n    researchFacts.push({ fact: line, source: '', date: '' });\n  }\n}\n\nlet researchSummary = clean(parsed.summary || '');\nif (!researchSummary) {\n  researchSummary = clean(researchFacts.map((f) => f.fact).slice(0, 4).join(' '));\n}\nif (!researchSummary) {\n  researchSummary = clean(rawText).slice(0, 900) || 'No research available.';\n}\n\nconst rawActions = Array.isArray(parsed.carer_actions) ? parsed.carer_actions : [];\nlet researchActions = rawActions.map(clean).filter(Boolean).slice(0, 6);\nif (!researchActions.length) {\n  researchActions = [\n    'Ask your GP or memory service for a named contact and written care plan.',\n    'Create one weekly routine for medication, meals, hydration, and sleep.',\n    'Keep a symptom diary to support reviews with health and social care teams.',\n    'Use local carers support groups for practical and emotional support.'\n  ];\n}\n\nconst nf = parsed.narrative_flow && typeof parsed.narrative_flow === 'object' ? parsed.narrative_flow : {};\nconst narrativeFlow = {\n  slide1: clean(nf.slide1 || ''),\n  slide2: clean(nf.slide2 || ''),\n  slide3: clean(nf.slide3 || ''),\n  slide4: clean(nf.slide4 || ''),\n  slide5: clean(nf.slide5 || '')\n};\n\nconst citations = response.citations\n  || response.choices?.[0]?.message?.annotations?.map((a) => a?.url_citation?.url).filter(Boolean)\n  || [];\n\nreturn [{\n  json: {\n    ...carouselArgs,\n    args: requestedTopic,\n    requestedTopic,\n    researchRaw: rawText,\n    researchSummary,\n    researchFacts,\n    researchActions,\n    narrativeFlow,\n    citations,\n    researchModel: response.model || 'unknown'\n  }\n}];\n"
      },
      "id": "research-0001-0000-0000-000000000002",
      "name": "Parse Carousel Research",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        160
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $('TEST_KEYS').first().json.openrouterKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: \"perplexity/sonar-pro\",\n  messages: [\n    {\n      role: \"user\",\n      content:\n        \"Research the topic: \" + ($json.args || \"signs of caregiver burnout\") +\n        \" in the context of dementia care and caregiving in the UK. Include: recent statistics or studies (2024-2026), real stories or examples, expert advice from NHS or Alzheimer's Society, and emotional hooks for short-form video. Be factual and specific. Return a concise research summary in 200 words max.\"\n    }\n  ]\n}) }}",
        "options": {}
      },
      "id": "research-0001-0000-0000-000000000003",
      "name": "Research for Video",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1180,
        400
      ],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2000,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Extract research text robustly and keep args/chat/profile context\nconst response = $input.first().json || {};\nconst content = response.choices?.[0]?.message?.content;\nconst research = (Array.isArray(content) ? content.map(c => c?.text || '').join('\\n') : content) || response.output_text || response.text || 'No research available.';\n\nlet videoArgs = {};\ntry { videoArgs = $('Prepare Video Args').first().json || {}; } catch (e) {\n  try { videoArgs = $('Video Regen Started').first().json || {}; } catch (e2) {}\n}\n\nconst citations = response.citations || response.choices?.[0]?.message?.annotations?.map(a => a?.url_citation?.url).filter(Boolean) || [];\nreturn [{\n  json: {\n    ...videoArgs,\n    research,\n    citations,\n    researchModel: response.model || 'unknown'\n  }\n}];\n"
      },
      "id": "research-0001-0000-0000-000000000004",
      "name": "Parse Video Research",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Deterministic intent guard before Action Router, with strict topic locking\nconst data = $input.first().json || {};\nconst incoming = data.action || {};\nlet type = String(incoming.type || 'none').toLowerCase().trim();\nlet topic = String(incoming.topic || data.args || '').trim();\nlet autoAction = String(data.autoAction || '').toLowerCase().trim();\nlet topicSource = String(data.topicSource || '').toLowerCase().trim();\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction normalizeTopic(s) {\n  let t = clean(s);\n  for (let i = 0; i < 3; i++) {\n    const first = t.charAt(0);\n    const last = t.charAt(t.length - 1);\n    const pairs = { '\"': '\"', \"'\": \"'\", '(': ')', '[': ']', '{': '}' };\n    if (pairs[first] && pairs[first] === last) t = clean(t.slice(1, -1));\n  }\n  return t;\n}\n\nlet raw = '';\nlet chatId = String(data.chatId || '');\ntry {\n  const load = $('Load Chat History').first().json || {};\n  raw = String(load.message || '');\n  if (!chatId) chatId = String(load.chatId || '');\n} catch (e) {}\nconst msg = raw.toLowerCase();\nconst isSlashMessage = raw.trim().startsWith('/');\n\nconst command = String(data.command || '').toLowerCase().trim();\nconst directArgs = normalizeTopic(data.forcedTopic || data.debugTopicSources?.directArgs || '');\n\ntopic = normalizeTopic(topic);\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.userMemory) staticData.userMemory = {};\nif (!staticData.pendingAutoActionByChat) staticData.pendingAutoActionByChat = {};\n\nconst chatKey = String(chatId || '');\nconst defaultChatKey = String(staticData.defaultChatId || '');\nconst memoryKey = chatKey || defaultChatKey;\nconst pick = (...vals) => vals.map(v => normalizeTopic(v)).find(Boolean) || '';\n\nconst handledExternally = new Set(['/commands', '/cmds', '/auto', '/creator', '/setface', '/setvoiceid']);\nif (handledExternally.has(command)) {\n  return [{\n    json: {\n      ...data,\n      chatId,\n      action: { type: 'none', topic: '' },\n      args: '',\n      autoAction: '',\n      topicSource: 'command',\n      debugEnsureTopic: {\n        chatKey,\n        command,\n        topicResolved: '',\n        topicSource: 'command',\n        autoAction: ''\n      }\n    }\n  }];\n}\n\nif ((command === '/carousel' || command === '/video') && type !== 'trends') {\n  type = command.slice(1);\n  if (directArgs) {\n    topic = directArgs;\n    topicSource = 'direct';\n  }\n}\n\nif (!autoAction && chatKey) {\n  autoAction = String(staticData.pendingAutoActionByChat?.[chatKey] || '').toLowerCase().trim();\n}\nif (!['carousel', 'video'].includes(autoAction)) autoAction = '';\n\nif (type === 'none' && !isSlashMessage) {\n  const wantsTrends = /(trend|trending|latest news|latest trends|what should .*post|what to post|news)/i.test(msg);\n  const wantsApprove = /(approve|post it|publish|go live|looks good,? post|ship it)/i.test(msg);\n  const wantsRegenerate = /(regenerate|redo|try again|another version|rewrite|new version)/i.test(msg);\n  const wantsStatus = /(status|are you online|bot status|system status|health check)/i.test(msg);\n  const wantsHelp = /(^help$|\\bhelp\\b|what can you do|how do you work|commands)/i.test(msg);\n  const wantsCarousel = /(carousel|carousels|slides|instagram post|instagram carousel)/i.test(msg);\n  const wantsVideo = /(video|reel|reels|tiktok|shorts?)/i.test(msg);\n\n  if (wantsTrends) type = 'trends';\n  else if (wantsApprove) type = 'approve';\n  else if (wantsRegenerate) type = 'regenerate';\n  else if (wantsStatus) type = 'status';\n  else if (wantsHelp) type = 'help';\n  else if (wantsCarousel && wantsVideo) type = 'both';\n  else if (wantsCarousel) type = 'carousel';\n  else if (wantsVideo) type = 'video';\n}\n\nif (!topic && ['carousel', 'video', 'both'].includes(type)) {\n  const m = raw.match(/\\/(?:carousel|video)(?:@[A-Za-z0-9_]+)?\\s+([\\s\\S]+)$/i)\n    || raw.match(/\\b(?:about|on|for)\\s+(.+)$/i);\n  if (m?.[1]) {\n    topic = normalizeTopic(m[1].replace(/[.!?]+$/g, ''));\n    topicSource = topicSource || 'message';\n  }\n}\n\nif (!topic && ['carousel', 'video', 'both'].includes(type)) {\n  topic = pick(\n    data.args,\n    incoming.topic,\n    staticData.pendingTrendTopicByChat[memoryKey],\n    staticData.latestSuggestedTopicByChat[memoryKey],\n    staticData.lastTrendByChat[memoryKey]\n  );\n  if (topic) topicSource = topicSource || 'memory';\n}\n\nif (!topic && ['carousel', 'video', 'both'].includes(type)) {\n  autoAction = type === 'both' ? 'carousel' : type;\n  type = 'trends';\n  if (chatKey) staticData.pendingAutoActionByChat[chatKey] = autoAction;\n}\n\nif (topic && ['carousel', 'video', 'both'].includes(type) && chatKey) {\n  staticData.userMemory[chatKey] = {\n    ...(staticData.userMemory[chatKey] || {}),\n    lastAction: type,\n    lastTopic: topic,\n    updatedAt: Date.now()\n  };\n\n  if (topicSource === 'direct' || topicSource === 'message' || topicSource === 'reply') {\n    staticData.pendingTrendTopicByChat[chatKey] = topic;\n    staticData.latestSuggestedTopicByChat[chatKey] = topic;\n    staticData.lastTrendByChat[chatKey] = topic;\n  }\n}\n\nconst debugEnsureTopic = {\n  chatKey,\n  memoryKey,\n  typeBeforeFinal: type,\n  topicResolved: topic,\n  topicSource,\n  pendingByChat: String(staticData.pendingTrendTopicByChat?.[chatKey] || ''),\n  latestByChat: String(staticData.latestSuggestedTopicByChat?.[chatKey] || ''),\n  lastByChat: String(staticData.lastTrendByChat?.[chatKey] || ''),\n  autoAction,\n  forcedTopic: directArgs,\n  command\n};\n\nreturn [{\n  json: {\n    ...data,\n    chatId,\n    action: { type, topic },\n    args: topic || data.args || '',\n    autoAction,\n    topicSource,\n    debugEnsureTopic\n  }\n}];"
      },
      "id": "conv-0001-0000-0000-000000000205",
      "name": "Ensure Action Intent",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        500
      ]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst clean = (s) => String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingTrendTopicByChat) staticData.pendingTrendTopicByChat = {};\nif (!staticData.latestSuggestedTopicByChat) staticData.latestSuggestedTopicByChat = {};\nif (!staticData.lastTrendByChat) staticData.lastTrendByChat = {};\nif (!staticData.userMemory) staticData.userMemory = {};\nif (!staticData.globalSuggestedTopic) staticData.globalSuggestedTopic = '';\n\nreturn items.map((item, index) => {\n  const d = item.json || {};\n\n  const title = clean(d.title || d.topic || 'Untitled topic').slice(0, 180);\n  const summary = clean(d.summary || d.description || 'No summary available.').slice(0, 1200);\n  const category = clean(d.category || 'caregiving');\n  const region = clean(d.region || 'UK');\n\n  let score = Number(d.engagement_score ?? d.engagementScore ?? 7);\n  if (!Number.isFinite(score)) score = 7;\n  score = Math.max(1, Math.min(10, Math.round(score)));\n\n  const rank = Number.isFinite(Number(d.rank)) ? Number(d.rank) : (index + 1);\n  const total = Number.isFinite(Number(d.totalTopics)) ? Number(d.totalTopics) : items.length;\n\n  const trendMessage = [\n    `Trending Topic ${rank}/${total}:`,\n    '',\n    title,\n    '',\n    summary,\n    '',\n    `Category: ${category}`,\n    `Region: ${region}`,\n    `Engagement Score: ${score}/10`,\n    '',\n    'Tap one of the buttons below to generate content for this exact topic.',\n    'Workflow build: 2026-02-11-lock-throttle-fix',\n    'Manual fallback: type carousel + topic or video + topic'\n  ].join('\\n');\n\n  const chatKey = String(d.chatId || staticData.defaultChatId || '');\n  if (chatKey && title) {\n    staticData.pendingTrendTopicByChat[chatKey] = title;\n    staticData.latestSuggestedTopicByChat[chatKey] = title;\n    staticData.lastTrendByChat[chatKey] = title;\n    staticData.globalSuggestedTopic = title;\n    staticData.userMemory[chatKey] = {\n      ...(staticData.userMemory[chatKey] || {}),\n      lastTopic: title,\n      lastAction: 'trends',\n      updatedAt: Date.now()\n    };\n  }\n\n  return {\n    json: {\n      ...d,\n      title,\n      summary,\n      category,\n      region,\n      engagement_score: score,\n      rank,\n      totalTopics: total,\n      trendMessage,\n      callbackCarousel: '/carousel',\n      callbackVideo: '/video'\n    }\n  };\n});\n"
      },
      "id": "trend-0001-0000-0000-000000000001",
      "name": "Format Trend Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        640
      ]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst apiKey = String($('TEST_KEYS').first().json.falKey || '').trim();\nconst modelPath = 'fal-ai/nano-banana-pro';\nconst headers = { Authorization: 'Key ' + apiKey };\n\nconst pollIntervalMs = 2000;\nconst maxChecks = 220;\nconst maxWaitMs = 600000;\nconst resultRetryCount = 8;\nconst transientCodes = new Set([404, 409, 422, 425, 429]);\n\nconst httpRequest =\n  (typeof $httpRequest === 'function' && $httpRequest) ||\n  (this && this.helpers && typeof this.helpers.httpRequest === 'function'\n    ? this.helpers.httpRequest.bind(this)\n    : null);\n\nif (!httpRequest) {\n  throw new Error('n8n HTTP helper is unavailable in this Code node runtime.');\n}\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nfunction getStatusCode(err) {\n  const candidates = [\n    err?.statusCode,\n    err?.status,\n    err?.httpCode,\n    err?.response?.statusCode,\n    err?.response?.status\n  ];\n  for (const c of candidates) {\n    const n = Number(c);\n    if (Number.isFinite(n)) return n;\n  }\n\n  const msg = String(err?.message || '');\n  const m = msg.match(/status\\s*code\\s*(\\d{3})/i) || msg.match(/\\b(\\d{3})\\b/);\n  if (m?.[1]) {\n    const n = Number(m[1]);\n    if (Number.isFinite(n)) return n;\n  }\n  return null;\n}\n\nfunction safeJson(v, maxLen = 500) {\n  try {\n    const s = JSON.stringify(v);\n    if (!s) return '';\n    return s.length > maxLen ? s.slice(0, maxLen) + '...' : s;\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction errText(err) {\n  const base = String(err?.message || err || 'unknown error');\n  const status = getStatusCode(err);\n  const body = safeJson(err?.response?.body || err?.body || err?.data || null);\n  return base + (status ? (' [status ' + status + ']') : '') + (body ? (' body=' + body) : '');\n}\n\nfunction readStatus(json) {\n  // Do not use nested result.status here; it can report completed before assets are fetchable.\n  return String(\n    (json &&\n      (json.status ||\n        json.request_status ||\n        json.state ||\n        json.phase ||\n        (json.data && json.data.status))) ||\n      ''\n  ).toUpperCase();\n}\n\nfunction readQueuePos(json) {\n  const v = json?.queue_position ?? json?.data?.queue_position ?? null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction normalizeImages(payload) {\n  const out = [];\n  const seen = new Set();\n\n  function pushUrl(v) {\n    const u = String(v || '').trim();\n    if (!u || !/^https?:\\/\\//i.test(u) || seen.has(u)) return;\n    seen.add(u);\n    out.push({ url: u });\n  }\n\n  function consume(node, depth = 0) {\n    if (!node || depth > 6) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) consume(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      pushUrl(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    if (typeof node.url === 'string') pushUrl(node.url);\n    if (typeof node.image_url === 'string') pushUrl(node.image_url);\n    if (typeof node.imageUrl === 'string') pushUrl(node.imageUrl);\n\n    if (Array.isArray(node.images)) consume(node.images, depth + 1);\n    if (Array.isArray(node.outputs)) consume(node.outputs, depth + 1);\n    if (Array.isArray(node.output)) consume(node.output, depth + 1);\n\n    if (node.data) consume(node.data, depth + 1);\n    if (node.result) consume(node.result, depth + 1);\n    if (node.response) consume(node.response, depth + 1);\n    if (node.image) consume(node.image, depth + 1);\n  }\n\n  consume(payload);\n  return out;\n}\n\nfunction buildFallbackStatusUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId) + '/status';\n}\n\nfunction buildFallbackResultUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId);\n}\n\nasync function getStatusByUrl(statusUrl, requestId) {\n  const url = statusUrl || buildFallbackStatusUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function getResultByUrl(responseUrl, requestId) {\n  const url = responseUrl || buildFallbackResultUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function waitForOne(item) {\n  const inputJson = item.json || {};\n  const requestId = inputJson.request_id || inputJson.requestId;\n  const statusUrl = String(inputJson.status_url || inputJson.statusUrl || '').trim();\n  const responseUrl = String(inputJson.response_url || inputJson.responseUrl || '').trim();\n\n  const syncImages = normalizeImages(inputJson);\n  if (syncImages.length) {\n    return { json: { ...inputJson, images: syncImages, falStatus: 'COMPLETED_SYNC', falPollAttempts: 0 } };\n  }\n\n  if (!requestId && !statusUrl && !responseUrl) {\n    throw new Error('fal.ai submit did not return request_id/status_url/response_url.');\n  }\n\n  const startedAt = Date.now();\n  let attempts = 0;\n  let statusValue = '';\n  let lastQueuePosition = null;\n\n  while (attempts < maxChecks && (Date.now() - startedAt) < maxWaitMs) {\n    attempts++;\n\n    let statusJson;\n    try {\n      statusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(statusJson);\n      lastQueuePosition = readQueuePos(statusJson);\n    } catch (err) {\n      const code = getStatusCode(err);\n      if (transientCodes.has(code)) {\n        statusValue = statusValue || 'IN_QUEUE';\n      } else {\n        throw new Error('fal.ai status request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n      }\n    }\n\n    if (statusValue === 'COMPLETED') break;\n    if (['FAILED', 'ERROR', 'CANCELLED'].includes(statusValue)) {\n      throw new Error('fal.ai request ' + (requestId || 'unknown') + ' failed with status ' + statusValue + '.');\n    }\n\n    const elapsed = Date.now() - startedAt;\n    const remaining = maxWaitMs - elapsed;\n    if (remaining <= 0) break;\n    await sleep(Math.min(pollIntervalMs, remaining));\n  }\n\n  if (statusValue !== 'COMPLETED') {\n    try {\n      const finalStatusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(finalStatusJson) || statusValue;\n      lastQueuePosition = readQueuePos(finalStatusJson) ?? lastQueuePosition;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  let resultJson = null;\n  const tryGetResult = async () => {\n    for (let i = 0; i < resultRetryCount; i++) {\n      try {\n        const res = await getResultByUrl(responseUrl, requestId || '');\n        if (res && typeof res === 'object') return res;\n      } catch (err) {\n        const code = getStatusCode(err);\n        if (!transientCodes.has(code)) {\n          throw new Error('fal.ai result request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n        }\n      }\n      await sleep(Math.min(1200 + i * 300, 3000));\n    }\n    return null;\n  };\n\n  if (statusValue === 'COMPLETED') {\n    resultJson = await tryGetResult();\n  } else {\n    try {\n      const possible = await tryGetResult();\n      const hasImages = normalizeImages(possible).length > 0;\n      if (hasImages) {\n        resultJson = possible;\n        statusValue = 'COMPLETED_LATE';\n      }\n    } catch (e) {\n      // no-op\n    }\n  }\n\n  if (!resultJson || typeof resultJson !== 'object') {\n    const seconds = Math.max(1, Math.round((Date.now() - startedAt) / 1000));\n    throw new Error(\n      'fal.ai request ' + (requestId || 'unknown') + ' is still ' + (statusValue || 'IN_QUEUE') +\n      ' after ' + attempts + ' checks (~' + seconds + 's), queue_position=' +\n      (lastQueuePosition == null ? 'n/a' : lastQueuePosition) +\n      '. Queue is busy or result is not ready yet. Retry /carousel in 1-2 minutes.'\n    );\n  }\n\n  const normalized = normalizeImages(resultJson);\n  const merged = {\n    ...inputJson,\n    ...resultJson,\n    images: normalized,\n    request_id: requestId || inputJson.request_id || '',\n    falStatus: statusValue || 'COMPLETED',\n    falPollAttempts: attempts,\n  };\n\n  if (!normalized.length) {\n    merged.falError = 'fal.ai completed but returned no image URLs in supported fields.';\n  }\n\n  return { json: merged };\n}\n\nconst out = [];\nlet lastError = null;\n\nfor (const item of items) {\n  try {\n    out.push(await waitForOne(item));\n  } catch (err) {\n    lastError = err;\n    out.push({\n      json: {\n        ...(item.json || {}),\n        falStatus: 'ERROR',\n        falError: String(err.message || err),\n        images: []\n      }\n    });\n  }\n}\n\nconst anyImages = out.some((o) => {\n  const j = o.json || {};\n  return Array.isArray(j.images) && j.images.length > 0;\n});\n\nif (!anyImages && lastError) {\n  throw lastError;\n}\n\nreturn out;",
        "mode": "runOnceForAllItems",
        "language": "javaScript"
      },
      "id": "fal-await-image-result-v1",
      "name": "fal.ai - Await Image Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1660,
        160
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// If /carousel or /video had no saved topic, continue automatically after fresh trend is sent.\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingAutoActionByChat) staticData.pendingAutoActionByChat = {};\n\nlet trend = {};\ntry { trend = $('Format Trend Message').first().json || {}; } catch (e) {}\n\nconst chatKey = String(trend.chatId || staticData.defaultChatId || '');\nif (!chatKey) return [];\n\nconst autoAction = String(staticData.pendingAutoActionByChat[chatKey] || '').toLowerCase().trim();\nif (!['carousel', 'video'].includes(autoAction)) return [];\n\nconst topic = String(trend.title || trend.topic || '').trim();\nif (!topic) return [];\n\n// Consume one-shot auto action to avoid repeated triggers.\nstaticData.pendingAutoActionByChat[chatKey] = '';\n\nreturn [{\n  json: {\n    ...trend,\n    chatId: trend.chatId,\n    messageId: trend.messageId,\n    args: topic,\n    action: { type: autoAction, topic },\n    autoAction\n  }\n}];"
      },
      "id": "trend-auto-continue-code-v1",
      "name": "Auto Continue From Trends",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1080,
        700
      ]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n\\t]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction stripMeta(text) {\n  let t = clean(text);\n  if (!t) return t;\n  t = t\n    .replace(/^(why this matters now|what changed|evidence update|what this means for carers|next step|key takeaway|conclusion)\\s*[:\\-]\\s*/i, '')\n    .replace(/\\b(why\\s+this\\s+matters\\s+now|what\\s+changed|evidence\\s+update|key\\s+takeaway|next\\s+step|conclusion)\\b\\s*[:\\-]?\\s*/ig, '')\n    .trim();\n  return t;\n}\n\nfunction hashSeed(text) {\n  const src = clean(text) || 'dignitate';\n  let acc = 0;\n  for (let i = 0; i < src.length; i++) {\n    acc = (acc * 131 + src.charCodeAt(i)) % 1000000000;\n  }\n  return Math.abs(acc);\n}\n\nfunction clampWords(text, maxWords) {\n  const words = stripMeta(text).split(/\\s+/).filter(Boolean);\n  return words.slice(0, Math.max(1, maxWords)).join(' ');\n}\n\nfunction clampRange(text, minWords, maxWords, filler = 'support') {\n  let words = stripMeta(text).split(/\\s+/).filter(Boolean);\n  if (words.length > maxWords) words = words.slice(0, maxWords);\n  while (words.length < minWords) words.push(filler);\n  return words.join(' ');\n}\n\nfunction clampChars(text, maxChars) {\n  const t = stripMeta(text);\n  if (!t) return '';\n  if (t.length <= maxChars) return t;\n  const cut = t.slice(0, maxChars);\n  const i = cut.lastIndexOf(' ');\n  return (i > 0 ? cut.slice(0, i) : cut).trim();\n}\n\nfunction extractHeadingBody(d) {\n  const h = stripMeta(d.slideHeading || '');\n  const b = stripMeta(d.slideBody || '');\n  if (h && b) return { heading: h, body: b };\n\n  const t = stripMeta(d.slideText || '');\n  const idx = t.indexOf(':');\n  if (idx > 0 && idx < 80) {\n    return { heading: stripMeta(t.slice(0, idx)), body: stripMeta(t.slice(idx + 1)) };\n  }\n\n  const words = t.split(/\\s+/).filter(Boolean);\n  return { heading: words.slice(0, 7).join(' '), body: words.slice(7).join(' ') };\n}\n\nreturn items.map((item) => {\n  const d = item.json || {};\n\n  const title = clean(d.title) || 'Dignitate Dementia Care Update';\n  const topic = clean(d.args || d.title) || 'dementia care support in the UK';\n  const slideIndex = Number(d.slideIndex || 0);\n  const totalSlides = Number(d.totalSlides || 5);\n  const role = String(d.slideRole || (slideIndex === 0 ? 'cover' : (slideIndex === totalSlides - 1 ? 'conclusion' : 'information'))).toLowerCase();\n\n  const extracted = extractHeadingBody(d);\n\n  // Keep text short so it renders cleanly.\n  let heading = clampRange(extracted.heading || title, 3, 6, 'care');\n  let body = clampRange(extracted.body || 'Practical UK guidance for carers', 10, 18, 'support');\n\n  heading = clampChars(heading, 34);\n  body = clampChars(body, 110);\n\n  // Hard ban the bad phrase.\n  const banned = /\\b(why\\s+this\\s+matters\\s+now|evidence\\s+update|key\\s+takeaway|next\\s+step|what\\s+changed|conclusion)\\b/i;\n  if (banned.test(heading)) heading = clampRange(title, 3, 7, 'care');\n  if (banned.test(body)) body = clampRange('Practical UK guidance for carers', 6, 14, 'support');\n\n  const continuity = 'Series: \"' + title + '\". Slide ' + (slideIndex + 1) + ' of ' + totalSlides + ' (' + role + ').';\n\n  const slideImagePrompt = clean(d.imagePrompt || d.image_prompt || d.visualPrompt || d.prompt || '');\n\n  const prompt = [\n    'Create exactly ONE single 4:5 portrait carousel slide image.',\n    'Dignitate style: modern, clean, UK healthcare editorial.',\n    'Layout rules:',\n    '- Top 40%: solid off-white panel with clean margins.',\n    '- Bottom 60%: photorealistic UK dementia-care / carer scene photo matching the slide meaning.',\n    'Photo brief: use this exact scene idea: ' + (slideImagePrompt || 'UK dementia-care documentary moment') + '.',\n    'Text rules:',\n    '- Keep text short but informative (2-4 lines total).',\n    '- Headline: very large bold, up to 2 lines max.',\n    '- Body: smaller sans-serif, up to 2 lines max.',\n        '- Use EXACTLY the text provided. Do not add or change any words.',\n    '- If the text does not fit, reduce font size slightly (never add lines).',\n    'Do NOT include: logos, watermarks, hashtags, slide numbers, charts, icons, UI.',\n    'Never include phrases like \"Why this matters now\" or \"Evidence update\".',\n    continuity,\n    'Topic: ' + topic + '.',\n    'Headline: \"' + heading + '\".',\n    'Subline: \"' + body + '\".'\n  ].join(' ');\n\n  const falSeed = hashSeed('DIGNITATE_CAROUSEL_V2|' + title + '|' + topic + '|slide:' + slideIndex + '|' + heading);\n\n  return {\n    json: {\n      ...d,\n      slideRole: role,\n      slideHeading: heading,\n      slideBody: body,\n      falPrompt: prompt,\n      falSeed,\n      falPromptPreview: prompt.slice(0, 700)\n    }\n  };\n});\n"
      },
      "id": "fal-build-prompt-v2",
      "name": "Build fal.ai Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1320,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json || {};\nlet raw = '';\ntry { raw = String($('Load Chat History').first().json.message || '').trim(); } catch (e) {}\nif (!raw) return [{ json: data }];\n\nconst isAuto = /^\\/auto(?:\\b|$)/i.test(raw);\nconst isCommands = /^\\/(commands|cmds)(?:\\b|$)/i.test(raw);\nconst isCreator = /^\\/(setface|setvoiceid|creator)(?:\\b|$)/i.test(raw);\nif (!isAuto && !isCommands && !isCreator) return [{ json: data }];\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.autoScheduleByChat) staticData.autoScheduleByChat = {};\nif (!staticData.pendingAutoActionByChat) staticData.pendingAutoActionByChat = {};\nif (!staticData.creatorProfileByChat) staticData.creatorProfileByChat = {};\nif (!staticData.defaultChatId && data.chatId) staticData.defaultChatId = String(data.chatId);\n\nconst chatKey = String(data.chatId || staticData.defaultChatId || '');\nif (!chatKey) {\n  return [{ json: { ...data, action: { type: 'none', topic: '' }, args: '', replyText: 'Could not identify chat for setup.' } }];\n}\n\nconst creatorDefaults = {\n  faceUrls: [\n    'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_casual.png',\n    'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_houndstooth.png',\n    'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_suit.png',\n    'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_shirt.png',\n    'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_layered.png'\n  ],\n  faceUrl: 'https://raw.githubusercontent.com/dignitatesocial/dignitatevideo/main/malcolm_portrait_houndstooth.png',\n  voiceId: 'GoLTMzQJAHarswiHqv3L',\n  updatedAt: Date.now(),\n};\nconst creatorCfg = {\n  ...creatorDefaults,\n  ...(staticData.creatorProfileByChat[chatKey] || {}),\n};\n\nconst cfg = {\n  enabled: false,\n  timezoneOffset: '+00:00',\n  carouselTime: '09:00',\n  videoTime: '18:00',\n  fixedTopic: '',\n  lastRun: {},\n  ...(staticData.autoScheduleByChat[chatKey] || {}),\n  updatedAt: Date.now(),\n};\n\nconst botFatherCommands = [\n  'carousel - Create carousel from topic',\n  'video - Create video from topic',\n  'trends - Get latest trend topic',\n  'approve - Approve pending draft',\n  'regenerate - Regenerate pending draft',\n  'status - Check bot status',\n  'help - Show help',\n  'setface - Set creator face image URL',\n  'setvoiceid - Set ElevenLabs voice ID',\n  'creator - Show creator profile',\n  'commands - Show command list'\n].join('\\n');\n\nfunction normalizeGithubRawUrl(u) {\n  const s = String(u || '').trim();\n  const m = s.match(/^https?:\\/\\/github\\.com\\/([^\\/]+)\\/([^\\/]+)\\/blob\\/([^\\/]+)\\/(.+)$/i);\n  if (m) return `https://raw.githubusercontent.com/${m[1]}/${m[2]}/${m[3]}/${m[4]}`;\n  return s;\n}\n\nfunction isHttpUrl(v) {\n  return /^https?:\\/\\//i.test(String(v || '').trim());\n}\n\nif (isAuto) {\n  cfg.enabled = false;\n  cfg.updatedAt = Date.now();\n  staticData.autoScheduleByChat[chatKey] = cfg;\n  staticData.pendingAutoActionByChat[chatKey] = '';\n  staticData.creatorProfileByChat[chatKey] = creatorCfg;\n\n  return [{\n    json: {\n      ...data,\n      action: { type: 'none', topic: '' },\n      args: '',\n      replyText: [\n        'Auto mode is temporarily disabled.',\n        'Use manual commands for now:',\n        '/carousel <topic>',\n        '/video <topic>',\n        '/trends'\n      ].join('\\n')\n    }\n  }];\n}\n\nif (isCommands) {\n  staticData.autoScheduleByChat[chatKey] = cfg;\n  staticData.pendingAutoActionByChat[chatKey] = '';\n  staticData.creatorProfileByChat[chatKey] = creatorCfg;\n\n  return [{\n    json: {\n      ...data,\n      action: { type: 'none', topic: '' },\n      args: '',\n      replyText: [\n        'Available commands:',\n        '/carousel <topic>',\n        '/video <topic>',\n        '/trends',\n        '/approve',\n        '/regenerate',\n        '/status',\n        '/help',\n        '/setface <public_image_url>',\n        '/setvoiceid <elevenlabs_voice_id>',\n        '/creator',\n        '',\n        'Auto mode is currently disabled.',\n        '',\n        'To show commands in Telegram / menu, use @BotFather /setcommands and paste:',\n        botFatherCommands\n      ].join('\\n')\n    }\n  }];\n}\n\nconst cmd = String(raw.split(/\\s+/)[0] || '').toLowerCase();\nlet reply = '';\n\nif (cmd === '/creator') {\n  reply = [\n    'CREATOR PROFILE',\n    '',\n    'Face URL: ' + (creatorCfg.faceUrl || 'not set'),\n    'Voice ID: ' + (creatorCfg.voiceId || 'not set'),\n    '',\n    'Commands:',\n    '/setface <public_image_url>',\n    '/setvoiceid <elevenlabs_voice_id>',\n    '/creator'\n  ].join('\\n');\n} else if (cmd === '/setface') {\n  const url = raw.replace(/^\\/setface\\s*/i, '').trim();\n  if (!url || !isHttpUrl(url)) {\n    reply = 'Invalid face image URL. Use: /setface https://...';\n  } else {\n    creatorCfg.faceUrl = normalizeGithubRawUrl(url);\n    creatorCfg.updatedAt = Date.now();\n    reply = 'Creator face image saved for future videos.';\n  }\n} else if (cmd === '/setvoiceid') {\n  const voiceId = raw.replace(/^\\/setvoiceid\\s*/i, '').trim();\n  if (!voiceId || /\\s/.test(voiceId) || voiceId.length < 6) {\n    reply = 'Invalid voice ID. Use: /setvoiceid <elevenlabs_voice_id>';\n  } else {\n    creatorCfg.voiceId = voiceId;\n    creatorCfg.updatedAt = Date.now();\n    reply = 'Creator voice ID saved for future videos.';\n  }\n}\n\ncfg.enabled = false;\ncfg.updatedAt = Date.now();\nstaticData.autoScheduleByChat[chatKey] = cfg;\nstaticData.pendingAutoActionByChat[chatKey] = '';\nstaticData.creatorProfileByChat[chatKey] = creatorCfg;\n\nreturn [{\n  json: {\n    ...data,\n    action: { type: 'none', topic: '' },\n    args: '',\n    replyText: reply || 'Creator command updated.',\n    creatorProfile: creatorCfg\n  }\n}];"
      },
      "id": "auto-mode-handler-v1",
      "name": "Handle Auto Mode Commands",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        340,
        340
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{`Image ${$json.slideIndex || 1}/${$json.totalSlides || 1}:\n${$json.imageUrl || \"\"}`}}",
        "additionalFields": {
          "disableWebPagePreview": false
        }
      },
      "id": "send-image-fallback-v1",
      "name": "Send Image URL Fallback",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [
        2080,
        260
      ],
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.imageUrl }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "image/*"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (n8n Telegram Image Fetch)"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "data"
            }
          },
          "timeout": 120000
        }
      },
      "id": "download-carousel-image-binary-v1",
      "name": "Download Carousel Image Binary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1880,
        260
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://queue.fal.run/fal-ai/nano-banana-pro/edit",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Key ' + $('TEST_KEYS').first().json.falKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  prompt: (\n    'Create a photorealistic vertical (9:16) documentary portrait scene of the same person in the reference image. ' +\n    'Keep exact identity, face geometry, skin tone, and hairstyle consistent. ' +\n    'Use topic context: ' + ($json.args || $json.title || 'UK dementia care') + '. ' +\n    'Wardrobe: professional UK founder look (smart suit or blazer or smart shirt), allow subtle variation based on topic, keep consistent within this portrait. ' +\n    'Setting: realistic UK healthcare/community environment. ' +\n    'No text, no logos, no watermark.'\n  ),\n  image_urls: (($json.creatorImageUrls && $json.creatorImageUrls.length) ? $json.creatorImageUrls : [ $json.creatorImageUrl ]),\n  num_images: 1,\n  aspect_ratio: '9:16',\n  output_format: 'png',\n  resolution: '1K',\n  safety_tolerance: '4',\n  limit_generations: true\n}) }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000072",
      "name": "Generate Founder Portrait",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1300,
        400
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2500
    },
    {
      "parameters": {
        "jsCode": "const base = $('Parse Video Response').first().json || {};\nconst out = $input.first().json || {};\n\nfunction looksLikeDirectImageUrl(v) {\n  const u = String(v || '').trim();\n  const lower = u.toLowerCase();\n\n  if (!(lower.startsWith('http://') || lower.startsWith('https://'))) return false;\n  if (lower.includes('queue.fal.run') && lower.includes('/requests/')) return false;\n  if (lower.includes('/status')) return false;\n  if (lower.includes('/cancel')) return false;\n\n  if (lower.includes('fal.media/files/')) return true;\n\n  const bare = lower.split('?')[0].split('#')[0];\n  if (bare.endsWith('.png') || bare.endsWith('.jpg') || bare.endsWith('.jpeg') || bare.endsWith('.webp')) return true;\n\n  return false;\n}\n\nfunction pickGeneratedPortraitUrl(payload) {\n  const urls = [];\n  const seen = new Set();\n\n  function push(v) {\n    const u = String(v || '').trim();\n    if (!u || seen.has(u) || !looksLikeDirectImageUrl(u)) return;\n    seen.add(u);\n    urls.push(u);\n  }\n\n  function walk(node, depth = 0) {\n    if (node == null || depth > 7) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) walk(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      push(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    push(node.image_url);\n    push(node.imageUrl);\n    push(node.url);\n\n    walk(node.images, depth + 1);\n    walk(node.output, depth + 1);\n    walk(node.result, depth + 1);\n    walk(node.data, depth + 1);\n    walk(node.response, depth + 1);\n\n    for (const v of Object.values(node)) {\n      if (v && typeof v === 'object') walk(v, depth + 1);\n    }\n  }\n\n  walk(payload);\n  return urls[0] || '';\n}\n\nconst generatedPortraitUrl = pickGeneratedPortraitUrl(out);\nconst originalCreatorUrl = String(base.creatorImageUrl || '').trim();\n\n// Keep original founder profile image as the identity anchor for clip generation.\nconst clipIdentityImageUrl = generatedPortraitUrl || originalCreatorUrl;\n\nconst founderPortraitSource = generatedPortraitUrl\n  ? (originalCreatorUrl ? 'generated_variant_used' : 'generated_only')\n  : (originalCreatorUrl ? 'fallback_profile' : 'none');\n\nreturn [{\n  json: {\n    ...base,\n    creatorImageUrl: clipIdentityImageUrl,\n    // Preserve the founder portrait pool for downstream scene generation.\n    creatorImageUrls: Array.isArray(out.creatorImageUrls) && out.creatorImageUrls.length\n      ? out.creatorImageUrls\n      : (Array.isArray(base.creatorImageUrls) ? base.creatorImageUrls : []),\n    generatedFounderPortraitUrl: generatedPortraitUrl,\n    founderPortraitSource\n  }\n}];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000073",
      "name": "Resolve Founder Portrait URL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1420,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json || {};\nconst qid = String(data.callbackQueryId || '').trim();\nif (!qid) return [];\nreturn [{ json: { callbackQueryId: qid } }];"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000074",
      "name": "Callback Ack Gate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        220
      ]
    },
    {
      "parameters": {
        "resource": "callback",
        "operation": "answerQuery",
        "queryId": "={{ $json.callbackQueryId }}",
        "additionalFields": {
          "text": "Processing your selection..."
        },
        "results": "=[]"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000075",
      "name": "Answer Callback Query",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        0,
        220
      ],
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dignitate-remotion-callback",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000076",
      "name": "Remotion Callback Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -760,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const src = ($json.body && typeof $json.body === 'object') ? $json.body : ($json || {});\nconst chatId = String(src.chatId || '').trim();\nif (!chatId) return [];\n\nconst statusRaw = String(src.status || '').trim();\nconst status = statusRaw ? statusRaw.toLowerCase() : '';\nconst videoUrl = String(src.videoUrl || '').trim();\nconst title = String(src.title || 'Untitled Video').trim();\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.pendingContent) staticData.pendingContent = {};\n\nconst pending = staticData.pendingContent[chatId] && typeof staticData.pendingContent[chatId] === 'object'\n  ? staticData.pendingContent[chatId]\n  : null;\n\nconst pendingCaption = String(pending?.caption || '').trim();\nconst pendingHashtags = Array.isArray(pending?.hashtags) ? pending.hashtags : [];\n\nconst renderOk = status === 'success' && Boolean(videoUrl);\n\n// Persist the final MP4 URL so /approve can use it.\nif (renderOk) {\n  const base = pending && pending.type === 'video'\n    ? { ...pending }\n    : { type: 'video', chatId, title, caption: pendingCaption, hashtags: pendingHashtags, timestamp: Date.now() };\n\n  staticData.pendingContent[chatId] = {\n    ...base,\n    title: base.title || title,\n    finalVideoUrl: videoUrl,\n    videoUrl,\n    renderStatus: 'success',\n    renderedAt: Date.now(),\n  };\n}\n\nfunction clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction uniqHashtags(list) {\n  const out = [];\n  const seen = new Set();\n  for (const raw of (Array.isArray(list) ? list : [])) {\n    let h = clean(raw);\n    if (!h) continue;\n    if (!h.startsWith('#')) h = '#' + h;\n    const key = h.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push(h);\n  }\n  return out;\n}\n\nconst hashtags = uniqHashtags(pendingHashtags).slice(0, 12);\n\nlet approvalCaption = '';\nif (renderOk) {\n  const parts = [\n    'VIDEO READY FOR REVIEW',\n    '',\n    'Title: ' + (pending?.title || title),\n  ];\n\n  if (pendingCaption) {\n    parts.push('', 'Draft caption:', pendingCaption);\n  }\n\n  if (hashtags.length) {\n    parts.push('', 'Hashtags: ' + hashtags.join(' '));\n  }\n\n  parts.push('', 'Tap a button below: Approve to post, or Regenerate for a new version.');\n\n  // Telegram video caption max is ~1024 chars.\n  const joined = parts.join('\\n');\n  approvalCaption = joined.length > 1000 ? (joined.slice(0, 997).trim() + '...') : joined;\n}\n\nlet text = '';\nif (renderOk) {\n  text = ['Video render complete.', '', 'Title: ' + (pending?.title || title), '', videoUrl].join('\\n');\n}\n\nif (!renderOk) {\n  const err = String(src.error || 'Unknown render error').slice(0, 700);\n  text = ['Video render failed.', '', 'Title: ' + title, 'Error: ' + err].join('\\n');\n}\n\nreturn [{\n  json: {\n    chatId,\n    title,\n    status: renderOk ? 'success' : (status || 'error'),\n    videoUrl,\n    renderOk,\n    approvalCaption,\n    text,\n  }\n}];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000077",
      "name": "Normalize Render Callback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -520,
        120
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ String($json.renderOk) }}",
                    "rightValue": "true",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Success"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000079",
      "name": "Render Callback Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -360,
        120
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.videoUrl }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "video/*"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (n8n Telegram Video Fetch)"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "data"
            }
          },
          "timeout": 240000
        }
      },
      "id": "download-rendered-video-binary-v1",
      "name": "Download Rendered Video Binary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -200,
        120
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "sendVideo",
        "chatId": "={{ $json.chatId }}",
        "binaryData": true,
        "replyMarkup": "inlineKeyboard",
        "inlineKeyboard": {
          "rows": [
            {
              "row": {
                "buttons": [
                  {
                    "text": "Approve",
                    "additionalFields": {
                      "callback_data": "/approve"
                    }
                  },
                  {
                    "text": "Regenerate",
                    "additionalFields": {
                      "callback_data": "/regenerate"
                    }
                  }
                ]
              }
            }
          ]
        },
        "additionalFields": {
          "caption": "={{ $json.approvalCaption }}"
        },
        "binaryPropertyName": "data"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000080",
      "name": "Send Rendered Video To Telegram",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [
        -120,
        120
      ],
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000078",
      "name": "Send Render Callback To Telegram",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [
        -280,
        120
      ],
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "function clean(s) {\n  return String(s || '').replace(/[\\r\\n]+/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction uniqHashtags(list) {\n  const out = [];\n  const seen = new Set();\n  for (const raw of (Array.isArray(list) ? list : [])) {\n    let h = clean(raw);\n    if (!h) continue;\n    if (!h.startsWith('#')) h = '#' + h;\n    const k = h.toLowerCase();\n    if (seen.has(k)) continue;\n    seen.add(k);\n    out.push(h);\n  }\n  return out;\n}\n\nconst j = $input.first().json || {};\nif (j.error) return [{ json: j }];\n\nconst chatId = j.chatId;\nconst title = clean(j.title || j.args || 'Dignitate Video');\nconst caption = clean(j.caption || 'Research-backed guidance for carers with clear next steps.');\nconst hashtags = uniqHashtags(j.hashtags || []).slice(0, 12);\n\nconst videoUrl = clean(j.finalVideoUrl || j.videoUrl || '');\nif (!videoUrl) {\n  return [{\n    json: {\n      chatId,\n      error: true,\n      message: 'Video is not rendered yet (no MP4 URL found). Please wait for the render to finish, then approve again.'\n    }\n  }];\n}\n\nconst igCaption = [title, caption, hashtags.join(' ')].filter(Boolean).join('\\n\\n').slice(0, 2100);\n\nconst ytTitleBase = title.length > 90 ? title.slice(0, 87).trim() + '...' : title;\nconst ytTitle = (ytTitleBase + ' #Shorts').slice(0, 100);\nconst ytDescription = [caption, '', hashtags.join(' '), '#Shorts'].filter(Boolean).join('\\n').slice(0, 4500);\n\nconst ttCaption = (caption + (hashtags.length ? (' ' + hashtags.slice(0, 8).join(' ')) : '')).slice(0, 2000);\n\n// Composio v2 requires UUID connectedAccountIds for TikTok/YouTube (not the ac_ ids used in v1).\nconst uuidRe = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n// If you only have Composio Auth Config IDs (ac_...), use entityId mode.\nconst rawTikTokId = '';\nconst rawYouTubeId = 'ac_45guMz9S841I';\n\nconst tiktokConnectedAccountUuid = uuidRe.test(rawTikTokId) ? rawTikTokId : '';\nconst youtubeConnectedAccountUuid = uuidRe.test(rawYouTubeId) ? rawYouTubeId : '';\n\nconst tiktokEntityId = (!tiktokConnectedAccountUuid && rawTikTokId) ? rawTikTokId : '';\nconst youtubeEntityId = (!youtubeConnectedAccountUuid && rawYouTubeId) ? rawYouTubeId : '';\n\nreturn [{\n  json: {\n    ...j,\n    type: 'video',\n    chatId,\n    title,\n    caption,\n    hashtags,\n    videoUrl,\n    instagramCaption: igCaption,\n    youtubeTitle: ytTitle,\n    youtubeDescription: ytDescription,\n    tiktokCaption: ttCaption,\n\n    // Prefer connectedAccount UUIDs; otherwise fall back to entityId mode.\n    tiktokConnectedAccountUuid,\n    youtubeConnectedAccountUuid,\n    tiktokEntityId,\n    youtubeEntityId,\n\n    connectedAccountValidation: {\n      rawTikTokId,\n      rawYouTubeId,\n      tiktokValidUuid: Boolean(tiktokConnectedAccountUuid),\n      youtubeValidUuid: Boolean(youtubeConnectedAccountUuid),\n      tiktokHasEntityId: Boolean(tiktokEntityId),\n      youtubeHasEntityId: Boolean(youtubeEntityId)\n    }\n  }\n}];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000081",
      "name": "Prepare Video Post Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        -80
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ String($json.error) }}",
                    "rightValue": "true",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "Error"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000087",
      "name": "Video Post Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        860,
        -80
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{`Posting approved video now...\\n\\nInstagram Reels: starting\\nTikTok: starting\\nYouTube Shorts: starting`}}",
        "additionalFields": {
          "disableWebPagePreview": true
        }
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000082",
      "name": "Video Posting Started",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "credentials": {
        "telegramApi": {
          "id": "BCYLgnIRm18fvabJ",
          "name": "Telegram account"
        }
      },
      "position": [
        940,
        -80
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v1/actions/INSTAGRAM_CREATE_MEDIA_CONTAINER/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ connectedAccountId: 'ac_KNBQIWjdvioh', input: { caption: $json.instagramCaption || '', video_url: $json.videoUrl, media_url: $json.videoUrl, is_carousel: false, media_type: 'REELS' } }) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000083",
      "name": "Composio - Instagram Reels",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1180,
        -80
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v2/actions/TIKTOK_PUBLISH_VIDEO/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify(($json.tiktokConnectedAccountUuid ? { connectedAccountId: $json.tiktokConnectedAccountUuid, text: `Publish this MP4 as a TikTok video. Video URL: ${$json.videoUrl}. Caption: ${$json.tiktokCaption}.` } : ($json.tiktokEntityId ? { appName: 'tiktok', entityId: $json.tiktokEntityId, text: `Publish this MP4 as a TikTok video. Video URL: ${$json.videoUrl}. Caption: ${$json.tiktokCaption}.` } : { text: 'Missing connected account configuration for tiktok' }))) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000084",
      "name": "Composio - TikTok",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1420,
        -80
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": false,
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://backend.composio.dev/api/v2/actions/YOUTUBE_UPLOAD_VIDEO/execute",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('TEST_KEYS').first().json.composioKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify(($json.youtubeConnectedAccountUuid ? { connectedAccountId: $json.youtubeConnectedAccountUuid, text: `Upload this MP4 to YouTube as a Short. Video URL: ${$json.videoUrl}. Title: ${$json.youtubeTitle}. Description: ${$json.youtubeDescription}.` } : ($json.youtubeEntityId ? { appName: 'youtube', entityId: $json.youtubeEntityId, text: `Upload this MP4 to YouTube as a Short. Video URL: ${$json.videoUrl}. Title: ${$json.youtubeTitle}. Description: ${$json.youtubeDescription}.` } : { text: 'Missing connected account configuration for youtube' }))) }}",
        "options": {}
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000085",
      "name": "Composio - YouTube Shorts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1660,
        -80
      ],
      "onError": "continueRegularOutput",
      "retryOnFail": false,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const base = $('Prepare Video Post Data').first().json || {};\nconst chatId = base.chatId;\n\nfunction statusFrom(nodeName) {\n  try {\n    const j = $(nodeName).first().json || {};\n    if (j.error) return { status: 'Failed', detail: String(j.error?.message || j.message || j.error || '').slice(0, 200) };\n    if (j.successful === false || j.successfull === false) return { status: 'Failed', detail: String(j.message || '').slice(0, 200) };\n    if (j.status && Number(j.status) >= 400) return { status: 'Failed', detail: String(j.message || '').slice(0, 200) };\n    return { status: 'Posted', detail: '' };\n  } catch (e) {\n    return { status: 'Skipped', detail: 'Not configured or not executed.' };\n  }\n}\n\nconst val = base.connectedAccountValidation || {};\nconst ttNote = (!val.tiktokValidUuid && val.rawTikTokId && val.rawTikTokId.startsWith('ac_'))\n  ? ' (using entityId mode with ac_...; if this fails, Composio may require a UUID connected account id)'\n  : (!val.tiktokValidUuid && val.rawTikTokId ? ' (invalid TikTok id)' : '');\nconst ytNote = (!val.youtubeValidUuid && val.rawYouTubeId && val.rawYouTubeId.startsWith('ac_'))\n  ? ' (using entityId mode with ac_...; if this fails, Composio may require a UUID connected account id)'\n  : (!val.youtubeValidUuid && val.rawYouTubeId ? ' (invalid YouTube id)' : '');\n\nconst ig = statusFrom('Composio - Instagram Reels');\nconst tt = (base.tiktokConnectedAccountUuid || base.tiktokEntityId)\n  ? statusFrom('Composio - TikTok')\n  : { status: 'Skipped', detail: 'TikTok account not set' };\nconst yt = (base.youtubeConnectedAccountUuid || base.youtubeEntityId)\n  ? statusFrom('Composio - YouTube Shorts')\n  : { status: 'Skipped', detail: 'YouTube account not set' };\n\nconst lines = [\n  'VIDEO POST RESULTS',\n  '',\n  `Instagram Reels: ${ig.status}${ig.detail ? ` (${ig.detail})` : ''}`,\n  `TikTok: ${tt.status}${ttNote}${tt.detail ? ` (${tt.detail})` : ''}`,\n  `YouTube Shorts: ${yt.status}${ytNote}${yt.detail ? ` (${yt.detail})` : ''}`,\n  '',\n  `Title: ${base.title || ''}`,\n  base.videoUrl ? `MP4: ${base.videoUrl}` : ''\n].filter(Boolean);\n\nreturn [{ json: { chatId, message: lines.join('\\n') } }];\n"
      },
      "id": "a0b1c2d3-e4f5-6789-abcd-000000000086",
      "name": "Check Video Post Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1900,
        -80
      ],
      "onError": "continueErrorOutput"
    },
    {
      "id": "3dfc9d09-e1b7-493b-9ec7-7d4f69ea1682",
      "name": "Lookup YouTube Connected Account",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        940,
        -200
      ],
      "continueOnFail": true,
      "parameters": {
        "method": "GET",
        "url": "={{ \"https://backend.composio.dev/api/v3/connected_accounts?toolkit_slugs=youtube&auth_config_ids=\" + encodeURIComponent(String($json.connectedAccountValidation?.rawYouTubeId || $json.connectedAccountValidation?.rawYouTubeId || \"\").trim()) + \"&limit=5\" }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "ak_p_o5n04j9WB8LmAwoRfx"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "options": {
          "response": {
            "responseFormat": "json"
          }
        }
      }
    },
    {
      "id": "acb2add1-5cc1-4745-b5db-e8976acc2dd6",
      "name": "Apply YouTube Connected Account",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        -200
      ],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const base = $('Prepare Video Post Data').first().json || {};\nconst resp = $input.first().json;\n\n// Response shapes: {items:[...]} or {data:[...]} or [...].\nlet items = [];\nif (Array.isArray(resp)) items = resp;\nelse if (Array.isArray(resp?.items)) items = resp.items;\nelse if (Array.isArray(resp?.data)) items = resp.data;\nelse if (Array.isArray(resp?.connected_accounts)) items = resp.connected_accounts;\n\nconst uuidRe = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nlet found = '';\nfor (const it of items) {\n  const id = String(it?.id || it?.connectedAccountId || it?.connected_account_id || '').trim();\n  if (uuidRe.test(id)) { found = id; break; }\n}\n\n// If v3 returns nothing, keep whatever we already had.\nconst merged = { ...base };\nif (found && !merged.youtubeConnectedAccountUuid) {\n  merged.youtubeConnectedAccountUuid = found;\n}\n\nreturn [{ json: merged }];\n"
      }
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst apiKey = String($('TEST_KEYS').first().json.falKey || '').trim();\nconst modelPath = 'fal-ai/nano-banana-pro';\nconst headers = { Authorization: 'Key ' + apiKey };\n\nconst pollIntervalMs = 2000;\nconst maxChecks = 220;\nconst maxWaitMs = 600000;\nconst resultRetryCount = 8;\nconst transientCodes = new Set([404, 409, 422, 425, 429]);\n\nconst httpRequest =\n  (typeof $httpRequest === 'function' && $httpRequest) ||\n  (this && this.helpers && typeof this.helpers.httpRequest === 'function'\n    ? this.helpers.httpRequest.bind(this)\n    : null);\n\nif (!httpRequest) {\n  throw new Error('n8n HTTP helper is unavailable in this Code node runtime.');\n}\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nfunction getStatusCode(err) {\n  const candidates = [\n    err?.statusCode,\n    err?.status,\n    err?.httpCode,\n    err?.response?.statusCode,\n    err?.response?.status\n  ];\n  for (const c of candidates) {\n    const n = Number(c);\n    if (Number.isFinite(n)) return n;\n  }\n\n  const msg = String(err?.message || '');\n  const m = msg.match(/status\\s*code\\s*(\\d{3})/i) || msg.match(/\\b(\\d{3})\\b/);\n  if (m?.[1]) {\n    const n = Number(m[1]);\n    if (Number.isFinite(n)) return n;\n  }\n  return null;\n}\n\nfunction safeJson(v, maxLen = 500) {\n  try {\n    const s = JSON.stringify(v);\n    if (!s) return '';\n    return s.length > maxLen ? s.slice(0, maxLen) + '...' : s;\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction errText(err) {\n  const base = String(err?.message || err || 'unknown error');\n  const status = getStatusCode(err);\n  const body = safeJson(err?.response?.body || err?.body || err?.data || null);\n  return base + (status ? (' [status ' + status + ']') : '') + (body ? (' body=' + body) : '');\n}\n\nfunction readStatus(json) {\n  // Do not use nested result.status here; it can report completed before assets are fetchable.\n  return String(\n    (json &&\n      (json.status ||\n        json.request_status ||\n        json.state ||\n        json.phase ||\n        (json.data && json.data.status))) ||\n      ''\n  ).toUpperCase();\n}\n\nfunction readQueuePos(json) {\n  const v = json?.queue_position ?? json?.data?.queue_position ?? null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction normalizeImages(payload) {\n  const out = [];\n  const seen = new Set();\n\n  function pushUrl(v) {\n    const u = String(v || '').trim();\n    if (!u || !/^https?:\\/\\//i.test(u) || seen.has(u)) return;\n    seen.add(u);\n    out.push({ url: u });\n  }\n\n  function consume(node, depth = 0) {\n    if (!node || depth > 6) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) consume(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      pushUrl(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    if (typeof node.url === 'string') pushUrl(node.url);\n    if (typeof node.image_url === 'string') pushUrl(node.image_url);\n    if (typeof node.imageUrl === 'string') pushUrl(node.imageUrl);\n\n    if (Array.isArray(node.images)) consume(node.images, depth + 1);\n    if (Array.isArray(node.outputs)) consume(node.outputs, depth + 1);\n    if (Array.isArray(node.output)) consume(node.output, depth + 1);\n\n    if (node.data) consume(node.data, depth + 1);\n    if (node.result) consume(node.result, depth + 1);\n    if (node.response) consume(node.response, depth + 1);\n    if (node.image) consume(node.image, depth + 1);\n  }\n\n  consume(payload);\n  return out;\n}\n\nfunction buildFallbackStatusUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId) + '/status';\n}\n\nfunction buildFallbackResultUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId);\n}\n\nasync function getStatusByUrl(statusUrl, requestId) {\n  const url = statusUrl || buildFallbackStatusUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function getResultByUrl(responseUrl, requestId) {\n  const url = responseUrl || buildFallbackResultUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function waitForOne(item) {\n  const inputJson = item.json || {};\n  const requestId = inputJson.request_id || inputJson.requestId;\n  const statusUrl = String(inputJson.status_url || inputJson.statusUrl || '').trim();\n  const responseUrl = String(inputJson.response_url || inputJson.responseUrl || '').trim();\n\n  const syncImages = normalizeImages(inputJson);\n  if (syncImages.length) {\n    return { json: { ...inputJson, images: syncImages, falStatus: 'COMPLETED_SYNC', falPollAttempts: 0 } };\n  }\n\n  if (!requestId && !statusUrl && !responseUrl) {\n    throw new Error('fal.ai submit did not return request_id/status_url/response_url.');\n  }\n\n  const startedAt = Date.now();\n  let attempts = 0;\n  let statusValue = '';\n  let lastQueuePosition = null;\n\n  while (attempts < maxChecks && (Date.now() - startedAt) < maxWaitMs) {\n    attempts++;\n\n    let statusJson;\n    try {\n      statusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(statusJson);\n      lastQueuePosition = readQueuePos(statusJson);\n    } catch (err) {\n      const code = getStatusCode(err);\n      if (transientCodes.has(code)) {\n        statusValue = statusValue || 'IN_QUEUE';\n      } else {\n        throw new Error('fal.ai status request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n      }\n    }\n\n    if (statusValue === 'COMPLETED') break;\n    if (['FAILED', 'ERROR', 'CANCELLED'].includes(statusValue)) {\n      throw new Error('fal.ai request ' + (requestId || 'unknown') + ' failed with status ' + statusValue + '.');\n    }\n\n    const elapsed = Date.now() - startedAt;\n    const remaining = maxWaitMs - elapsed;\n    if (remaining <= 0) break;\n    await sleep(Math.min(pollIntervalMs, remaining));\n  }\n\n  if (statusValue !== 'COMPLETED') {\n    try {\n      const finalStatusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(finalStatusJson) || statusValue;\n      lastQueuePosition = readQueuePos(finalStatusJson) ?? lastQueuePosition;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  let resultJson = null;\n  const tryGetResult = async () => {\n    for (let i = 0; i < resultRetryCount; i++) {\n      try {\n        const res = await getResultByUrl(responseUrl, requestId || '');\n        if (res && typeof res === 'object') return res;\n      } catch (err) {\n        const code = getStatusCode(err);\n        if (!transientCodes.has(code)) {\n          throw new Error('fal.ai result request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n        }\n      }\n      await sleep(Math.min(1200 + i * 300, 3000));\n    }\n    return null;\n  };\n\n  if (statusValue === 'COMPLETED') {\n    resultJson = await tryGetResult();\n  } else {\n    try {\n      const possible = await tryGetResult();\n      const hasImages = normalizeImages(possible).length > 0;\n      if (hasImages) {\n        resultJson = possible;\n        statusValue = 'COMPLETED_LATE';\n      }\n    } catch (e) {\n      // no-op\n    }\n  }\n\n  if (!resultJson || typeof resultJson !== 'object') {\n    const seconds = Math.max(1, Math.round((Date.now() - startedAt) / 1000));\n    // Do not fail the whole workflow if the portrait result isn't ready yet.\n    // Downstream will fall back to the original creator profile image.\n    return {\n      json: {\n        ...inputJson,\n        request_id: requestId || inputJson.request_id || '',\n        images: [],\n        falStatus: 'TIMEOUT',\n        falPollAttempts: attempts,\n        falError:\n          'fal.ai founder portrait request ' + (requestId || 'unknown') +\n          ' not ready after ' + attempts + ' checks (~' + seconds + 's), status=' + (statusValue || 'IN_QUEUE') +\n          ', queue_position=' + (lastQueuePosition == null ? 'n/a' : lastQueuePosition) +\n          '. Using fallback profile image.'\n      }\n    };\n  }\n\n  const normalized = normalizeImages(resultJson);\n  const merged = {\n    ...inputJson,\n    ...resultJson,\n    images: normalized,\n    request_id: requestId || inputJson.request_id || '',\n    falStatus: statusValue || 'COMPLETED',\n    falPollAttempts: attempts,\n  };\n\n  if (!normalized.length) {\n    merged.falError = 'fal.ai completed but returned no image URLs in supported fields.';\n  }\n\n  return { json: merged };\n}\n\nconst out = [];\nlet lastError = null;\n\nfor (const item of items) {\n  try {\n    out.push(await waitForOne(item));\n  } catch (err) {\n    lastError = err;\n    out.push({\n      json: {\n        ...(item.json || {}),\n        falStatus: 'ERROR',\n        falError: String(err.message || err),\n        images: []\n      }\n    });\n  }\n}\n\nconst anyImages = out.some((o) => {\n  const j = o.json || {};\n  return Array.isArray(j.images) && j.images.length > 0;\n});\n\n// If the founder portrait failed, keep going; downstream will use the original creator image.\nreturn out;",
        "mode": "runOnceForAllItems",
        "language": "javaScript"
      },
      "id": "8c9f08ec-92b0-4bc8-a746-1bcdc935fbd7",
      "name": "fal.ai - Await Founder Portrait Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1540,
        520
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://queue.fal.run/fal-ai/nano-banana-pro/edit",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Key ' + $('TEST_KEYS').first().json.falKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  prompt: $json.sceneImagePrompt || $json.videoPrompt || $json.visualPrompt || 'Photorealistic UK healthcare scene, vertical 9:16',\n  image_urls: (($json.creatorImageUrls && $json.creatorImageUrls.length) ? $json.creatorImageUrls : [ $json.creatorImageUrl ]),\n  num_images: 1,\n  aspect_ratio: '9:16',\n  output_format: 'png',\n  resolution: '1K',\n  safety_tolerance: '4',\n  limit_generations: true\n}) }}",
        "options": {
          "timeout": 240000
        }
      },
      "id": "generate-scene-image-v1",
      "name": "fal.ai - Generate Scene Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1500,
        400
      ],
      "onError": "continueErrorOutput",
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2500
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst apiKey = String($('TEST_KEYS').first().json.falKey || '').trim();\nconst modelPath = 'fal-ai/nano-banana-pro';\nconst headers = { Authorization: 'Key ' + apiKey };\n\nconst pollIntervalMs = 2000;\nconst maxChecks = 220;\nconst maxWaitMs = 600000;\nconst resultRetryCount = 8;\nconst transientCodes = new Set([404, 409, 422, 425, 429]);\n\nconst httpRequest =\n  (typeof $httpRequest === 'function' && $httpRequest) ||\n  (this && this.helpers && typeof this.helpers.httpRequest === 'function'\n    ? this.helpers.httpRequest.bind(this)\n    : null);\n\nif (!httpRequest) {\n  throw new Error('n8n HTTP helper is unavailable in this Code node runtime.');\n}\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nfunction getStatusCode(err) {\n  const candidates = [\n    err?.statusCode,\n    err?.status,\n    err?.httpCode,\n    err?.response?.statusCode,\n    err?.response?.status\n  ];\n  for (const c of candidates) {\n    const n = Number(c);\n    if (Number.isFinite(n)) return n;\n  }\n\n  const msg = String(err?.message || '');\n  const m = msg.match(/status\\s*code\\s*(\\d{3})/i) || msg.match(/\\b(\\d{3})\\b/);\n  if (m?.[1]) {\n    const n = Number(m[1]);\n    if (Number.isFinite(n)) return n;\n  }\n  return null;\n}\n\nfunction safeJson(v, maxLen = 500) {\n  try {\n    const s = JSON.stringify(v);\n    if (!s) return '';\n    return s.length > maxLen ? s.slice(0, maxLen) + '...' : s;\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction errText(err) {\n  const base = String(err?.message || err || 'unknown error');\n  const status = getStatusCode(err);\n  const body = safeJson(err?.response?.body || err?.body || err?.data || null);\n  return base + (status ? (' [status ' + status + ']') : '') + (body ? (' body=' + body) : '');\n}\n\nfunction readStatus(json) {\n  // Do not use nested result.status here; it can report completed before assets are fetchable.\n  return String(\n    (json &&\n      (json.status ||\n        json.request_status ||\n        json.state ||\n        json.phase ||\n        (json.data && json.data.status))) ||\n      ''\n  ).toUpperCase();\n}\n\nfunction readQueuePos(json) {\n  const v = json?.queue_position ?? json?.data?.queue_position ?? null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction normalizeImages(payload) {\n  const out = [];\n  const seen = new Set();\n\n  function pushUrl(v) {\n    const u = String(v || '').trim();\n    if (!u || !/^https?:\\/\\//i.test(u) || seen.has(u)) return;\n    seen.add(u);\n    out.push({ url: u });\n  }\n\n  function consume(node, depth = 0) {\n    if (!node || depth > 6) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) consume(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      pushUrl(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    if (typeof node.url === 'string') pushUrl(node.url);\n    if (typeof node.image_url === 'string') pushUrl(node.image_url);\n    if (typeof node.imageUrl === 'string') pushUrl(node.imageUrl);\n\n    if (Array.isArray(node.images)) consume(node.images, depth + 1);\n    if (Array.isArray(node.outputs)) consume(node.outputs, depth + 1);\n    if (Array.isArray(node.output)) consume(node.output, depth + 1);\n\n    if (node.data) consume(node.data, depth + 1);\n    if (node.result) consume(node.result, depth + 1);\n    if (node.response) consume(node.response, depth + 1);\n    if (node.image) consume(node.image, depth + 1);\n  }\n\n  consume(payload);\n  return out;\n}\n\nfunction buildFallbackStatusUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId) + '/status';\n}\n\nfunction buildFallbackResultUrl(requestId) {\n  return 'https://queue.fal.run/' + modelPath + '/requests/' + encodeURIComponent(requestId);\n}\n\nasync function getStatusByUrl(statusUrl, requestId) {\n  const url = statusUrl || buildFallbackStatusUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function getResultByUrl(responseUrl, requestId) {\n  const url = responseUrl || buildFallbackResultUrl(requestId);\n  return await httpRequest({ method: 'GET', url, headers, json: true });\n}\n\nasync function waitForOne(item) {\n  const inputJson = item.json || {};\n  const requestId = inputJson.request_id || inputJson.requestId;\n  const statusUrl = String(inputJson.status_url || inputJson.statusUrl || '').trim();\n  const responseUrl = String(inputJson.response_url || inputJson.responseUrl || '').trim();\n\n  const syncImages = normalizeImages(inputJson);\n  if (syncImages.length) {\n    return { json: { ...inputJson, images: syncImages, falStatus: 'COMPLETED_SYNC', falPollAttempts: 0 } };\n  }\n\n  if (!requestId && !statusUrl && !responseUrl) {\n    throw new Error('fal.ai submit did not return request_id/status_url/response_url.');\n  }\n\n  const startedAt = Date.now();\n  let attempts = 0;\n  let statusValue = '';\n  let lastQueuePosition = null;\n\n  while (attempts < maxChecks && (Date.now() - startedAt) < maxWaitMs) {\n    attempts++;\n\n    let statusJson;\n    try {\n      statusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(statusJson);\n      lastQueuePosition = readQueuePos(statusJson);\n    } catch (err) {\n      const code = getStatusCode(err);\n      if (transientCodes.has(code)) {\n        statusValue = statusValue || 'IN_QUEUE';\n      } else {\n        throw new Error('fal.ai status request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n      }\n    }\n\n    if (statusValue === 'COMPLETED') break;\n    if (['FAILED', 'ERROR', 'CANCELLED'].includes(statusValue)) {\n      throw new Error('fal.ai request ' + (requestId || 'unknown') + ' failed with status ' + statusValue + '.');\n    }\n\n    const elapsed = Date.now() - startedAt;\n    const remaining = maxWaitMs - elapsed;\n    if (remaining <= 0) break;\n    await sleep(Math.min(pollIntervalMs, remaining));\n  }\n\n  if (statusValue !== 'COMPLETED') {\n    try {\n      const finalStatusJson = await getStatusByUrl(statusUrl, requestId || '');\n      statusValue = readStatus(finalStatusJson) || statusValue;\n      lastQueuePosition = readQueuePos(finalStatusJson) ?? lastQueuePosition;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  let resultJson = null;\n  const tryGetResult = async () => {\n    for (let i = 0; i < resultRetryCount; i++) {\n      try {\n        const res = await getResultByUrl(responseUrl, requestId || '');\n        if (res && typeof res === 'object') return res;\n      } catch (err) {\n        const code = getStatusCode(err);\n        if (!transientCodes.has(code)) {\n          throw new Error('fal.ai result request failed for request ' + (requestId || 'unknown') + ': ' + errText(err));\n        }\n      }\n      await sleep(Math.min(1200 + i * 300, 3000));\n    }\n    return null;\n  };\n\n  if (statusValue === 'COMPLETED') {\n    resultJson = await tryGetResult();\n  } else {\n    try {\n      const possible = await tryGetResult();\n      const hasImages = normalizeImages(possible).length > 0;\n      if (hasImages) {\n        resultJson = possible;\n        statusValue = 'COMPLETED_LATE';\n      }\n    } catch (e) {\n      // no-op\n    }\n  }\n\n  if (!resultJson || typeof resultJson !== 'object') {\n    const seconds = Math.max(1, Math.round((Date.now() - startedAt) / 1000));\n    // Do not fail the whole workflow if the portrait result isn't ready yet.\n    // Downstream will fall back to the original creator profile image.\n    return {\n      json: {\n        ...inputJson,\n        request_id: requestId || inputJson.request_id || '',\n        images: [],\n        falStatus: 'TIMEOUT',\n        falPollAttempts: attempts,\n        falError:\n          'fal.ai scene image request ' + (requestId || 'unknown') +\n          ' not ready after ' + attempts + ' checks (~' + seconds + 's), status=' + (statusValue || 'IN_QUEUE') +\n          ', queue_position=' + (lastQueuePosition == null ? 'n/a' : lastQueuePosition) +\n          '. Using fallback profile image.'\n      }\n    };\n  }\n\n  const normalized = normalizeImages(resultJson);\n  const merged = {\n    ...inputJson,\n    ...resultJson,\n    images: normalized,\n    request_id: requestId || inputJson.request_id || '',\n    falStatus: statusValue || 'COMPLETED',\n    falPollAttempts: attempts,\n  };\n\n  if (!normalized.length) {\n    merged.falError = 'fal.ai completed but returned no image URLs in supported fields.';\n  }\n\n  return { json: merged };\n}\n\nconst out = [];\nlet lastError = null;\n\nfor (const item of items) {\n  try {\n    out.push(await waitForOne(item));\n  } catch (err) {\n    lastError = err;\n    out.push({\n      json: {\n        ...(item.json || {}),\n        falStatus: 'ERROR',\n        falError: String(err.message || err),\n        images: []\n      }\n    });\n  }\n}\n\nconst anyImages = out.some((o) => {\n  const j = o.json || {};\n  return Array.isArray(j.images) && j.images.length > 0;\n});\n\n// If the scene image failed, keep going; downstream will use the original creator image.\nreturn out;"
      },
      "id": "await-scene-image-result-v1",
      "name": "fal.ai - Await Scene Image Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1560,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first().json || {};\n\nfunction looksLikeDirectImageUrl(v) {\n  const u = String(v || '').trim();\n  const lower = u.toLowerCase();\n\n  if (!(lower.startsWith('http://') || lower.startsWith('https://'))) return false;\n  if (lower.includes('queue.fal.run') && lower.includes('/requests/')) return false;\n  if (lower.includes('/status')) return false;\n  if (lower.includes('/cancel')) return false;\n\n  const bare = lower.split('?')[0].split('#')[0];\n  if (bare.endsWith('.png') || bare.endsWith('.jpg') || bare.endsWith('.jpeg') || bare.endsWith('.webp')) return true;\n  if (lower.includes('fal.media/files/')) return true;\n  if (lower.includes('fal.media/')) return true;\n\n  return false;\n}\n\nfunction pickUrl(payload) {\n  const urls = [];\n  const seen = new Set();\n\n  function push(v) {\n    const u = String(v || '').trim();\n    if (!u || seen.has(u) || !looksLikeDirectImageUrl(u)) return;\n    seen.add(u);\n    urls.push(u);\n  }\n\n  function walk(node, depth = 0) {\n    if (node == null || depth > 7) return;\n\n    if (Array.isArray(node)) {\n      for (const x of node) walk(x, depth + 1);\n      return;\n    }\n\n    if (typeof node === 'string') {\n      push(node);\n      return;\n    }\n\n    if (typeof node !== 'object') return;\n\n    push(node.url);\n    push(node.image_url);\n    push(node.imageUrl);\n\n    walk(node.images, depth + 1);\n    walk(node.output, depth + 1);\n    walk(node.outputs, depth + 1);\n    walk(node.result, depth + 1);\n    walk(node.data, depth + 1);\n    walk(node.response, depth + 1);\n\n    for (const v of Object.values(node)) {\n      if (v && typeof v === 'object') walk(v, depth + 1);\n    }\n  }\n\n  walk(payload);\n  return urls[0] || '';\n}\n\nconst sceneImageUrl = pickUrl(item);\n\nreturn [{\n  json: {\n    ...item,\n    sceneImageUrl: sceneImageUrl || String(item.creatorImageUrl || '').trim(),\n    sceneImageSource: sceneImageUrl ? 'generated_scene_image' : 'fallback_creator_image'\n  }\n}];\n"
      },
      "id": "resolve-scene-image-url-v1",
      "name": "Resolve Scene Image URL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1620,
        400
      ],
      "onError": "continueErrorOutput"
    },
    {
      "id": "c9c7aa3b-538c-4f1a-821a-f1fd2a652639",
      "name": "Restore Payload After Voiceover",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        280
      ],
      "parameters": {
        "jsCode": "// ElevenLabs HTTP Request (responseFormat=file) can drop upstream JSON fields.\n// Reattach the real video payload so downstream nodes always have creatorImageUrl(s), args, title, etc.\nconst base = $('Restore Video Payload').first().json || {};\nconst current = $input.first();\n\nreturn [{\n  json: {\n    ...base,\n    ...(current?.json || {})\n  },\n  binary: current?.binary\n}];\n"
      }
    },
    {
      "parameters": {
        "keepOnlySet": false,
        "values": {
          "string": [
            {
              "name": "openrouterKey",
              "value": ""
            },
            {
              "name": "falKey",
              "value": ""
            },
            {
              "name": "elevenLabsKey",
              "value": ""
            },
            {
              "name": "githubPat",
              "value": ""
            },
            {
              "name": "composioKey",
              "value": ""
            }
          ]
        },
        "options": {}
      },
      "id": "acb0ee18-41ad-4208-a791-874b512f31be",
      "name": "TEST_KEYS",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        -428,
        400
      ]
    }
  ],
  "connections": {
    "Telegram Trigger": {
      "main": [
        [
          {
            "node": "TEST_KEYS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Chat History": {
      "main": [
        [
          {
            "node": "Callback Ack Gate",
            "type": "main",
            "index": 0
          },
          {
            "node": "Is Slash Command?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Slash Command?": {
      "main": [
        [
          {
            "node": "Quick Parse Slash",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Quick Parse Slash": {
      "main": [
        [
          {
            "node": "Handle Auto Mode Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Conversation": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Quick Parse Slash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response": {
      "main": [
        [
          {
            "node": "Ensure Action Intent",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send AI Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Action Router": {
      "main": [
        [
          {
            "node": "Prepare Carousel Args",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Video Args",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Carousel Args",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Video Args",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OpenRouter - Trends",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Approval",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Regeneration",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Status Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Help Response",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Prepare Carousel Args": {
      "main": [
        [
          {
            "node": "Research for Carousel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Research for Carousel": {
      "main": [
        [
          {
            "node": "Parse Carousel Research",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Carousel Research": {
      "main": [
        [
          {
            "node": "OpenRouter - Carousel Script",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Video Args": {
      "main": [
        [
          {
            "node": "Research for Video",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Research for Video": {
      "main": [
        [
          {
            "node": "Parse Video Research",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Video Research": {
      "main": [
        [
          {
            "node": "OpenRouter - Video Script",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Scheduled Trends Prep",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scheduled Trends Prep": {
      "main": [
        [
          {
            "node": "Action Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter - Carousel Script": {
      "main": [
        [
          {
            "node": "Parse Carousel Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter - Video Script": {
      "main": [
        [
          {
            "node": "Parse Video Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter - Trends": {
      "main": [
        [
          {
            "node": "Parse Trends Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse Trends Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Carousel Response": {
      "main": [
        [
          {
            "node": "Carousel - Status Update",
            "type": "main",
            "index": 0
          },
          {
            "node": "Split Slides",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Video Response": {
      "main": [
        [
          {
            "node": "Video - Status Update",
            "type": "main",
            "index": 0
          },
          {
            "node": "Restore Video Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Trends Response": {
      "main": [
        [
          {
            "node": "Format Trend Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Carousel - Status Update": {
      "main": [
        []
      ]
    },
    "Split Slides": {
      "main": [
        [
          {
            "node": "Build fal.ai Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "fal.ai - Submit Image": {
      "main": [
        [
          {
            "node": "fal.ai - Await Image Result",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Images": {
      "main": [
        [
          {
            "node": "Package Carousel Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Package Carousel Data": {
      "main": [
        [
          {
            "node": "Store Pending Carousel",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Pending Carousel": {
      "main": [
        [
          {
            "node": "Send Carousel for Approval",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Carousel for Approval": {
      "main": [
        [
          {
            "node": "Split Remaining Images",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Remaining Images": {
      "main": [
        [
          {
            "node": "Download Carousel Image Binary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video - Status Update": {
      "main": [
        []
      ]
    },
    "ElevenLabs - Create Voiceover": {
      "main": [
        [
          {
            "node": "Restore Payload After Voiceover",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Video Scenes": {
      "main": [
        [
          {
            "node": "Collect All Clips",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect All Clips": {
      "main": [
        [
          {
            "node": "Package Video Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Package Video Data": {
      "main": [
        [
          {
            "node": "Prepare Render Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Approval": {
      "main": [
        [
          {
            "node": "Content Type Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Content Type Router": {
      "main": [
        [
          {
            "node": "Approval Confirmed",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Video Post Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Approval Confirmed": {
      "main": [
        [
          {
            "node": "Prepare Post Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Post Data": {
      "main": [
        [
          {
            "node": "Composio - Instagram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - Instagram": {
      "main": [
        [
          {
            "node": "Composio - LinkedIn",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - LinkedIn": {
      "main": [
        [
          {
            "node": "Composio - X/Twitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - X/Twitter": {
      "main": [
        [
          {
            "node": "Check Post Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Post Results": {
      "main": [
        [
          {
            "node": "Post Results Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Regeneration": {
      "main": [
        [
          {
            "node": "Regen Type Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Regen Type Router": {
      "main": [
        [
          {
            "node": "Regeneration Started",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Video Regen Started",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Regeneration Started": {
      "main": [
        [
          {
            "node": "Prepare Carousel Args",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video Regen Started": {
      "main": [
        [
          {
            "node": "Prepare Video Args",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure Action Intent": {
      "main": [
        [
          {
            "node": "Action Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Trend Message": {
      "main": [
        [
          {
            "node": "Auto Continue From Trends",
            "type": "main",
            "index": 0
          },
          {
            "node": "Trends - Send Topic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trends - Send Topic": {
      "main": [
        [],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "fal.ai - Await Image Result": {
      "main": [
        [
          {
            "node": "Collect Images",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto Continue From Trends": {
      "main": [
        [
          {
            "node": "Action Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build fal.ai Prompt": {
      "main": [
        [
          {
            "node": "fal.ai - Submit Image",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Auto Mode Commands": {
      "main": [
        [
          {
            "node": "Ensure Action Intent",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send AI Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Remaining Images": {
      "main": [
        [],
        [
          {
            "node": "Send Image URL Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Carousel Image Binary": {
      "main": [
        [
          {
            "node": "Send Remaining Images",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Image URL Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resolve Founder Portrait URL": {
      "main": [
        [
          {
            "node": "Prepare Video Scenes",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Callback Ack Gate": {
      "main": [
        [
          {
            "node": "Answer Callback Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remotion Callback Webhook": {
      "main": [
        [
          {
            "node": "Normalize Render Callback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Render Callback": {
      "main": [
        [
          {
            "node": "Render Callback Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Render Data": {
      "main": [
        [
          {
            "node": "Trigger GitHub Actions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger GitHub Actions": {
      "main": [
        [
          {
            "node": "Video - Rendering Status",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Render Callback Router": {
      "main": [
        [
          {
            "node": "Download Rendered Video Binary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Render Callback To Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Video Post Data": {
      "main": [
        [
          {
            "node": "Video Post Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video Posting Started": {
      "main": [
        [
          {
            "node": "Composio - Instagram Reels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - Instagram Reels": {
      "main": [
        [
          {
            "node": "Composio - TikTok",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - TikTok": {
      "main": [
        [
          {
            "node": "Composio - YouTube Shorts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Composio - YouTube Shorts": {
      "main": [
        [
          {
            "node": "Check Video Post Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Video Post Results": {
      "main": [
        [
          {
            "node": "Post Results Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video Post Router": {
      "main": [
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Lookup YouTube Connected Account",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lookup YouTube Connected Account": {
      "main": [
        [
          {
            "node": "Apply YouTube Connected Account",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply YouTube Connected Account": {
      "main": [
        [
          {
            "node": "Video Posting Started",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Rendered Video Binary": {
      "main": [
        [
          {
            "node": "Send Rendered Video To Telegram",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Render Callback To Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Video Payload": {
      "main": [
        [
          {
            "node": "ElevenLabs - Create Voiceover",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Payload After Voiceover": {
      "main": [
        [
          {
            "node": "Resolve Founder Portrait URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TEST_KEYS": {
      "main": [
        [
          {
            "node": "Load Chat History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 2
}